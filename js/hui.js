define('hui/core/position',[], function() {
    // 0-999 are for application elements
    // 10,000+ are for dynamically displayed popup/modal elements
    var baseZindex = 10000,
        topZindex = baseZindex;

    /**
     * Determines if the element has non-zero offsetWidth and offsetHeight.
     * @param  {HTMLElement} elem Element to detect width and height
     * @return {Boolean}      True if the element has non-zero width and height
     */
    function _hasDimension(elem) {
        return (elem.offsetWidth > 0) && (elem.offsetHeight > 0);
    }

    return {
        /**
         * The base z-index value that will be used for dynamically displayed elements.
         * topZindex starts at this value and increments each time it is accessed.
         */
        get baseZindex() {
            return baseZindex;
        },

        set baseZindex(value) {
            if (baseZindex !== topZindex) {
                console.warn('The global z-index is already in use; baseZindex should be set at application initialization');
            } else {
                topZindex = value;
            }

            baseZindex = value;
        },

        /**
         * The highest z-index value in use (auto-increments each time it is accessed)
         * This value should be used by elements that need to display at the top of the z-index stack.
         * It is used by the 'bringToFront' method.
         */
        getTopZindex: function() {
            return topZindex++;
        },

        /**
         * Display an element in front of all other elements.
         * This is dependent on static CSS z-index values being below the value of 'baseZindex', and dynamically
         * assigned z-index values being assigned from 'topZindex'.
         * WARNING: To ensure that the element can display on top regardless of overflow or stacking context in
         * ancestors, it will be relocated to be a direct child of the document.body if it is not already.
         * @param {HTMLElement} element The element to display in front
         */
        bringToFront: function(element) {
            if (element.parentNode !== element.ownerDocument.body) {
                element.ownerDocument.body.appendChild(element);
            }

            element.style.zIndex = this.getTopZindex();
        },

        /**
         * Makes calculations for box-shadow sizes
         * @param  {HTMLElmenet} element Element source for box-shadow sizes
         * @return {object} object.top {Number}
         *                  object.bottom {Number}
         *                  object.left {Number}
         *                  object.right {Number}
         */
        getBoxShadowSize: function(element) {
            var style = window.getComputedStyle(element),
                shadowSize,
                shadowSizeArray,
                hShadow,
                vShadow,
                spread,
                blur,
                result = {
                    left: 0,
                    right: 0,
                    top: 0,
                    bottom: 0
                };

            shadowSize = style.getPropertyValue('box-shadow');
            if (shadowSize === 'none') {
                return result;
            }

            // Remove all possible color definitions
            shadowSize = shadowSize.replace(/rgba?\([^\)]+\)/gi, '');
            shadowSize = shadowSize.replace(/#[0-9a-f]+/gi, '');

            // Remove any alpha characters
            shadowSize = shadowSize.replace(/[a-z]+/gi, '').trim();

            shadowSizeArray = shadowSize.split(' ');

            // Some browsers (IE) don't include a default value (0) for unspecified properties
            hShadow = shadowSizeArray.length > 0 ? parseInt(shadowSizeArray[0], 10) : 0;
            vShadow = shadowSizeArray.length > 1 ? parseInt(shadowSizeArray[1], 10) : 0;
            blur = shadowSizeArray.length > 2 ? parseInt(shadowSizeArray[2], 10) : 0;
            spread = shadowSizeArray.length > 3 ? parseInt(shadowSizeArray[3], 10) : 0;

            result.left = Math.max(spread - hShadow + 0.5 * blur, 0);
            result.right = Math.max(spread + hShadow + 0.5 * blur, 0);
            result.top = Math.max(spread - vShadow + 0.5 * blur, 0);
            result.bottom = Math.max(spread + vShadow + 0.5 * blur, 0);

            return result;

        },

        /**
         * Retrieves the dimensions of the object.
         *
         * @param {HTMLElement} elem The element which we want to get the dimension.
         *
         * @return {Object} object.width {Number}
         *                  object.height {Number}
         */
        getDimension: function(elem) {
            var dimensions = {},
                style = {
                    'position': '',
                    'display': '',
                    'top': '',
                    'left': ''
                },
                moved = false,
                domRect,
                rect = {},
                key = '';

            // If we have dimensions we can just use it.
            if (!_hasDimension(elem)) {
                domRect = elem.getBoundingClientRect();

                if (!domRect.width || !domRect.height) {

                    // If we don't have dimensions we need to put the elem in a state
                    // that we can truly get the width and height and then restore
                    // everything.
                    moved = true;
                    for (key in style) {
                        style[key] = elem.style[key] || '';
                    }

                    // @TODO Maybe a better strategy here. The main issue with this
                    // is performance.
                    elem.style.position = 'absolute';
                    elem.style.left = '-1000px';
                    elem.style.top = '-1000px';
                    elem.style.display = 'inline-block';
                } else {
                    rect.width = domRect.width;
                    rect.height = domRect.height;
                }
            }

            dimensions = {
                width: rect.width || elem.offsetWidth,
                height: rect.height || elem.offsetHeight
            };

            if (moved) {
                for (key in style) {
                    elem.style[key] = style[key];
                }
            }

            return dimensions;

        },

        /**
         * Calculates document width and height in a crossbrowser way
         * @param  {HTMLElement} elementOwnerDocument ownerDocument property of an element contained in the document
         * @return {Object}         object.height   {Number}
         *                          object.width    {Number}
         */
        getPageSize: function(elementOwnerDocument) {
            var documentEl = elementOwnerDocument.documentElement,
                bodyEl = elementOwnerDocument.body;

            return {
                width: Math.max(
                    bodyEl.scrollWidth, documentEl.scrollWidth,
                    bodyEl.offsetWidth, documentEl.offsetWidth,
                    bodyEl.clientWidth, documentEl.clientWidth
                ),
                height: Math.max(
                    bodyEl.scrollHeight, documentEl.scrollHeight,
                    bodyEl.offsetHeight, documentEl.offsetHeight,
                    bodyEl.clientHeight, documentEl.clientHeight
                )
            };
        },

        /**
         * Retrieve the position and the dimensions of an element.
         *
         * @return {object} object.left {Number}
         *                  object.top {Number}
         *                  object.right {Number}
         *                  object.bottom {Number}
         *                  object.width {Number}
         *                  object.height {Number}
         */
        getPositionInDocument: function(elem) {
            var rect = elem.getBoundingClientRect(),
                // IE11 does not play nice with window.scrollX and window.scrollY
                scroll = {
                    x: window.pageXOffset || document.documentElement.scrollLeft,
                    y: window.pageYOffset || document.documentElement.scrollTop
                },
                // round values since some browsers (Firefox) like to provide double values
                result = {
                    left: Math.round(rect.left) + scroll.x,
                    right: Math.round(rect.right) + scroll.x,
                    top: Math.round(rect.top) + scroll.y,
                    bottom: Math.round(rect.bottom) + scroll.y,
                    width: Math.round(rect.width),
                    height: Math.round(rect.height)
                };

            return result;
        }
    };
});

/**
* This class exists for the sole purpose of being able to test the below methods.
* These methods need to be refactored and removed at a future date because the
* original author didn't structure them in a way that is healthy for long term support.
* Until that day comes, this class will exist. When the refactoring happens, I suggest
* the new logic get moved to position.js
*/
define('hui/core/popupPositionUtils',[
    './position'
], function(position) {
    /**
     * Determines if there is space between the popup and the parent on the top side. If there is space, or
     * the amount needed is equal to the amount available, the position is set to the avialable - needed. In the
     * case where they are equal, the currentPosition.y will be equal to the amount available.
     *
     * @param {object}    popup              Object containing information regarding size of the
     *                                       popup to be rendered.
     * @param {object}    currentPosition    Position for the popup when it is rendered. Contains both x and y
     *                                       directions.
     * @param {string}    currentPositionType Contains the string denoting which side we are calculating
     */
    function _tryTopPosition(popup, currentPosition, currentPositionType) {
        var finalMargin = popup.margin + popup.boxShadow.bottom,
            available = popup.spaceToNextObject.top,
            needed = popup.dimensions.height + finalMargin;

        if (needed <= available) {
            currentPositionType.position = 'top';
            currentPosition.y = available - needed;
        }
    }

    /**
     * Determines if there is space between the popup and the parent on the bottom side
     * @param {object}    popup              Object containing information regarding size of the
     *                                       popup to be rendered.
     * @param {object}    currentPosition    Position for the popup when it is rendered. Contains both x and y
     *                                       directions.
     * @param {string}    currentPositionType Contains the string denoting which side we are calculating
     */
    function _tryBottomPosition(popup, currentPosition, currentPositionType, force) {
        var finalMargin = popup.margin + popup.boxShadow.top,
            available = position.getPageSize(this.ownerDocument).height - popup.spaceToNextObject.bottom,
            needed = popup.dimensions.height + finalMargin;

        if ((needed < available) || force) {
            currentPositionType.position = 'bottom';
            currentPosition.y = popup.parentPosition.bottom + finalMargin;
        }
    }

    /**
     * Determines if there is space between the popup and the parent on the right side
     * @param {object}    popup              Object containing information regarding size of the
     *                                       popup to be rendered.
     * @param {object}    currentPosition    Position for the popup when it is rendered. Contains both x and y
     *                                       directions.
     * @param {string}    currentPositionType Contains the string denoting which side we are calculating
     */
    function _tryRightPosition(popup, currentPosition, currentPositionType) {
        var finalMargin = popup.margin + popup.boxShadow.left,
            available = position.getPageSize(this.ownerDocument).width - popup.spaceToNextObject.right,
            needed = popup.dimensions.width + finalMargin;

        if (needed < available) {
            currentPositionType.position = 'right';
            currentPosition.x = popup.parentPosition.right + finalMargin;
        }
    }

    /**
     * Determines if there is space between the popup and the parent on the left side. If the space needed is greater than available,
     * this method does nothing. If less than or equal to, position is set to left, and position in the x direction is set to available - needed
     * @param {object}    popup              Object containing information regarding size of the
     *                                       popup to be rendered.
     * @param {object}   currentPosition     Position for the popup when it is rendered. Contains both x and y
     *                                       directions.
     * @param {string}    currentPositionType Contains the string denoting which side we are calculating
     */
    function _tryLeftPosition(popup, currentPosition, currentPositionType) {
        var finalMargin = popup.margin + popup.boxShadow.right,
            available = popup.parentPosition.left,
            needed = popup.dimensions.width + finalMargin;

        if (needed <= available) {
            currentPositionType.position = 'left';
            currentPosition.x = available - needed;
        }
    }

    return {
        tryLeftPosition: _tryLeftPosition,
        tryRightPosition: _tryRightPosition,
        tryTopPosition: _tryTopPosition,
        tryBottomPosition: _tryBottomPosition
    };
});

/**
* This class exists for the sole purpose of being able to test the below methods.
* These methods need to be refactored and removed at a future date because the
* original author didn't structure them in a way that is healthy for long term support.
* Until that day comes, this class will exist. When the refactoring happens, I suggest
* the new logic get moved to position.js
*/

define('hui/core/popupAlignmentUtils',[
    './position'
], function(position) {
    /* -------- Alignment --------*/
    /**
     * Determines where the popup should align itself within relation to the parent on the left side.
     * currentPositionType.alignment is always set to left. currentPosition.x is set to parentPosition left if
     * needed < available. Otherwise, it is set to parentPosition.left - (needed - available)
     * @param {object}    popup              Object containing information regarding size of the
     *                                       popup to be rendered.
     * @param {object}    currentPosition    Position for the popup when it is rendered. Contains both x and y
     *                                       directions.
     * @param {string}    currentPositionType Contains the string denoting which side we are calculating
     */
    function _tryLeftAlignment(popup, currentPosition, currentPositionType) {
        var available = position.getPageSize(this.ownerDocument).width - popup.parentPosition.left,
            needed = popup.dimensions.width;

        currentPositionType.alignment = 'left';
        if (needed <= available) {
            currentPosition.x = popup.parentPosition.left;
        } else {
            currentPosition.x = popup.parentPosition.left - (needed - available);
        }
    }

    /**
     * Determines where the popup should align itself within relation to the parent in the center. Based on
     * how the popup aligns, we determine where to stick it. If it doesn't fit on a side, we set the x position
     * equal to 0
     * @param {object}    popup              Object containing information regarding size of the
     *                                       popup to be rendered.
     * @param {object}    currentPosition    Position for the popup when it is rendered. Contains both x and y
     *                                       directions.
     * @param {string}    currentPositionType Contains the string denoting which side we are calculating
     */
    function _tryCenterAlignment(popup, currentPosition, currentPositionType) {
        var available = position.getPageSize(this.ownerDocument).width,
            needed = popup.dimensions.width,
            halfChild,
            targetCenterPos;

        /* istanbul ignore else */
        if (needed < available) {
            currentPositionType.alignment = 'center';

            halfChild = popup.dimensions.width / 2;
            targetCenterPos = popup.parentPosition.left + (popup.parentPosition.width / 2);

            if (targetCenterPos > halfChild) {
                // Popup left half fits
                if (targetCenterPos + halfChild < available) {
                    // Popup fits centered
                    currentPosition.x = targetCenterPos - halfChild;
                } else {
                    // Popup doesn't fit on the right, so will be sticky to that side
                    currentPosition.x = available - popup.dimensions.width;
                }
            } else {
                // Popup doesn't fit on the left, so will be sticky to that side
                currentPosition.x = 0;
            }
        }
    }

    /**
     * Determines where the popup should align itself within relation to the parent on the right side. This method
     * will only set the alignment and position if the needed space is less than the available.
     * @param {object}    popup              Object containing information regarding size of the
     *                                       popup to be rendered.
     * @param {object}    currentPosition    Position for the popup when it is rendered. Contains both x and y
     *                                       directions.
     * @param {string}    currentPositionType Contains the string denoting which side we are calculating
     */
    function _tryRightAlignment(popup, currentPosition, currentPositionType) {
        var available = popup.parentPosition.right,
            needed = popup.dimensions.width;

        if (needed < available) {
            currentPositionType.alignment = 'right';
            currentPosition.x = popup.parentPosition.left - popup.dimensions.width + popup.parentPosition.width;
        }
    }

    /**
     * Determines where the popup should align itself within relation to the parent on the top. This will only set the
     * alignment if needed < available or force is used.
     * @param {object}    popup              Object containing information regarding size of the
     *                                       popup to be rendered.
     * @param {object}    currentPosition    Position for the popup when it is rendered. Contains both x and y
     *                                       directions.
     * @param {string}    currentPositionType Contains the string denoting which side we are calculating
     * @param {boolean}   force              Denotes if the top alignment should be set regardless of needed space vs available
     */
    function _tryTopAlignment(popup, currentPosition, currentPositionType, force) {
        var available = position.getPageSize(this.ownerDocument).height - popup.parentPosition.top,
            needed = popup.dimensions.height;

        if ((needed < available) || force) {
            currentPositionType.alignment = 'top';
            currentPosition.y = popup.parentPosition.top;
        }
    }

    /**
     * Determines where the popup should align itself within relation to the parent in the middle (not to be confused with center,
     * which relates to the vertical alignment). If the needed space is greater than the amount available, the positoin
     * is estimated by rounding the y direction to the available - the height of the parent. Otherwise, it is set to the top position
     * of the parent.
     * equal to 0
     * @param {object}    popup              Object containing information regarding size of the
     *                                       popup to be rendered.
     * @param {object}    currentPosition    Position for the popup when it is rendered. Contains both x and y
     *                                       directions.
     * @param {string}    currentPositionType Contains the string denoting which side we are calculating
     */
    function _tryMiddleAlignment(popup, currentPosition, currentPositionType) {
        var available = position.getPageSize(this.ownerDocument).height,
            child,
            targetPos;

        currentPositionType.alignment = 'middle';

        child = popup.dimensions.height;
        targetPos = popup.parentPosition.top;

        // Popup top half fits
        if (targetPos + child < available) {
            // Popup fits centered
            currentPosition.y = targetPos;
        } else {
            // Popup doesn't fit on the bottom, so will be sticky to that side
            currentPosition.y = Math.max(0, available - popup.dimensions.height);
        }
    }

    /**
     * Determines where the popup should align itself within relation to the parent on the bottom.
     * Alignment and position in the y direction will be set when needed < available. Otherwise nothing changes.
     * @param {object}    popup              Object containing information regarding size of the
     *                                       popup to be rendered.
     * @param {object}    currentPosition    Position for the popup when it is rendered. Contains both x and y
     *                                       directions.
     * @param {string}    currentPositionType Contains the string denoting which side we are calculating
     */
    function _tryBottomAlignment(popup, currentPosition, currentPositionType) {
        var available = popup.parentPosition.bottom,
            needed = popup.dimensions.height;

        /* istanbul ignore else */
        if (needed < available) {
            currentPositionType.alignment = 'bottom';
            currentPosition.y = popup.parentPosition.bottom - needed;
        }
    }

    return {
        tryLeftAlignment: _tryLeftAlignment,
        tryRightAlignment: _tryRightAlignment,
        tryTopAlignment: _tryTopAlignment,
        tryBottomAlignment: _tryBottomAlignment,
        tryMiddleAlignment: _tryMiddleAlignment,
        tryCenterAlignment: _tryCenterAlignment
    };
});

define('hui/core/utils',[],function() {
    'use strict';

    var overflowRegex = /(auto|scroll)/;

    /**
     * Return the set of keys of the object
     * @param  {Object} obj
     * @return {Array}  An array containg the set of keys of the object
     */
    function _allKeys(obj) {
        var keys = [],
            key;
        for (key in obj) {
            keys.push(key);
        }
        return keys;
    }

    /**
     * Common base for shared functionality between extend and mixin
     * Adapted from the extend function from underscorejs.org
     */
    function extendOrMixin(objs, override) {
        var obj = objs[0],
            length = objs.length,
            source,
            index = 1,
            i,
            key,
            keys,
            l;

        if (length < 2 || obj === null) {
            return obj;
        }
        for (index; index < length; index++) {
            source = objs[index];
            keys = _allKeys(source);
            l = keys.length;

            for (i = 0; i < l; i++) {
                key = keys[i];
                if (obj[key] === void 0 || override) {
                    obj[key] = source[key];
                }
            }
        }
        return obj;
    }

    /**
     * Determines if an object is a DOM node
     * @param {Object} content The object to check
     * @return {Boolean} Whether the content is an DOM node or not
     */
    function isNode(content) {
        return !!content && !!content.nodeType;
    }

    /**
     * Determines if an object is an array of DOM nodes
     * @param {Array} content The array to check
     * @return {Boolean} Whether the content is an an array of DOM nodes or not
     */
    function isArrayOfNodes(content) {
        return Array.isArray(content) && content.reduce(function(previousElementWasANode, currentElement) {
            return previousElementWasANode && isNode(currentElement);
        }, true);
    }

    /**
     * Determines if a value is an object
     * @param {Object} value The value to check
     * @return {Boolean} Whether the value is an object or not
     */
    function isObject(value) {
        return (!!value && value.toString() === '[object Object]');
    }

    /**
     * Appends an array of DOM nodes to a parent DOM node
     * @param {HTMLElement} parent The node to append to
     * @param {[HTMLElement]} children The array of nodes to add
     */
    function appendChildren(parent, children) {
        if (isNode(parent)) {
            children.filter(function(child) {
                    return isNode(child);
                })
                .forEach(function(childNode) {
                    parent.appendChild(childNode);
                });
        }
    }

    /**
     * Creates a element and assigns specified properties
     * @param {String} tagName The tagName of the element
     * @param {Object} properties Key-value pairs for the properties to be
     *      assigned to the element
     * @param {[HTMLElement]} children Array of child nodes to append to the
     *      parent element
     * @return {HTMLElement} The initialized element
     */
    function createElement(tagName, properties, children) {
        var _element = document.createElement(tagName),
            _properties = isObject(properties) ? properties : {},
            _children = Array.isArray(children) ? children : [];

        function isAttribute(string) {
            return /^attr-/.test(string);
        }

        function parseAttribute(string) {
            return string.substring('attr-'.length, string.length);
        }

        Object.keys(_properties).forEach(function(prop) {
            var value = _properties[prop];

            if (isAttribute(prop)) {
                _element.setAttribute(parseAttribute(prop), value);
            } else {
                _element[prop] = value;
            }
        });

        appendChildren(_element, _children);

        return _element;
    }

    /**
     * @param {HTMLElement} parentNode The DOM node from which to remove children
     */
    function removeAllChildrenFrom(parentNode) {
        while (parentNode && parentNode.firstChild) {
            parentNode.removeChild(parentNode.firstChild);
        }
    }

    /**
     * Slices an element's childNodes into an array
     * @param {HTMLElement} element The source of child nodes
     * @return {[HTMLElement]} The array of child nodes
     */
    function arrayOfChildrenFrom(element) {
        if (isNode(element)) {
            return Array.prototype.slice.call(element.children);
        } else {
            return [];
        }
    }

    /**
     * Behaves like Element.querySelector, except it returns null if the result
     * is not an immediate child of the parent.
     * @param {HTMLElement} parent The element from which to query
     * @param {String} selector A CSS selector for the query
     * @return {HTMLElement} The first immediate child of the parent which matches
     *      the selector
     */
    function queryChildOf(parent, selector) {
        return queryChildrenOf(parent, selector)[0] || null;
    }

    /**
     * Behaves like Element.querySelectorAll, except it returns null if the results
     * are not an immediate children of the parent.
     * @param {HTMLElement} parent The element from which to query
     * @param {String} selector A CSS selector for the query
     * @return {[HTMLElement]} The first immediate child of the parent which matches
     *      the selector
     */
    function queryChildrenOf(parent, selector) {
        var results = [],
            hasChild = function(child) {
                return arrayOfChildrenFrom(parent).indexOf(child) !== -1;
            };

        if (isNode(parent) && !!selector) {
            results = Array.prototype.slice.call(parent.querySelectorAll(selector));
        }

        return results.filter(hasChild);
    }

    /**
     * Execute a callback if a root and all chained properties exists.
     * @param   {Object}        root        The object from which the chain originates
     * @param   {Array<string>} chain       The names of properties in order of evaluation
     * @param   {Function}      callback    The block of code to execute if the subject exists
     * @return  {*}             returnVal   The return value of the callback or undefined
     */
    function ifSafeChain(root, chain, callback) {
        var toFinalLink = function(prevLink, propName) {
                var prop = prevLink[propName];
                return (prevLink && prop) ? bindIfFunction(prevLink, prop) : null;
            },
            bindIfFunction = function(prevLink, prop) {
                return ((typeof prop) === 'function') ? prop.bind(prevLink) : prop;
            },
            finalLink = (chain || []).reduce(toFinalLink, root);

        return (callback && finalLink) ? callback(finalLink) : undefined;
    }

    /**
     * Get the name of a fucntion safely, polyfill function for IE11.
     * @param {Function}    func  is the function.
     * @returns {String}    The name of the function, return anonymous func if function with no name,
     *                          return nothing if not a function type.
     */
    function getFunctionName(func) {
        if (typeof func === 'function') {
            if (func.name) {
                return func.name;
            } else {
                var funcName = func.toString().match(/^function\s*([^\s(]+)/);
                return funcName ? funcName[1] : 'anonymous func';
            }
        }
    }

    /**
     * A function for checking children types of React component based given types.
     * @param {Object / Array}      children is a react component children nodes.
     * @param {String}              componentName is a react component name.
     * @param {Object / Array}      types is the required types.
     * @param {String}              typesString is required names of types.
     * @return {Object}             error object with error message, return nothing if require types match.
     */
    function checkReactChildrenType(children, componentName, types, typesString) {
        var childNodes = children || [],
            i, errorFlag, currentType;
        // handle single child prop http://facebook.github.io/react/tips/children-props-type.html
        childNodes = Array.isArray(childNodes) ? childNodes : [childNodes];
        types = Array.isArray(types) ? types : [types];
        // Only accept a single child of the appropriate type
        for (var child in childNodes) {
            errorFlag = true;
            currentType = childNodes[child].type;
            for (i = 0; i < types.length; i++) {
                if (currentType === types[i]) {
                    errorFlag = false;
                    break;
                }
            }
            if (errorFlag) {
                return new Error(componentName + '\'s children can only have one instance of the following types: ' +
                    typesString + '; not accept type: ' + currentType);
            }
        }
    }

    var Utils = {
        /**
         * Retrieve the width of the string.
         * @param {String} text Text to be measured
         * @return {Number}
         */

        /**
         * Retrieve the width of the string.
         * @param  {String}         text            Text to be measured
         * @param  {String}         font            Text font
         * @param  {HTMLElement}    canvasElement   Optional. Useful to cache canvas when calling this method repeatedly
         * @return {Number}
         */
        getTextWidth: function(text, font, canvasElement) {
            var canvas = canvasElement || document.createElement('canvas'),
                context = canvas.getContext('2d'),
                width;

            context.font = font;

            width = Math.floor(context.measureText(text).width);
            // Width may be 0, in that case we don't want to add 1 px.
            return width ? width + 1 : width;
        },

        /**
         * Remove and returns the childNodes of a component safely.
         * The childNodes will be remove from the parent and
         * returned.
         * @param {HTMLElement} component The component where the nodes need to be removed
         * @param {NodeList} nodeList The NodeList of nodes to be remove
         * @return {Array} An array of the removed nodes.
         */
        removeNodesSafe: function(component, nodeList) {
            var removedChildNodes = [],
                nodes;

            nodes = Array.prototype.slice.apply(nodeList);
            nodes.filter(function(node) {
                    return component === node.parentNode;
                }).map(function(node) {
                    removedChildNodes.push(component.removeChild(node));
                    if (node.render) {
                        node.render();
                    }
                });

            return removedChildNodes;
        },

        /**
         * Inserts a node collection into component.
         * @param {HTMLElement} component   where the node list will be inserted.
         * @param {Array}       nodeList    nodes to be inserted.
         */
        appendChildCollection: function(component, nodeList) {
            var idx;

            for (idx = 0; idx < nodeList.length; ++idx) {
                component.appendChild(nodeList[idx]);
            }
        },

        /**
         * Stops propagation and default actions of event
         * @param  {event} evt Event to stop
         */
        stopEvent: function(evt) {
            evt.stopPropagation();
            evt.preventDefault();
        },

        /**
         * Answers the name of the animation events.
         * @return {Object} Object.animationstart {String}
         *                  Object.animationend {String}
         */
        getAnimationEventNames: function() {
            var animationstart =
                    'webkitAnimationName' in document.documentElement.style ?
                        'webkitAnimationStart' : 'animationstart',
                animationend =
                    'webkitAnimationName' in document.documentElement.style ?
                        'webkitAnimationEnd' : 'animationend',
                transitionend =
                    'onwebkittransitionend' in window ?
                        'webkitTransitionEnd' : 'transitionend';

            return {
                animationstart: animationstart,
                animationend: animationend,
                transitionend: transitionend
            };
        },

        /**
         * Search a specific node element and return it from the component.
         * @param {HTMLElement}  component       is the component which could have searched target.
         * @param {String}       targetTagName   is the component name to be searched.
         * @returns The component searched.
         */
        getComponentFromElement: function(component, targetTagName) {
            while (component && component.tagName !== targetTagName) {
                component = component.parentNode;
            }
            return component;
        },

        /**
         * Search a specific node element and return it from the component by className.
         * @param {HTMLElement}  component       is the component which could have searched target.
         * @param {String}       className   is the class name to be searched.
         * @returns The component searched.
         */
        getComponentFromElementByClassName: function(component, className) {
            while (component && !component.classList.contains(className)) {
                component = component.parentNode;
            }
            return component;
        },

        /**
         * Determines if a given component needs some sort of validation
         * @param  {HTMLElement} component The component to check
         * @return {Boolean}     True if the component defines a validation
         */
        validationRequired: function(component) {
            return component.required || component.pattern || component.validator || component.min || component.max || component.numeric || component.password || component.minDate || component.maxDate;
        },

        /**
         * Takes a list of objects, and returns the union of all of them
         * Adapted from underscorejs.org
         * @return {Object}     A new object containing the union of all keys and their corresponding values
         */
        extend: function() {
            return extendOrMixin(Array.prototype.slice.call(arguments), false);
        },

        /**
         * Takes a list of objects, and copies all properties from them to the first object. If two arguments have the
         * same key, the one at the greater index wins.
         * @return {Object}     A new object containing the union of all keys and their corresponding values
         */
        mixin: function() {
            return extendOrMixin(Array.prototype.slice.call(arguments), true);
        },

        stopNativeEvent: function(component, element, eventName) {
            component.listenTo(element, eventName, function(ev) {
                ev.stopPropagation();
            });
        },

        /**
         * Return the target related of the event with IE compliance way.
         * @param {Event} event that will be try to take the related target.
         * @returns {Object} The related target of the event.
         * @private
         */
        getSafeTargetFromEvent: function(event) {
            return event.relatedTarget || event.explicitOriginalTarget || document.activeElement;
        },

        /**
         * Returns the next sibling of the same type.
         * @param {Node} node The node we want to compare from.
         * @param {String} nodeName The node name.
         * @return {Node}  The next sibling of the same type.
         */
        getNextSiblingOfType: function(node, nodeName) {
            while ((node = node.nextSibling) && node.nodeName !== nodeName) {
            }
            return node;
        },

        /**
         * Returns the prev sibling of the same type.
         * @param {Node} node The node we want to compare from.
         * @param {String} nodeName The node name.
         * @return {Node}  The prev sibling of the same type.
         */
        getPrevSiblingOfType: function(node, nodeName) {
            while ((node = node.previousSibling) && node.nodeName !== nodeName) {
            }
            return node;
        },

        /**
         * Finds the difference between two arrays
         * @param  {Array} a
         * @param  {Array} b
         * @return {Array}   The difference between a and b
         */
        getArrayDiff: function(a, b) {
            a = a ? a : [];
            b = b ? b : [];
            return a.filter(function(item) {
                return b.indexOf(item) < 0;
            });
        },

        /**
         * Returns a direct child of a parent node, that matches the passed type, similar to do a parentNode > type selector
         * @param  {HTMLElement} parentNode  The node inside of which search for the element
         * @param  {String}      type        The type of the element to find
         * @return {HTMLElement}             The found element
         */
        getDirectChildByType: function(parentNode, type) {
            var children = parentNode.children,
                child;
            Array.prototype.forEach.call(children, function(node) {
                if (node.tagName.toLowerCase() === type) {
                    child = node;
                }
            });
            return child;
        },

        /**
         * Gets the scroll parent of the specified node. A scroll parent is created by a node whose overflow
         * is set to 'auto' or 'scroll'. If none of the node's ancestors creates scrolling, then the scroll
         * parent is the node's ownerDocument (the scrolling context is the browser window).
         * @param {HTMLElement} node The node to find the scroll parent of
         * @returns {Node} The node's scroll parent
         */
        getScrollParent: function(node) {
            var parent = node,
                style,
                // if the child node is absolutely positioned then we can ignore ancestors that
                // are statically positioned, since scrolling within them will not affect the child
                excludeStaticParent = getComputedStyle(node).position === 'absolute',
                found = false;

            do {
                // Generally we can skip parent nodes that aren't elements, except when we get to the top:
                // the body's parentElement is document.documentElement; document.documentElement's parentElement is
                // null, but its parentNode is document, which we want to get and compare to node.ownerDocument
                parent = parent.parentElement || parent.parentNode;

                // if node has not been added to the body, just return the ownerDocument
                if (parent === null) {
                    return node.ownerDocument;
                }

                if (parent === node.ownerDocument) {
                    found = true;
                    continue;
                }

                style = getComputedStyle(parent);

                if (excludeStaticParent && style.position === 'static') {
                    continue;
                }

                if (overflowRegex.test(style.overflow) ||
                    overflowRegex.test(style.overflowX) ||
                    overflowRegex.test(style.overflowY)) {
                    found = true;
                }
            } while (!found);

            return parent;
        },

        /**
         * limit how often a function is called
         * @param {Function} callback the function to throttle
         * @param {number} delay the number of milliseconds between function calls
         * @return {Function} a new function that throttles the original function
         */
        throttle: function(callback, delay) {
            var ready = true;

            return function() {
                if (ready) {
                    ready = false;

                    setTimeout(function() {
                        ready = true;
                    }, delay);

                    callback.apply(this, arguments);
                }
            };
        },

        /**
         * Create a function that is called only once so often,
         * as long as it's still being called
         * @param {Function} callback the function to call
         * @param {number} delay the number of milliseconds between function calls
         * @return {Function} a new function that is throttle-debounced
         */
        throttleDebounce: function(callback, delay) {
            var ready = true,
                args = null;

            return function throttled() {
                var context = this;

                if (ready) {
                    ready = false;

                    setTimeout(function() {
                        ready = true;

                        if (args) {
                            throttled.apply(context);
                        }
                    }, delay);

                    if (args) {
                        callback.apply(this, args);
                        args = null;
                    } else {
                        callback.apply(this, arguments);
                    }
                } else {
                    args = arguments;
                }
            };
        },

        /**
         * Returns the prototype of any given value.
         * @argument {(String|Boolean|Number|Object|Array)} value the initial value to be typed
         * @return {(String|Boolean|Number|Object|Array)} the cast type
         */
        type: function(value) {
            /*jshint indent:false, eqnull:true*/
            switch (value == null ? '' + value : Object.prototype.toString.call(value).slice(8, -1).toLowerCase()) {
            case 'string': return String;
            case 'boolean': return Utils.YesNoType; // booleans cannot have defaults, so use this instead
            case 'number': return Number;
            case 'object': return Object;
            case 'array': return Array;
            }
        },

        /**
         * Append new class props from a React component to pre-applied classes
         * from the rendered custom element. classProps should be truthy
         * upon invocation. If the element doesn't have any applied classes,
         * then just return the class props. Note: a re-render will trigger on
         * the component when used in conjunction with setting classAttributes of
         * state. See TextField component for an example. Needs to handle the
         * following cases:

         * Case 1: new className should clear previous consumer-defined className props on the component
         * Case 2: new className should NOT overwrite the HUI class attribute if it's on the component (eg. mobile-text-field)
         *
         * @param {HTMLElement} component The rendered custom element reference
         * @param {String} classProps Props from the React component
         * @return {String} A string of the classes to be updated
         */
        updateClassWithProps: function(component, classProps) {
            if (component.classList.length > 0) {
                var props, mergedClasses, preservedClasses = [];

                // for every supported class on this component, preserve the class
                // in a new array to be merged with the new props
                if (component.supportedClasses) {
                    preservedClasses = component.supportedClasses.filter(function(supportedClass) {
                        return (component.classList.contains(supportedClass) &&
                            preservedClasses.indexOf(supportedClass) === -1);
                    });

                    // merge preseved (existing) HUI classes with new props
                    if (classProps) {
                        mergedClasses = preservedClasses.concat(classProps.split(' '));
                    } else {
                        mergedClasses = preservedClasses;
                    }
                    return mergedClasses.join(' ').trim();

                } else {
                    // TOOD: old - keeping for now for testing on multiple components
                    if (classProps) {
                        props = classProps.split(' ');
                        props.forEach(function(prop) {
                            if (!component.classList.contains(prop)) {
                                component.classList.add(prop);
                            }
                        });
                    }

                    return component.classList.toString();
                }
            } else {
                return classProps ? classProps : '';
            }
        },

        YesNoType: {

            /**
             * Returns a boolean value if the lowercased argument strictly equals the string 'yes'
             * @argument {String} attrValue to be lowercased
             * @return {Boolean}
             */
            parse: function(attrValue) {
                return attrValue.toLowerCase() === 'yes';
            },

            /**
             * Returns a string value equal to the given boolean argument
             * @argument {Boolean} value
             * @return {String}
             */
            stringify: function(value) {
                return value ? 'yes' : 'no';
            }
        },

        /**
         * Appends or removes the suffixText from text
         * @param {String} text The text
         * @param {String} suffixText The text to apply as a suffix
         * @param {Boolean} state Flag to determine if to add or remove the suffixText
         * @return {String} The processed text
         */
        toggleSuffixText: function(text, suffixText, state) {
            if (state) {
                if (text && text.slice(-2) !== suffixText) {
                    text += suffixText;
                }
            } else {
                if (text && text.slice(-2) === suffixText) {
                    text = text.slice(0, -2);
                }
            }

            return text;
        },

        debounce: function(func, wait, immediate) {
            var timeout;
            return function() {
                var context = this,
                    args = arguments,
                    later = function() {
                        timeout = null;
                        if (!immediate) {
                            func.apply(context, args);
                        }
                    },
                    callNow = immediate && !timeout;

                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
                if (callNow) {
                    func.apply(context, args);
                }
            };
        },

        createElement: createElement,

        appendChildren: appendChildren,

        /**
         * Attaches content to an HTMLElement based on its type.
         * @param {String|[HTMLElement]|HTMLElement} newValue The value to be converted
         * @param {HTMLElement} parentNode The HTMLElement to attach the newValue
         * @return {HTMLElement} The modified HTMLElement
         */
        attachContentToNode: function(newValue, parentNode) {
            if (newValue) {
                if (typeof newValue === 'string') {
                    parentNode.textContent = newValue;
                } else if (Array.isArray(newValue)) {
                    newValue.forEach(function(value) {
                        if (value && value.nodeType) {
                            parentNode.appendChild(value);
                        }
                    });
                } else {
                    if (newValue.nodeType) {
                        parentNode.appendChild(newValue);
                    }
                }
            }

            return parentNode;
        },

        removeAllChildrenFrom: removeAllChildrenFrom,

        /**
         * Wraps content in a specified tag
         * @param {String} wrapperTagName The tagName of the wrapping element
         * @param {HTMLElement|[HTMLElement]} content The content to wrap
         * @return {HTMLElement} The wrapped content
         */
        wrapIfNotWrapped: function(wrapperTagName, content) {
            var wrappedContent = null,
                toLowerCase = String.prototype.toLowerCase;

            if (wrapperTagName) {
                if (isNode(content)) {
                    if (toLowerCase.call(content.tagName) === toLowerCase.call(wrapperTagName)) {
                        wrappedContent = content;
                    } else {
                        wrappedContent = createElement(wrapperTagName, {}, [content]);
                    }
                } else if (isArrayOfNodes(content)) {
                    wrappedContent = createElement(wrapperTagName, {}, content);
                }
            }

            return wrappedContent;
        },

        /**
         * Set one or more attributes of an HTMLElement
         * @param {HTMLElement} element The HTMLElement to set attributes on
         * @param {Object} attributes Map from attribute names to values
         * @return {HTMLElement} element with attributes applied to it
         */
        setAttributes: function(element, attributes) {
            var value;
            if (isNode(element) && isObject(attributes)) {
                Object.keys(attributes).forEach(function(name) {
                    value = attributes[name];
                    element.setAttribute(name, value);
                });
            }

            return element;
        },

        arrayOfChildrenFrom: arrayOfChildrenFrom,

        queryChildOf: queryChildOf,

        queryChildrenOf: queryChildrenOf,

        isNode: isNode,

        getFunctionName: getFunctionName,

        checkReactChildrenType: checkReactChildrenType,
        /**
         * Checks whether the popover or modal is open
         * @param {ha-popover | ha-modal} popoverOrModal
         * @returns {*|boolean}
         * @private
         */
        isOpen: function(popoverOrModal) {
            return popoverOrModal && (
                    (popoverOrModal.nodeName === 'HA-POPOVER' && popoverOrModal.open) ||
                    (popoverOrModal.nodeName === 'HA-MODAL' && popoverOrModal.classList.contains('show'))
                );
        },

        /**
         * Helper to show the popover or modal based on positionTarget
         * @param {HTMLElement} component The popover with menu items to show.
         * @param {HTMLElement} positionTarget The target for the popover to be positioned from
         * @param {*} popup The popup utility
         * @private
         */
        showPopoverOrModal: function(component, positionTarget, popup) {
            if (component) {
                if (this.isOpen(component)) {
                    popup.setPosition(component, positionTarget, ['bottom', 'top'], ['left', 'right']);
                } else {
                    popup.show(component, positionTarget, ['bottom', 'top'], ['left', 'right']);
                }
            }
        },

        /**
         * Replace all of an elements children with new content
         * @param {HTMLElement} parent The element that hosts the content nodes
         * @param {HTMLElement|[HTMLElement]} newContent The new content to add to the parent
         */
        replaceChildrenOf: function(parent, newContent) {
            if (isNode(parent)) {
                if (isNode(newContent)) {
                    removeAllChildrenFrom(parent);
                    parent.appendChild(newContent);
                } else if (isArrayOfNodes(newContent)) {
                    removeAllChildrenFrom(parent);
                    appendChildren(parent, newContent);
                }
            }
        },

        /**
         * Factory function that creates a querySelector function which only returns
         * results from specified paths.
         * @param {HTMLElement} parent The element from which to query
         * @param {Object} renderMapping A set of key values in which the key is
         *      the tagName of the node being queried, and the value represents
         *      the path to the node after the component has been rendered.
         * @return {Function} renderedOrUserProvided The augmented querySelector
         *
         * ex:  var drawerLarge = document.createElement('ha-drawer-large'),
         *          renderedOrUserProvided = contentQueryFactory(drawerLarge, {
         *                                      'section': 'aside'
         *                                   });
         *
         *      // if <ha-drawer-large><section>...</section></ha-drawer-large> (user provided)
         *      //                              or
         *      //    <ha-drawer-large><aside><section>...</section></aside></ha-drawer-large> (rendered)
         *      renderedOrUserProvided('section')   //=> <section></section>
         *
         *      // if <ha-drawer-large></ha-drawer-large>
         *      renderedOrUserProvided('section')   //=> null
         */
        contentQueryFactory: function(parent, renderMapping) {
            return function renderedOrUserProvided(tagName) {
                var renderedSelector = [renderMapping[tagName], tagName].join(' > '),
                    rendered = parent.querySelector(renderedSelector),
                    userProvided = queryChildOf(parent, tagName);

                return rendered || userProvided;
            };
        },

        ifSafeChain: ifSafeChain,

        /**
         * Execute a callback if a subject exists.
         * @param   {Object}    subject     Will get passed into the callback as it's argument
         * @param   {Function}  callback    The block of code to execute if the subject exists
         * @return  {*}         returnVal   The return value of the callback or undefined
         */
        ifExists: function(subject, callback) {
            return ifSafeChain(subject, [], callback);
        },

        customMixin: function(dest, source, copyFunc, visited) {
            // summary:
            //		Copies/adds all properties of source to dest; returns dest.
            // dest: Object
            //		The object to which to copy/add all properties contained in source.
            // source: Object
            //		The object from which to draw all properties to copy into dest.
            // copyFunc: Function?
            //		The process used to copy/add a property in source; defaults to the Javascript assignment operator.
            // returns:
            //		dest, as modified
            // description:
            //		All properties, including functions (sometimes termed 'methods'), excluding any non-standard extensions
            //		found in Object.prototype, are copied/added to dest. Copying/adding each particular property is
            //		delegated to copyFunc (if any); copyFunc defaults to the Javascript assignment operator if not provided.
            //		Notice that by default, _mixin executes a so-called 'shallow copy' and aggregate types are copied/added by reference.
            var name,
                s,
                empty = {};
            for (name in source) {
                // the (!(name in empty) || empty[name] !== s) condition avoids copying properties in 'source'
                // inherited from Object.prototype.	 For example, if dest has a custom toString() method,
                // don't overwrite it with the toString() method that source inherited from Object.prototype
                s = source[name];
                if (!(name in dest) || (dest[name] !== s && (!(name in empty) || empty[name] !== s))) {
                    dest[name] = copyFunc ? copyFunc(s, visited) : s;
                }
            }

            return dest; // Object
        },

        clone: function(src, visited) {
            visited = visited || [];
            if (visited.indexOf(src) >= 0) {
                return null;
            }
            // summary:
            //		Clones objects (including DOM nodes) and all children.
            //		Warning: do not clone cyclic structures.
            // src:
            //		The object to clone
            if (!src || typeof src !== 'object' || typeof src === 'function') {
                // null, undefined, any non-object, or function
                return src;	// anything
            }
            if (src.nodeType && 'cloneNode' in src) {
                // DOM Node
                visited.push(src);
                return src.cloneNode(true); // Node
            }
            if (src instanceof Date) {
                // Date
                return new Date(src.getTime());	// Date
            }
            if (src instanceof RegExp) {
                // RegExp
                return new RegExp(src);   // RegExp
            }
            var r;
            if (Array.isArray(src)) {
                // array
                visited.push(src);
                r = [];
            } else {
                // generic objects
                visited.push(src);
                try {
                    r = src.constructor ? new src.constructor() : {};
                } catch (exception) {
                    r = {};
                }
            }
            return Utils.customMixin(r, src, Utils.clone, visited);
        },

        animateScrollTo: function(element, scrollTop, duration) {
            var start = (new Date()).valueOf(),
                target = scrollTop,
                original = element.scrollTop;

            setTimeout(function animate() {
                var now = (new Date()).valueOf(),
                    t = Math.min((now - start) / duration, 1);

                element.scrollTop = original + (target - original) * t;

                if (t < 1) {
                    setTimeout(animate, 33);
                }
            }, 33);
        },

        /**
         * Helper to hide the popover or modal
         * @param {ha-popover | ha-modal} component the popover or modal to hide
         * @param {*} popup The popup utility
         * @private
         */
        hidePopoverOrModal: function(component, popup) {
            if (component.nodeName === 'HA-MODAL') {
                component.close();
            } else {
                popup.hide(component);
            }
        },

        /**
         * Find the nearest parent element that matches a given selector
         * Defaults to using Element#closest if it exists
         * @param {Element} elem the starting element
         * @param {string} selector the selector to search for
         * @return {Element|null}
         */
        closest: function(elem, selector) {
            if (typeof elem.closest === 'function') {
                return elem.closest(selector);
            }

            var firstChar = selector.charAt(0),
                attribute,
                value;

            if (firstChar === '[') {
                selector = selector.substr(1, selector.length - 2);
                attribute = selector.split('=');

                if (attribute.length > 1) {
                    value = true;
                    attribute[1] = attribute[1].replace(/"/g, '').replace(/'/g, '');
                }
            }

            for (; elem && elem !== document && elem.nodeType === 1; elem = elem.parentNode) {
                if (firstChar === '.') {
                    if (elem.classList.contains(selector.substr(1))) {
                        return elem;
                    }
                } else if (firstChar === '#') {
                    if (elem.id === selector.substr(1)) {
                        return elem;
                    }
                } else if (firstChar === '[' && elem.hasAttribute(attribute[0])) {
                    if (value) {
                        if (elem.getAttribute(attribute[0]) === attribute[1]) {
                            return elem;
                        }
                    } else {
                        return elem;
                    }
                } else if (elem.tagName.toLowerCase() === selector) {
                    return elem;
                }
            }

            return null;
        }
    };

    return Utils;
});

define('hui/core/Viewport',[],function() {
    'use strict';
    /**
     * Detects if it's a mobile browser
     * @return {Boolean} true if it's a mobile browser
     */
    function _isMobile() {
        return /iPhone|iPod|iPad|Android|BlackBerry/.test(navigator.userAgent);
    }

    /**
     * Attaches or deattaches a callback from the resize change event
     * @param  {String}     actionType   determines whether to use addEventListener or removeEventListener
     * @param  {Function}   callback the handler to be attached
     */
    function _handleResizeHandlerAttachment(actionType, callback) {
        var focusableElements = ['input', 'select', 'textarea'],
            body = document.getElementsByTagName('body')[0],
            action = actionType === 'add' ? HTMLElement.prototype.addEventListener : HTMLElement.prototype.removeEventListener,
            safeWindowsAction = actionType === 'add' ? window.addEventListener : window.removeEventListener,
            delegatedCallback = function(event) {
                var targetType = event.target.nodeName.toLowerCase();
                if (focusableElements.indexOf(targetType) > -1) {
                    callback();
                }
            };

        if (_isMobile()) {
            action.call(body, 'focusin', delegatedCallback, false);
            action.call(body, 'focusout', delegatedCallback, false);
            action.call(document, 'orientationchange', callback, false);
        } else {
            safeWindowsAction.call(window, 'resize', callback, false);
        }
    }

    /**
     * Utility set of methods to handle the viewport properties.
     * @type {Object}
     */
    var viewport = {

        /**
        * Adds a handler to the viewport size change event, considering
        * also problematic cases in mobile devices
        * @callback  callback
        */
        onResize: function(callback) {
            _handleResizeHandlerAttachment('add', callback);
        },

        /**
        * Removes a handler off the viewport size change event
        * @callback  callback   the handler to be removed
        */
        offResize: function(callback) {
            _handleResizeHandlerAttachment('remove', callback);
        }

    };

    return viewport;
});
define('hui/core/event',[
    'exports'
], function(exports) {
    function matches(node, selector, contextNode) {
        /* istanbul ignore next */
        var matchesSelector = node.matches || node.webkitMatchesSelector || node.mozMatchesSelector || node.msMatchesSelector;

        while (node && node.nodeType === 1 && node !== contextNode) {
            if (matchesSelector.call(node, selector)) {
                return node;
            } else {
                node = node.parentNode;
            }
        }
        return false;
    }

    function matchesSelectorListener(selector, listener, contextNode) {
        return function(e) {
            var matchesTarget = matches(e.target, selector, contextNode);
            if (matchesTarget) {
                listener(e, matchesTarget);
            }
        };
    }

    function off(target, name, callback, useCapture) {
        target.removeEventListener(name, callback, !!useCapture);
    }

    function on(target, name, callback, useCapture) {
        var selector = name.match(/(.*):(.*)/);

        if (selector) {
            name = selector[2];
            selector = selector[1];
            callback = matchesSelectorListener(selector, callback, target);
        }

        target.addEventListener(name, callback, !!useCapture);

        return {
            remove: function() {
                return off(target, name, callback, useCapture);
            }
        };
    }

    function emit(target, eventName, eventObject) {
        var event;

        eventObject = eventObject || {};

        /* istanbul ignore else */
        if (!('bubbles' in eventObject)) {
            eventObject.bubbles = true;
        }

        /* istanbul ignore else */
        if (!('cancelable' in eventObject)) {
            eventObject.cancelable = false;
        }

        if (target.emit) {
            target.emit(eventName, eventObject);
        } else {
            event = document.createEvent('UIEvent');
            event.initUIEvent(eventName, eventObject.bubbles, eventObject.cancelable, window, 1);
            Object.keys(eventObject).forEach(function(eventProperty) {
                if (!(eventProperty in {bubbles: 1, cancelable: 1})) {
                    event[eventProperty] = eventObject[eventProperty];
                }
            });
            target.dispatchEvent(event);
        }
    }

    exports.on = on;
    exports.off = off;
    exports.emit = emit;
});

define('hui/core/popup',[
    './position',
    './popupPositionUtils',
    './popupAlignmentUtils',
    './utils',
    './Viewport',
    './event'
],
function(position, popupPositionUtils, popupAlignmentUtils, utils, Viewport, eventUtil) {

    var BASE_MARGIN = 5,
        CONNECTOR_MARGIN = 4,
        VERTICAL_POSITIONS = ['top', 'bottom'],
        HORIZONTAL_POSITIONS = ['left', 'right'],
        VERTICAL_ALIGNMENTS = ['top', 'middle', 'bottom'],
        HORIZONTAL_ALIGNMENTS = ['left', 'center', 'right'];

    /**
     * Calculates position for the popup
     * @param  {HTMLElement}    component                   component to be rendered as a popup
     * @param  {Object}         target                      contains position and dimensions of target element
     * @param  {Array}          positionOrder               ordered list of possible positions to fit the popup
     * @param  {Object}         alignmentOrder              ordered list of possible alignments to try to fit the popup
     * @param  {Object}         margin                      margin between the popup and the target
     * @param  {Object}         customPositioningMethods    custom position or alignment methods
     * @return {Object}         object.x
     *                          object.y
     *                          object.positionFound
     *                          object.alignmentFound
     */
    function _getPopupPosition(component, target, positionOrder, alignmentOrder, margin, customPositioningMethods) {
        var currentPosition = {
                x: -1,
                y: -1
            },
            positionMap = {
                'top': popupPositionUtils.tryTopPosition,
                'left': popupPositionUtils.tryLeftPosition,
                'right': popupPositionUtils.tryRightPosition,
                'bottom': popupPositionUtils.tryBottomPosition
            },
            alignmentMap = {
                'top': popupAlignmentUtils.tryTopAlignment,
                'left': popupAlignmentUtils.tryLeftAlignment,
                'right': popupAlignmentUtils.tryRightAlignment,
                'bottom': popupAlignmentUtils.tryBottomAlignment,
                'middle': popupAlignmentUtils.tryMiddleAlignment,
                'center': popupAlignmentUtils.tryCenterAlignment
            },
            currentPositionType = {},
            connector = component.querySelector('.connector'),
            positionFound,
            alignmentFound,
            verticalPosition,
            method,
            possibleAlignments,
            popup = {
                boxShadow: {
                    top: 0,
                    left: 0,
                    right: 0,
                    bottom: 0
                },
                margin: 0,
                parentPosition: {},
                spaceToNextObject: {},
                dimensions: {}
            };

        customPositioningMethods = customPositioningMethods || {};

        /* ----------- Position -------------- */
        popup.parentPosition = position.getPositionInDocument(target);  // formally targetRect
        popup.spaceToNextObject = popup.parentPosition;                 // formally absoluteRect

        if (!component.style.minWidth) {
            component.style.minWidth = popup.parentPosition.width + 'px';
        }
        popup.dimensions = position.getDimension(component);            // formally popupDimensions

        // If the component has a connector, we need to add extra margin
        if (connector) {
            popup.margin = BASE_MARGIN + (margin || CONNECTOR_MARGIN);        // formally margin
        } else {
            popup.margin = BASE_MARGIN + (margin || 0);
            popup.boxShadow = position.getBoxShadowSize(component);                 // formally boxShadow
        }

        // Checks every position on the array until one fits on the page
        positionFound = positionOrder.some(function(pos) {
            var method = customPositioningMethods[pos] || positionMap[pos];
            if (method) {
                method.call(target, popup, currentPosition, currentPositionType);
                return currentPositionType.position;
            }
        });

        if (!positionFound) {
            method = customPositioningMethods.bottom || positionMap.bottom;
            // If there's no space anywhere, popup is forced to be added at the bottom
            method.call(target, popup, currentPosition, currentPositionType, true);
        }

        /* -------- Alignment -------- */

        verticalPosition = VERTICAL_POSITIONS.indexOf(currentPositionType.position) > -1;
        if (verticalPosition) {
            possibleAlignments = HORIZONTAL_ALIGNMENTS;
        } else {
            possibleAlignments = VERTICAL_ALIGNMENTS;
        }

        // Check every alignment on the array that matches with the position until one fits on the page
        alignmentFound = alignmentOrder.some(function(align) {
            var method;
            if (possibleAlignments.indexOf(align) > -1) {
                method = customPositioningMethods[align] || alignmentMap[align];
                method.call(target, popup, currentPosition, currentPositionType);       // This method is also called in validtable.js.
                return currentPositionType.alignment;
            }
        });

        // If there's no space anywhere, popup is forced to be aligned to the top
        if (!alignmentFound && !verticalPosition) {
            method = customPositioningMethods.top || alignmentMap.top;
            alignmentMap.top.call(target, popup, currentPosition, currentPositionType, true);
        }

        if (connector && currentPositionType.alignment === 'middle') {
            connector.style.top = ((Math.min(popup.dimensions.height, popup.parentPosition.height) - 14) / 2) + 'px';
        }

        return {
            'currentPosition': currentPosition,
            'currentPositionType': currentPositionType
        };
    }

    /**
     * Resets all position and alignments classes
     * @param  {HTMLElement} component Component to clear classes
     */
    function _clearPosition(component) {
        VERTICAL_POSITIONS.forEach(function(pos) {
            this.classList.remove('position-' + pos);
        }, component);

        HORIZONTAL_POSITIONS.forEach(function(pos) {
            this.classList.remove('position-' + pos);
        }, component);

        VERTICAL_ALIGNMENTS.forEach(function(alignment) {
            this.classList.remove('alignment-' + alignment);
        }, component);

        HORIZONTAL_ALIGNMENTS.forEach(function(alignment) {
            this.classList.remove('alignment-' + alignment);
        }, component);
    }

    /**
     * Updates styles of component with position and alignments
     * @param  {HTMLElement}    component      Component to show as a popup
     * @param  {Object}         positionTarget Position and alignments to be set
     */
    function _updateComponent(component, positionTarget) {
        _clearPosition(component);

        component.classList.add('position-' + positionTarget.currentPositionType.position);
        component.classList.add('alignment-' + positionTarget.currentPositionType.alignment);

        component.style.left = positionTarget.currentPosition.x + 'px';
        component.style.top = positionTarget.currentPosition.y + 'px';
    }

    function getScrollingPopupParent(node) {
        if (node._scrollTarget) {
            return node._scrollTarget;
        }

        var parent = node.parentElement || node.parentNode;

        while (parent) {
            if (parent._scrollTarget) {
                return parent._scrollTarget;
            }

            if (parent.scrollHandler) {
                return parent;
            }

            if (parent === node.ownerDocument) {
                return;
            }

            parent = parent.parentElement || parent.parentNode;
        }
    }

    function removeScrollHandler(popupElement) {
        if (popupElement.scrollHandler) {
            popupElement.scrollParent.removeEventListener('scroll', popupElement.scrollHandler);
            popupElement.scrollHandler = null;
            popupElement.scrollParent = null;
        }
    }

    var handleVisibilityChange = function(component, referenceElement) {
        // A popover with _closeOnBlur set to true will initiate its "close" process by setting
        // the CSS class "leave"
        if (component.classList.contains('leave') || component.classList.contains('closed')) {
            removeScrollHandler(component);
            component.addEventListener('close', function closeHandler(event) {
                if (event.target.classList.contains('no-transition')) {
                    event.target.classList.remove('no-transition');
                }

                event.target.removeEventListener('close', closeHandler);
            });

            if (!component.classList.contains('no-transition')) {
                component.classList.add('no-transition');
            }

            return;
        }

        var referenceElementRect = position.getPositionInDocument(referenceElement),
            parentRect = position.getPositionInDocument(component.scrollParent);

        // If the element has been scrolled out of sight hide it (or close it)
        if ((referenceElementRect.bottom < parentRect.top) ||
            (referenceElementRect.top > parentRect.bottom) ||
            (referenceElementRect.right < parentRect.left) ||
            (referenceElementRect.left > parentRect.right)) {
            if (component.classList.contains('visible')) {
                // A popover with _closeOnBlur set will close when it is hidden (hiding triggers blur),
                // but since it has been hidden the fade out transition will not occur, and the animationend
                // handler in popover.js that performs the final "close" logic will not happen. To ensure the
                // component is correctly closed we call "close" here instead of hiding it (and we don't have to
                // worry about unhiding it when the target scrolls back into view since that behavior is not
                // expected with _closeOnBlur).
                if (component._closeOnBlur) {
                    removeScrollHandler(component);
                    // we need to ensure we temporarily prevent autofocus of last element on close or it will
                    // interrupt the user's scrolling
                    component._tmpNoAutoFocusLastActiveElementOnClose = component._noAutoFocusLastActiveElementOnClose;
                    component._noAutoFocusLastActiveElementOnClose = true;
                    // TODO: make this logic reusable since it's the same as at the beginning of the handleVisibilityChange function
                    component.addEventListener('close', function closeHandler(event) {
                        if (event.target.classList.contains('no-transition')) {
                            event.target.classList.remove('no-transition');
                        }

                        event.target.removeEventListener('close', closeHandler);
                    });

                    if (!component.classList.contains('no-transition')) {
                        component.classList.add('no-transition');
                    }

                    component.close();
                } else {
                    if (component.classList.contains('visible')) {
                        component.classList.remove('visible');
                        component.emit('ha-popup-obscured');
                    }
                }
            }
        // If the element has been scrolled back into view, make it visible
        } else {
            if (!component.classList.contains('visible')) {
                component.classList.add('visible');
                component.emit('ha-popup-revealed');
            }
        }
    };

    function addScrollHandler(component, referenceElement, positions, alignment, margin, customPositioningMethods) {
        var popupParent,
            requestId = 0;

        // If referenceElement is within a scrolling popup then we can listen to its
        // 'ha-popup-move' event
        popupParent = getScrollingPopupParent(referenceElement);

        if (popupParent) {
            component._scrollTarget = popupParent;

            /* istanbul ignore else */
            if (!component.moveHandler) {
                /* istanbul ignore next */
                component.moveHandler = function(event) {
                    component.style.left = (parseInt(component.style.left, 10) + event.dx) + 'px';
                    component.style.top = (parseInt(component.style.top, 10) + event.dy) + 'px';
                    component.style.zIndex = position.getTopZindex();
                };

                /* istanbul ignore next */
                component.parentCloseHandler = function() {
                    if (!component.classList.contains('no-transition')) {
                        component.classList.add('no-transition');
                    }
                };

                // These are necessary in case there is a popover with a popupParent that doesn't close on blur.
                // In that case we need to hide and reveal the child popovers as the parent popover is hidden and revealed
                /* istanbul ignore next */
                component.parentObscuredHandler = function() {
                    component.classList.add('no-transition');
                    component.classList.remove('visible');
                    setTimeout(function() {
                        component.classList.remove('no-transition');
                    }, 20);
                };

                /* istanbul ignore next */
                component.parentRevealedHandler = function() {
                    component.classList.add('no-transition');
                    component.classList.add('visible');
                    setTimeout(function() {
                        component.classList.remove('no-transition');
                    }, 20);
                };

                popupParent.addEventListener('ha-popup-move', component.moveHandler);
                popupParent.addEventListener('close', component.parentCloseHandler);
                popupParent.addEventListener('ha-popup-obscured', component.parentObscuredHandler);
                popupParent.addEventListener('ha-popup-revealed', component.parentRevealedHandler);
                /* istanbul ignore next */
                component.addEventListener('close', function closeHandler(event) {
                    popupParent.removeEventListener('ha-popup-move', event.target.moveHandler);
                    popupParent.removeEventListener('close', event.target.parentCloseHandler);
                    popupParent.removeEventListener('ha-popup-obscured', event.target.parentObscuredHandler);
                    popupParent.removeEventListener('ha-popup-revealed', event.target.parentRevealedHandler);
                    event.target.moveHandler = null;
                    event.target.parentCloseHandler = null;
                    event.target.parentObscuredHandler = null;
                    event.target.parentRevealedHandler = null;
                    event.target.removeEventListener('close', closeHandler);
                    if (event.target.classList.contains('no-transition')) {
                        event.target.classList.remove('no-transition');
                    }
                });
            }
        // Otherwise check to see if referenceElement requires a scroll handler
        } else if (!component.scrollHandler) {
            component.scrollParent = utils.getScrollParent(referenceElement);

            if (component.scrollParent !== component.ownerDocument) {
                /* istanbul ignore next */
                component.scrollHandler = utils.throttleDebounce(function() {
                    handleVisibilityChange(component, referenceElement);

                    if (component.classList.contains('leave') || !component.classList.contains('visible')) {
                        return;
                    }

                    if (requestId === 0) {
                        requestId = requestAnimationFrame(function() {
                            _setPosition(component, referenceElement, positions, alignment, margin, customPositioningMethods);
                            requestId = 0;
                        });
                    }
                }, 20);

                component.scrollParent.addEventListener('scroll', component.scrollHandler);

                if (!component.closeHandler) {
                    component.closeHandler = function(event) {
                        /* istanbul ignore if */
                        if (requestId) {
                            cancelAnimationFrame(requestId);
                            requestId = 0;
                        }

                        removeScrollHandler(event.target);
                        component._noAutoFocusLastActiveElementOnClose = component._tmpNoAutoFocusLastActiveElementOnClose;
                        event.target.removeEventListener('close', component.closeHandler);
                        component.closeHandler = null;
                    };

                    component.addEventListener('close', component.closeHandler);
                }
            }
        }
    }

    /**
     * Sets position order and alignment order based on parameters or default values
     * Obtains coordinates for popup
     * Updates component with new coordinates
     * @param  {HTMLElement}    component                   component to show as a popup
     * @param  {HTMLElement}    referenceElement            reference element to position the popup
     * @param  {Array}          positions                   ordered list of possible positions to fit the popup
     * @param  {Array}          alignment                   ordered list of possible alignments to try to fit the popup
     * @param  {Number}         margin                      margin to add to the BASE_MARGIN
     * @param  {Object}         customPositioningMethods    custom position or alignment methods
     * @return {Boolean}                                    true if a position for the popup could be found
     */
    function _setPosition(component, referenceElement, positions, alignment, margin, customPositioningMethods) {
        var finalAlignment  = alignment || ['left', 'right'],
            orderPosition = positions || ['bottom', 'top'],
            positionTarget;

        addScrollHandler(component, referenceElement, positions, alignment, margin, customPositioningMethods);

        position.bringToFront(component);

        positionTarget = _getPopupPosition(component, referenceElement, orderPosition, finalAlignment, margin, customPositioningMethods);

        if (!positionTarget.currentPositionType.position || !positionTarget.currentPositionType.alignment) {
            _hide(component);
            return false;
        }

        // The 'ha-popup-move' event can be listened to by elements that wish to update their position in sync with
        // the popup. The event includes 'dx' and 'dy' properties to indicate the delta values in the x and y axes.
        if (component.style.top && component.style.left) {
            eventUtil.emit(component, 'ha-popup-move', {
                dx: positionTarget.currentPosition.x - parseInt(component.style.left, 10),
                dy: positionTarget.currentPosition.y - parseInt(component.style.top, 10)
            });
        }

        _updateComponent(component, positionTarget);

        return true;

    }

    /**
     * Adds listener for browser resize.
     * @param  {HTMLElement}    popupElement                Component where a resize listening method should be installed
     * @param  {HTMLElement}    referenceElement            Reference element to position the popup
     * @param  {Array}          positions                   ordered list of possible positions to fit the popup
     * @param  {Array}          alignment                   ordered list of possible alignments to try to fit the popup
     * @param  {Number}         margin                      margin to add to the BASE_MARGIN
     * @param  {Object}         customPositioningMethods    custom position or alignment methods
     * @return {Function}                                   Return a reference for future removal of listener
     */
    function _installResizeMethod(popupElement, referenceElement, positions, alignment, margin, customPositioningMethods) {
        var resizeMethod;

        resizeMethod = function() {
            if (popupElement.classList.contains('visible')) {
                _setPosition(popupElement, referenceElement, positions, alignment, margin, customPositioningMethods);
            }
        };

        Viewport.onResize(resizeMethod);

        return resizeMethod;
    }

    /**
     * Removes listener for browser resize
     * @param  {Function} callback Reference of the listener to remove
     */
    function _uninstallResizeMethod(callback) {
        Viewport.offResize(callback);
    }

    /**
     * Calculates popup position based on the reference HTML element on conf.target.
     * Then, calls popupElement.show.
     * @param  {HTMLElement}    popupElement                component to show as a popup
     * @param  {HTMLElement}    referenceElement            reference element to position the popup
     * @param  {Array}          positions                   ordered list of possible positions to fit the popup
     * @param  {Array}          alignment                   ordered list of possible alignments to try to fit the popup
     * @param  {Number}         margin                      margin to add to the BASE_MARGIN
     * @param  {Object}         customPositioningMethods    custom position or alignment methods
     */
    function _show(popupElement, referenceElement, positions, alignment, margin, customPositioningMethods) {
        var setupSuccessful = false;

        if (!document.body.contains(referenceElement)) {
            // Silently fail if the target is not in the DOM.
            return;
        }

        if (popupElement.show && !popupElement.classList.contains('visible')) {
            setupSuccessful = _setPosition(popupElement, referenceElement, positions, alignment, margin, customPositioningMethods);
            if (setupSuccessful) {
                popupElement.show();
            }
        }

    }

    /**
     * Hides the previously shown component
     * @param  {HTMLElement} popupElement Component to be hidden
     */
    function _hide(popupElement) {
        if (popupElement && popupElement.open) {
            popupElement.close();
        }

        removeScrollHandler(popupElement);
    }

    return {
        installResizeMethod: _installResizeMethod,
        uninstallResizeMethod: _uninstallResizeMethod,
        clearPosition: _clearPosition,
        setPosition: _setPosition,
        show: _show,
        hide: _hide
    };
});

define('hui/core/tooltip',[], function() {
    function resetTooltipDismissal(tooltip) {
        var leaveEvent = tooltip.trigger === 'focus' ? 'blur' : 'mouseleave',
            numTargets = tooltip._listenersTargets.length,
            elem,
            target;
        for (elem = 0; elem < numTargets; ++elem) {
            target = tooltip._listenersTargets[elem];
            if (target) {
                if (!tooltip.dismissible && tooltip.duration <= 0  && tooltip.trigger !== 'custom') {
                    tooltip.listenTo(target, leaveEvent, tooltip._hideCallback, true);
                } else {
                    tooltip.stopListening(target, leaveEvent, tooltip._hideCallback, true);
                }
            }
        }
    }

    return {
        /**
         * When targets change, we need to remove the listeners from the old targets
         * @param  {HTMLElement} tooltip Current tooltip
         */
        removeOldListeners: function(tooltip) {
            var numTargets = tooltip._listenersTargets.length,
                leaveEvent = tooltip.trigger === 'focus' ? 'blur' : 'mouseleave',
                enterEvent = tooltip.trigger === 'hover' ? 'mouseenter' : 'focus',
                elem, target;
            for (elem = 0; elem < numTargets; ++elem) {
                target = tooltip._listenersTargets[elem];
                tooltip.stopListening(target, enterEvent, tooltip._showCallback, true);
                tooltip.stopListening(target, leaveEvent, tooltip._hideCallback, true);
            }
        },

        /**
         * Removes old event listeners and add new ones
         * @param {HTMLElement} tooltip   The current tooltip
         * @param {String} newEvent  The new event to attach listeners to
         */
        resetListeners: function(tooltip, newEvent) {
            var enterEvent, oldEnterEvent, elem, target;

            if (newEvent === 'hover') {
                oldEnterEvent = 'focus';
                enterEvent = 'mouseenter';
            } else if (newEvent === 'focus') {
                oldEnterEvent = 'mouseenter';
                enterEvent = 'focus';
            }

            // Remove listener for each target
            for (elem = 0; elem < tooltip._listenersTargets.length; ++elem) {
                target = tooltip._listenersTargets[elem];
                if (target) {
                    tooltip.stopListening(target, oldEnterEvent, tooltip._showCallback, true);
                    if (tooltip.trigger !== 'custom') {
                        tooltip.listenTo(target, enterEvent, tooltip._showCallback, true);
                    }
                }
            }
            resetTooltipDismissal(tooltip);
        },

        /**
         * Updates the way in which the tooltip dismissal is handled
         * @param {HTMLElement} tooltip   The current tooltip
         */
        resetTooltipDismissal: resetTooltipDismissal,

        /**
         * Caches the tooltip targets in a "private" variable for future use
         * @param {HTMLElement} tooltip   The current tooltip
         * @param {String} targetSelector A selector to match the desired targets
         */
        setTooltipTargets: function(tooltip, targetSelector) {
            if (targetSelector.indexOf('_previousSibling') === -1) {
                tooltip._listenersTargets = tooltip.ownerDocument.querySelectorAll(targetSelector);
            } else {
                var restOfSelector = targetSelector.split('_previousSibling')[1];
                if (restOfSelector) {
                    tooltip._listenersTargets = [tooltip.previousElementSibling.querySelector(restOfSelector.trim()) || tooltip.previousElementSibling];
                } else {
                    tooltip._listenersTargets = [tooltip.previousElementSibling];
                }
            }
        }
    };
});

define('register-component/v2/register',[], function() {

    var doc = typeof document !== "undefined" && document,  // "typeof document" check so module loads in NodeJS

    /**
     * Internal registry of widget class metadata.
     * Key is custom widget tag name, used as Element tag name like <ha-text-field>
     * Value is metadata about the widget, including its prototype, ex: {prototype: object, extends: "button", ... }
     * @type {Object}
     */
    registry = {};

    function register(tag, proto) {
        //var bases, baseElement;

        // Check to see if the custom tag is already registered
        if (tag in registry) {
            throw new TypeError("A widget is already registered with tag '" + tag + "'.");
        }
        var config = registry[tag] = {
            prototype: proto
        };
        return doc.registerElement(tag, config);
    }

    return register;
});
define('register-component/v2/UIComponent',[
    "object-utils/classes"
], function(classes) {
    "use strict";

    var UIComponent,
        componentIdCounter = 0,
        listenToCounter = 0,

        _defineProperty = Object.defineProperty;

    function matchesSelectorListener(selector, listener, contextNode) {
        return function(e) {
            var matchesTarget = matches(e.target, selector, contextNode);
            if (matchesTarget) {
                listener(e, matchesTarget);
            }
        };
    }

    function _isTypeObject(what) {
        return what.stringify && what.parse;
    }

    function _parseTypeCast(what, propertyName) {
        if (what) {
            if (typeof what === "function") {
                what = {
                    stringify: what,
                    parse: what
                };
            }
            if (!_isTypeObject(what)) {
                throw new TypeError(propertyName + ": invalid type");
            }
        }
        return what || null;
    }

    // like _assertFunction but can take a string method name, allowing child overrides
    function _assertMethodIfExists(what, optionName, propertyName) {
        var type = typeof what;
        if (what && !(type === "function" || type === "string")) {
            throw new TypeError(propertyName + ": " + optionName + " not a function or method name");
        }
        return what || null;
    }

    /**
     * Makes a (non-enumerable) own object if necessary
     *
     * @param {Object} object Some object
     * @param {string} propertyName
     * @returns {object}
     * @private
     */
    function _objectMap(object, propertyName) {
        if (!object.hasOwnProperty(propertyName)) {
            _defineProperty(object, propertyName, {
                value: Object.create(null)
            });
        }
        return object[propertyName];
    }

    /**
     * Check if a node match the current selector within the constraint of a context node
     * @param  {HTMLElement} node        The node that originate the event
     * @param  {String} selector         The selector to check against
     * @param  {HTMLElement} contextNode The context to search in
     * @return {HTMLElement|Boolean}     The matching node if any. Else you get false.
     */
    function matches(node, selector, contextNode) {
        var matchesSelector = node.matches || node.webkitMatchesSelector || node.mozMatchesSelector || node.msMatchesSelector;

        while (node && node.nodeType === 1 && node !== contextNode) {
            if (matchesSelector.call(node, selector)) {
                return node;
            } else {
                node = node.parentNode;
            }
        }
        return false;
    }

    function _makeGetConverter(propertyName, typeCast, defaultValue) {
        if (defaultValue === undefined) {
            defaultValue = null;
        }

        var parse = typeCast && typeCast.parse;

        return parse === Boolean ? function(value) {
            return value !== null && value !== "false";
        } : parse ? function(value) {
            return value === null ? defaultValue : parse(value, propertyName);
        } : function(value) {
            return value === null ? defaultValue : value;
        };
    }

    function _makeAttributeGetterSetter(object, propertyName, attributeName, typeCast, getConverter) {
        var stringify = typeCast && typeCast.stringify;

        _defineProperty(object, propertyName, {
            get: function() {
                return getConverter(this.getAttribute(attributeName));
            },
            set: stringify === Boolean ? function(value) {
                if (value) {
                    this.setAttribute(attributeName, attributeName);
                } else {
                    this.removeAttribute(attributeName);
                }
            } : stringify ? function(value) {
                value = (value === null ? value : stringify(value, propertyName));

                if (value === null || value === "") {
                    this.removeAttribute(attributeName);
                } else {
                    this.setAttribute(attributeName, value);
                }
            } : function(value) {
                if (value === null || value === "") {
                    this.removeAttribute(attributeName);
                } else {
                    this.setAttribute(attributeName, value);
                }
            }
        });
    }

    function _findChildren(parent) {
        var children = [];

        function loop(el) {
            var nodes = el.children,
                node;

            for (var i = 0; i < nodes.length; ++i) {
                node = nodes[i];
                if (node.tagName.indexOf("-") >= 0) {
                    // custom elements must contain a "-"
                    children.push(node);
                } else if (node.children.length){
                    loop(node);
                }
            }
        }

        loop(parent);

        return children;
    }

    UIComponent = classes.createObject(HTMLElement.prototype, {

        /**
         * Initialization method (like a constructor)
         *
         * @protected
         */
        init: function() {
            /**
             * Root CSS class of the component
             * @member {String}
             * @protected
             */
            this.baseClass = "";

            /**
             * Unique id for this component, separate from id attribute (which may or may not be set).
             * @member {Number}
             * @constant
             * @readonly
             * @protected
             */
            this.componentId = 0;

            /**
             * Value returned by a handlebars AMD plugin or compatible template engine.
             * Specifies how to build the widget DOM initially and also how to update the DOM when
             * widget properties change.
             * @member {Function}
             * @protected
             */
            this.template = null;

            /**
             * Kick off the life-cycle of a component.
             *
             * Calls a number of component methods (`render()` which calls `preRender()` and `postRender()`),
             * some of which of you'll want to override.
             *
             * Don't override createdCallback.
             * @protected
             */
            this.componentId = ++componentIdCounter;
        },

        /**
         * Don't override createdCallback, which is used to both construct and render a component.
         * Instead override the above 'init' callback, which will be called after defaults are set but before
         * the component has been rendered.
         */
        createdCallback: function() {
            _defineProperty(this, "_attrChangeCalls", {
                value: {}
            });

            this.init();

            // handle initial class names
            if (this.baseClass) {
                var classNames = this.baseClass.split(" ").filter(Boolean);
                classNames.forEach(function(item) {
                    this.classList.add(item);
                }, this);
            }

            this._setupEventAttrbutes();

            this.render();

            this._listenforReady();

            this._rendered = true;

            this._initBoundProperties();
        },

        _listenforReady: function() {
            var eventName = "component-upgraded",
                children = _findChildren(this),
                numUpgraded = children.reduce(function(prev, child) {
                    return child._upgraded ? prev + 1 : prev;
                }, 0),
                numChildren = children.length,
                func = function(event) {
                    event.stopPropagation();
                    if (++numUpgraded === numChildren) {
                        this.removeEventListener(eventName, func);
                        this.ready();
                    }
                }.bind(this);

            if (numChildren) {
                this.addEventListener(eventName, func);
            } else {
                this.ready();
            }
        },

        ready: function() {
            this._upgraded = true;
            this.emit("component-upgraded", { bubbles: true });
        },

        /**
         * Placeholder that _.super call works
         */
        attachedCallback: function() { },

        attributeChangedCallback: function(attrName, oldValue, newValue) {
            var attrRecord  = this._attributes && this._attributes[attrName.toLowerCase()];

            attrName = attrName.toLowerCase();

            if (attrRecord) {
                var pendingChangeCalls = this._attrChangeCalls;
                if (pendingChangeCalls[attrName] > 0) {
                    pendingChangeCalls[attrName]--;
                } else {
                    this._attributeChanged(attrName, oldValue, newValue);
                }
            }
        },

        /**
         * Processing before `render()`.
         *
         * @protected
         */
        preRender: function() { },

        /**
         * Processing after the DOM fragment is created from `render()`.
         *
         * Called after the DOM fragment has been created, but not necessarily
         * added to the document.  Do not include any operations which rely on
         * node dimensions or placement.
         *
         * @protected
         */
        postRender: function() { },

        /**
         * Construct the UI for this widget, filling in subnodes and/or text inside of this.
         * Most widgets will leverage handlebars AMD plugin to set `template`, rather than define this method.
         * @protected
         */
        render: function() {
            var str;

            if (this._rendered) {
                return;
            }

            this.preRender();

            if (this.template) {
                str = this.template(this);
                // remove the <template> tag
                this.innerHTML = str.replace(/<[\/]{0,1}(template|TEMPLATE)[^><]*>/g, "");
            }

            this.postRender();
        },

        /**
         * Calls the initial change handlers on any bound properties
         * @private
         */
        _initBoundProperties: function() {
            var attrChangeCalls = this._attrChangeCalls;

            if (this._attributes) {
                Object.keys(this._attributes).forEach(function(attrName) {
                    attrChangeCalls[attrName.toLowerCase()] = 0;
                    this._attributeChanged(attrName, null, this.getAttribute(attrName));
                }, this);
            }
        },

        /**
         * Registers attribute-property bindings and synchronous change handlers
         * Call this.setupProperties() from inside init() or Prototype.setupProperties() when creating the prototype
         *
         * Specify a mapping of property name to type conversion functions (such as Boolean, Number, String, etc)
         * or configuration objects, with the following properties (all optional)
         *
         * Boolean types are handled like native HTML boolean attributes (like option.selected): if an
         * attribute is present it's true, and if missing it's false. As a concession to template systems
         * that don't recognize nonstandard boolean attributes, it's also false if set to the string "false".
         *
         * The type option can take a simple type cast function or object with 'stringify' and 'parse' methods.
         * stringify() converts from an arbitrary property value to the DOM attribute's string representation,
         * and parse() converts it back. See the custom types in attributeTypes.js for examples.
         *
         *   - *type*: a type conversion function, which takes a string or user-provided value and outputs the desired
         *     type. The builtins Number, String, and Boolean will work as is, while other types will require a custom
         *     converter. Defaults (implicitly) to String, since actual values are stored in the DOM as strings.
         *   - *attribute*: the attribute name to map to. Defaults to the property name in lowercase.
         *     In HTML documents, attributes are case-insensitive but the provided case will reflect newly-created
         *     attributes.
         *   - *default*: the value when the attribute doesn't exist. Ignored for Booleans since their default
         *     is always false.
         *
         * @param {object} attributeMap
         */
        setupProperties: function(attributeMap) {

            var boundAttributes = _objectMap(this, "_attributes"),
                boundProperties = _objectMap(this, "_properties");

            for (var propertyName in attributeMap) {
                var attrOptions = attributeMap[propertyName],
                    typeCast, defaultValue, attrName, attrChangeCallback;

                if (typeof attrOptions === "function" || _isTypeObject(attrOptions)) {
                    typeCast = attrOptions;
                    attrOptions = {};
                } else {
                    typeCast = attrOptions.type || null;
                }
                typeCast = _parseTypeCast(typeCast, propertyName);

                attrChangeCallback = attrOptions.change;

                attrName = attrOptions.attribute || propertyName.toLowerCase();
                defaultValue = attrOptions["default"];

                var getConverter = _makeGetConverter(propertyName, typeCast, defaultValue);

                if (propertyName in boundProperties) {
                    throw new Error("Property " + propertyName + " already bound");
                }
                if (attrName.toLowerCase() in boundAttributes) {
                    throw new Error("Attribute " + attrName + " already bound");
                }

                _makeAttributeGetterSetter(this, propertyName, attrName, typeCast, getConverter);

                boundAttributes[attrName.toLowerCase()] = boundProperties[propertyName] = {
                    p: propertyName,
                    c: _assertMethodIfExists(attrOptions.change, "change callback", propertyName),
                    g: getConverter
                };
            }

            return this;
        },

        /**
         * Call the change handler for attrName, if one exists
         *
         * @param {string} attrName
         * @param {string} oldAttrValue
         * @param {string} newAttrValue
         * @private
         */
        _attributeChanged: function(attrName, oldAttrValue, newAttrValue) {
            var attrRecord  = this._attributes && this._attributes[attrName.toLowerCase()],
                changeCallback;

            if (attrRecord && (changeCallback = attrRecord.c)) {
                var typeCast = attrRecord.g,
                    newValue = typeCast(newAttrValue),
                    oldValue = typeCast(oldAttrValue);

                if (typeof changeCallback === "function") {
                    changeCallback.call(this, newValue, oldValue);
                } else {
                    this[changeCallback](newValue, oldValue);
                }
            }
        },

        /**
         * @private
         */
        _setupEventAttrbutes: function() {
            /** @const */
            var EVENT_ATTRIBUTE_RE = /^data-on-(.+)$/,
                attributes = this.attributes;

            for (var i = 0, l = attributes.length; i < l; i++) {
                var attribute = attributes[i],
                    attrNameMatch;
                if ((attrNameMatch = EVENT_ATTRIBUTE_RE.exec(attribute.name))) {
                    var eventName = attrNameMatch[1],
                        handlerName = attribute.value,
                        handlerFunc = this[handlerName];

                    if (typeof handlerFunc === "function") {
                        this.on(eventName, handlerFunc);
                    } else {
                        console.warn(this.nodeName + ": event handler \"" + handlerName + "\" is not " +  handlerName ? "a function" : "defined");
                    }
                }

            }
        },

        /**
         * On is a chainable method that allows us to bind a dom event to a `callback` function in the view's rootNode
         * @param  {String} type Then name of the dom event
         * @param  {Function} callback The callback function that gets called when a 'emit' happens
         * @return {Object} Returns the this object to allow for chaining.
         */
        on: function(type, callback) {
            return this.listenTo(this, type, callback);
        },

        /**
         * Off is a chainable method that removes one or many callbacks in the view's rootNode
         * @param  {String} type Name of the event. If `name` is null, removes all bound callbacks for all events
         * @param  {Function} callback If `callback` is null, removes all callbacks for the event
         * @return {Object} Returns the this object in order to allow chaining.
         */
        off: function(type, callback) {
            return this.stopListening(this, type, callback);
        },

        /**
         * Emits a syntethic event of specified type, firing all bound callbacks.
         * @param {String} type The name of the event.
         * @param {Object} eventObj An object that provides the properties for the event.
         * Can also contain `bubbles` and `cancelable` properties. See https://developer.mozilla.org/en/DOM/event.initEvent.
         * These properties are copied to the event object.
         * @return {Boolean} True if the event was not canceled, false if it was canceled.
         */
        emit: function(type, eventObj) {
            eventObj = eventObj || {};

            var nativeEvent,
                bubbles = "bubbles" in eventObj ? eventObj.bubbles : true,
                cancelable = "cancelable" in eventObj ? eventObj.cancelable : true;

            nativeEvent = this.ownerDocument.createEvent("HTMLEvents");
            nativeEvent.initEvent(type, bubbles, cancelable);

            for (var i in eventObj) {
                if (!(i in nativeEvent)) {
                    nativeEvent[i] = eventObj[i];
                }
            }
            return this.dispatchEvent(nativeEvent);
        },

        /**
         * @property _listeningTo
         * @type {Object}
         * @private
         */
        // _listeningTo: null

        /**
         * Tell an object to listen to a particular event on another object.
         * Allows the object to keep track of the events, and they can be removed all at once later on.
         *
         * @param {HTMLElement} obj        An Element you want to listen to
         * @param {String}      name       The event to listen to
         * @param {Function}    callback   The callback function that will be executed
         * @param {Boolean}     useCapture If true, useCapture indicates that the user wishes to initiate capture
         *
         * @return {HTMLElement} The element instance
         */
        listenTo: function(obj, name, callback, useCapture) {
            var listeningTo, id;

            if (!callback && typeof name === "object") {
                callback = this;
            }

            listeningTo = this._listeningTo || (this._listeningTo = {});
            id = "l" + (++listenToCounter);
            listeningTo[id] = {object: obj, name: name, callback: callback};

            // if dom node
            if (obj.addEventListener) {

                // supports name in the form of
                // "selector:click" e.g "a:click"
                var selector = name.match(/(.*):(.*)/);
                // if we have a selector:event, the last one is interpreted as an event, and we use event delegation
                if (selector) {
                    name = selector[2];
                    selector = selector[1];
                    callback = matchesSelectorListener(selector, callback, obj);
                    listeningTo[id].callback = callback;
                    listeningTo[id].name = name;
                }

                obj.addEventListener(name, callback, !!useCapture);
            } else if (obj.on) {
                obj.on(name, callback, this);
            }

            return this;
        },

        /**
         * Tell an object to stop listening to events. Either call stopListening with no arguments to have the object
         * remove all of its registered callbacks ...
         * or be more precise by telling it to remove just the events it's listening to on a specific object,
         * or a specific event, or just a specific callback.
         *
         * @param  {HTMLElement} [obj]        Optional If you want to stop listening to events for that particular Element only
         * @param  {String}      [name]       Optional event name
         * @param  {Function}    [callback]   Optional The listener function you want to stop listening
         * @param  {Boolean}     [useCapture] Optional Specifies whether the listener being removed was registered as a capturing listener or not. If not specified, useCapture defaults to false.
         *
         * @return {HTMLElement} The element instance
         */
        stopListening: function(obj, name, callback, useCapture) {
            var listeningTo = this._listeningTo,
                map = {},
                item,
                id;

            if (!listeningTo) {
                return this;
            }

            if (obj && !name && !callback) {
                // stopListening(obj)
                for (id in listeningTo) {
                    if (listeningTo[id].object === obj) {
                        map[id] = listeningTo[id];
                    }
                }
            } else if (obj && name && !callback) {
                // stopListening(obj, "click")
                for (id in listeningTo) {
                    if (listeningTo[id].object === obj && listeningTo[id].name === name) {
                        map[id] = listeningTo[id];
                    }
                }
            } else if (obj && name && callback) {
                // stopListening(obj, "click", callback)
                for (id in listeningTo) {
                    if (listeningTo[id].object === obj && listeningTo[id].name === name && listeningTo[id].callback === callback) {
                        map[id] = listeningTo[id];
                    }
                }
            } else if (!obj && !name && !callback) {
                // stopListening() stop listening to all
                map = listeningTo;
            }

            for (id in map) {
                item = map[id];

                // if dom node
                if (item.object.removeEventListener) {
                    item.object.removeEventListener(item.name, item.callback, !!useCapture);
                } else if (item.object.off) {
                    item.object.off(item.name, item.callback, this);
                }

                delete this._listeningTo[id];
            }

            return this;
        },

        /**
         * Overrides HTMLElement's setAttribute to call custom attribute change observers (declared with
         * setupProperties()) synchronously. This is needed because when WebComponent polyfills are used
         * attributeChangedCallback becomes asynchronous.
         *
         * @param {string} attrName
         * @param {*} attrValue
         */
        setAttribute: function setAttribute(attrName, attrValue) {
            this._attrChangeCalls[ ("" + attrName).toLowerCase() ]++;

            var oldValue = this.getAttribute(attrName);
            setAttribute.superFunc.call(this, attrName, attrValue);
            var newValue = this.getAttribute(attrName);

            if (oldValue !== newValue) {
                this._attributeChanged(attrName, oldValue, newValue);
            }
        },

        /**
         * Overrides HTMLElement's removeAttribute to call custom attribute change observers (declared with
         * setupProperties()) synchronously. This is needed because when WebComponent polyfills are used
         * attributeChangedCallback becomes asynchronous.
         *
         * @param {string} attrName
         */
        removeAttribute: function removeAttribute(attrName) {
            // just return if attribute doesn't exist anymore
            if (!this.hasAttribute(attrName)) {
                return;
            }

            this._attrChangeCalls[ ("" + attrName).toLowerCase() ]++;

            var oldValue = this.getAttribute(attrName);

            removeAttribute.superFunc.call(this, attrName);

            if (oldValue !== null) {
                this._attributeChanged(attrName, oldValue, null);
            }
        }
    });

    return UIComponent;
});

define('hui/core/keys',[
], function() {
    return {
        BACKSPACE: 8,
        TAB: 9,
        ENTER: 13,
        SPACEBAR: 32,
        ESCAPE: 27,
        PAGEUP: 33,
        PAGEDOWN: 34,
        END: 35,
        HOME: 36,
        LEFT: 37,
        UP: 38,
        RIGHT: 39,
        DOWN: 40,
        DELETE: 46,
        MINUS: 189,
        EQUALS: 187,
        NUM_PAD_MINUS: 109,
        NUM_PAD_PLUS: 107,
        H: 72,
        K: 75,
        M: 77,
        R: 82,
        T: 84,
        W: 87,
        Y: 89,
        isLetter: function(keycode) {
            return (keycode > 64 && keycode < 91);
        },
        isNumber: function(keycode) {
            return ((keycode > 47 && keycode < 58) || (keycode > 95 && keycode < 106));
        },
        isSpecialChar: function(keycode) {
            return ((keycode > 106 && keycode < 112) || (keycode > 185 && keycode < 223));
        }
    };
});
define('hui/core/a11y',[
    './keys'
], function(keys) {
    var a11y,
        _elementsFocusable = [
            'INPUT',
            'SELECT',
            'BUTTON',
            'TEXTAREA',
            'A',
            'AREA',
            'OBJECT'
        ];

    /**
     * Stops the event.
     * @param {HTMLElement} evt
     */
    function _stopEvt(evt) {
        evt.stopPropagation();
        evt.preventDefault();
    }

    /**
     * Handler for the first focusable element onBlur.
     * When we detect that the first focusable element has lost the focus
     * we force it to be on the component wrapper.
     * @param {KeyboardEvent} event
     * @param {HAPopover} component
     */
    function _firstElementKeydownHandler(event, component) {
        if (event.shiftKey) {
            component.focus();
        }
    }

    /**
     * Handler for the last focusable element onBlur.
     * When we detect that the last focusable element has lost the focus
     * we force it to be the on component wrapper.
     * @param {KeyboardEvent} event
     * @param {HAPopover} component
     */
    function _lastElementBlurKeydownHandler(event, component) {
        if (!event.shiftKey) {
            component.focus();
        }
    }

    /**
     * Return the indexTab of the element, considering native elements focusable.
     * @param {HTMLElement} elem that contain the indexTab attribute.
     * @returns {Number} return the TabIndex value of current element, if don't have one
     * will return undefined.
     * @private
     */
    function _getTabIndex(elem) {
        if (elem.hasAttribute('tabIndex')) {
            return +elem.getAttribute('tabIndex');
        } else {
            return _elementsFocusable.indexOf(elem.tagName) > -1 ? 0 : undefined;
        }
    }

    /**
     * Returns if the element is hidden
     * @param  {HTMLElement}  elem The element
     * @param {HTMLElement} component - Component Element
     * @return {Boolean} True if the element is hidden
     */
    function _isHidden(elem, component) {
        var isHidden,
            styles;
        if (component) {
            isHidden = false;
            do {
                isHidden = elem.style.display === 'none' || elem.style.visibility === 'hidden' ||
                    elem.classList.contains('hidden');
                elem = elem.parentElement;
            } while (elem && elem !== component && !isHidden);
            return isHidden;
        } else {
            styles = window.getComputedStyle(elem);
            return ((styles.display && styles.display === 'none') || (styles.visibility && styles.visibility === 'hidden'));
        }
    }

    a11y = {
        /**
         * Given a component returns the first and (optionally) the last
         * focusable element.
         * Focusable is interpreted as any element that has a tabIndex > -1.
         *
         * @param {HTMLElement} component The component to inspect.
         * @param {Boolean} last If we need the last child or not.
         * @param {Boolean} displayedOnly If we should ignore elements that are not displayed
         * @return {Object} object.first {HTMLElement}
         *                  object.last {null || HTMLElement}
         */
        getBoundariesTabableElement: function(component, last, displayedOnly) {
            var elements = {},
                i = 0,
                innerElements = component.querySelectorAll('*'),
                currentElement,
                styles;

            elements.first = null;
            for (i; null === elements.first && i < innerElements.length; ++i) {
                currentElement = innerElements[i];
                if (displayedOnly) {
                    styles = window.getComputedStyle(currentElement);
                }
                if (currentElement && this.isTabNavigable(currentElement, component)) {
                    if (!displayedOnly || (styles.display !== 'none' && styles.visibility !== 'hidden')) {
                        elements.first = currentElement;
                    }
                }
            }

            elements.last = null;
            if (last) {
                i = innerElements.length - 1;
                for (i; null === elements.last && i > 0; --i) {
                    currentElement = innerElements[i];
                    if (displayedOnly) {
                        styles = window.getComputedStyle(currentElement);
                    }
                    if (innerElements[i] && this.isTabNavigable(innerElements[i], component)) {
                        if (!displayedOnly ||(styles.display !== 'none' && styles.visibility !== 'hidden')) {
                            elements.last = currentElement;
                        }
                    }
                }
            }

            return elements;
        },

        _getFirstTabable: function(component) {
            var innerElements = component.querySelectorAll('*'),
                element,
                i;

            element = null;
            for (i = 0; i < innerElements.length; ++i) {
                if (this.isTabNavigable(innerElements[i])) {
                    element = innerElements[i];
                    break;
                }
            }

            return element;
        },

        _getFirstFocusable: function(component) {
            var innerElements = component.querySelectorAll('*'),
                element,
                i;

            element = null;
            for (i = 0; i < innerElements.length; ++i) {
                if (this.isFocusable(innerElements[i])) {
                    element = innerElements[i];
                    break;
                }
            }

            return element;
        },

        /**
         * Return if the element is tabable or not.
         * @param {HTMLElement} elem that will be validated.
         * @param {HTMLElement} component - Component Element
         * @returns {Boolean}
         */
        isTabNavigable: function(elem, component) {
            return !elem.disabled && !_isHidden(elem, component) && _getTabIndex(elem)  >= 0;
        },

        /**
         * Return if the element is focusable or not.
         * @param {HTMLElement} elem that will be validated.
         * @returns {Boolean}
         */
        isFocusable: function(elem) {
            return !elem.disabled && !_isHidden(elem) && _getTabIndex(elem) >= -1;
        },

        /**
         * Keeps the focus inside the element while using the TAB.
         * @param {KeyboardEvent} evt
         * @param {HTMLElement} component The component to inspect.
         */
        keepFocusInsideListener: function(evt, component) {
            var elements,
                target;

            if (evt.keyCode === keys.TAB) {
                elements = this.getBoundariesTabableElement(component, true);
                target = evt.target;

                // If first and last elements are equal, we should not stop the propagation
                // because if we do, the focus never is going to leave that element.
                // The component wrapper could be also empty so we need to check if the getBoundariesTabableElement
                // has returned somethign or not.
                if (elements.first && elements.last) {

                    // If the shiftKey was pressed along with the tab, we need to move back.
                    if (evt.shiftKey) {

                        // If the the target is the first focusable element, the focus needs to go
                        // to the component wrapper according with what we agreed with @TedDrake.
                        if (target === elements.first) {
                            _stopEvt(evt);
                            _firstElementKeydownHandler(evt, component);

                            // Similary if the target is the component, we need to go back to the last
                            // focusable element.
                        } else if (target === component) {
                            _stopEvt(evt);
                            elements.last.focus();
                        }

                        // Target is the last focusable element and shiftKey wasn't pressed, so the focus needs
                        // to go to the component wrapper.
                    } else if (target === (elements.last)) {
                        _stopEvt(evt);
                        _lastElementBlurKeydownHandler(evt, component);
                    }
                } else {
                    _stopEvt(evt);
                    _lastElementBlurKeydownHandler(evt, component);
                }
            }
        },

        /**
         * Sets the focus to first input or focusable element.
         * Ussually this will be called from the components show method.
         * @param {HTMLElement} component The component to inspect.
         */
        setFocusOnFirst: function(component) {
            var elements = this.getBoundariesTabableElement(component);

            if (elements.first) {
                elements.first.focus();
                return elements.first;
            }
        },

        /**
         * Sets the focus to first tabable element. If there isn't any,
         * sets focus on first focusable element
         * @param {HTMLElement} component The component to inspect.
         * @return {HTMLElement} The element that was found
         */
        setFocusOnAnyFirst: function(component) {
            var element;

            element = this._getFirstTabable(component) ||  this._getFirstFocusable(component);

            if (element) {
                element.focus();
            }

            return element;
        },

        /**
         * Set focus on any previous sibling if any of them is focusable.
         * Otherwise, it sets focus on parent element, taking into account if it's focusable or not,
         * in the last case adding a class to hide any potential outline
         * @param  {HTMLElement} component Reference component to find siblings
         */
        setFocusOnPreviousElement: function(component) {
            var parent = component.parentElement,
                previousSibling = component.previousElementSibling;

            while (previousSibling) {
                if (this.isFocusable(previousSibling) && !_isHidden(previousSibling)) {
                    previousSibling.focus();
                    return;
                }
                previousSibling = previousSibling.previousElementSibling;
            }

            if (this.isFocusable(parent)) {
                parent.focus();
                return;
            } else {
                //We force focusable
                parent.classList.add('hidden-focus-style');
                parent.setAttribute('tabindex', -1);
                parent.focus();
            }

        },

        addA11yFocus: function(component) {
            component._mouseActive = false;
            component.classList.add('ha-a11y-focus');
            component.listenTo(component, 'mousedown', function() {
                component._mouseActive = true;
                setTimeout(function() {
                    component._mouseActive = false;
                }, 150);
            });

            component.listenTo(component, 'focus', function() {
                if (!component._mouseActive) {
                    component.classList.add('ha-a11y-focused');
                }
            }, true);

            component.listenTo(component, 'blur', function() {
                component.classList.remove('ha-a11y-focused');
            }, true);
        },

        hideChildElementsFromAria: function(parentNode, exclusions) {
            var isExcluded = false,
                i,
                removals = [],
                attribute = 'aria-hidden';

            exclusions = exclusions || [];

            Array.prototype.slice.call(parentNode.children, 0).forEach(function(child) {
                isExcluded = false;

                for (i = 0; i < exclusions.length; i++) {
                    if (exclusions[i] === child) {
                        isExcluded = true;
                        break;
                    }
                }

                if (!isExcluded) {
                    removals.push({
                        element: child,
                        oldValue: child.getAttribute(attribute)
                    });
                    child.setAttribute(attribute, true);
                }
            });

            exclusions.forEach(function(node) {
                if (node) {
                    removals.push({
                        element: node,
                        oldValue: node.getAttribute(attribute)
                    });

                    node.removeAttribute('aria-hidden');
                }
            });

            return {
                remove: function() {
                    removals.forEach(function(values) {
                        if (!values.oldValue) {
                            values.element.removeAttribute(attribute);
                        } else {
                            values.element.setAttribute(attribute, values.oldValue);
                        }
                    });
                }
            };
        }
    };

    return a11y;
});

define('hui/segmented-button',[
    'register-component/v2/register',
    'register-component/v2/UIComponent',
    'object-utils/classes',
    './core/utils',
    './core/a11y',
    './core/keys'
], function(register, UIComponent, classes, utils, a11y, keys) {
    'use strict';

    /**
     * Arrows key press handler.
     * @param {HTMLElement} component
     * @param {Event} evt The key press event.
     */
    function _onButtonKeypress(component, evt) {
        var key = evt.keyCode,
            selectButton;

        if (key === keys.LEFT) {
            // left arrow
            selectButton = utils.getPrevSiblingOfType(evt.target, 'BUTTON');
        } else if (key === keys.RIGHT) {
            // right arrow
            selectButton = utils.getNextSiblingOfType(evt.target, 'BUTTON');
        }

        if (selectButton) {
            selectButton.focus();
            component.selectedItem = selectButton;
        }
    }

    /**
     * sets the spected properties to a clicked button
     * @param {Event} evt The click event that triggered the handler.
     * @emits HASegmentedButton#click
     */
    function _onButtonClick(evt) {
        evt.stopPropagation();
        var component = utils.getComponentFromElement(evt.target, 'HA-SEGMENTED-BUTTON');

        component.selectedItem = evt.target;
        component.emit('click');
    }

    /**
     * Given a SegmentedButton component, it removes all the aria pressed
     * from the elements who belong to the same group.
     * @param {HTMLElement} component The component to inspect.
     */
    function _removeARIAPressedFromGroup(component) {
        var buttons = component.buttons,
            i = 0;

        for (i; i < buttons.length; i++) {
            buttons[i].setAttribute('aria-pressed', false);
        }
    }

    var HASegmentedButton =  classes.createObject(UIComponent, {

        /**
         * buttons is the list of buttons that the segmented button owns
         * @type {Array}
         */
        set buttons(buttons) {
            var oldButtons = [].slice.call(this.querySelectorAll('button')),
                lastSelected,
                elements;

            oldButtons.forEach(function(btn) {
                this.stopListening(btn, 'click', _onButtonClick);
                this.removeChild(btn);
            }.bind(this));

            elements =  [].slice.call(buttons);

            elements.forEach(function(btn) {
                var label = btn.label || btn.getAttribute('label');

                btn.classList.add('ha-button');
                btn.disabled = btn.disabled || btn.getAttribute('disabled');

                if (label) {
                    console.warn('Label property is deprecated. Should use textContent instead.');
                }

                if (!btn.textContent && label) {
                    btn.textContent = label;
                }

                if (btn.getAttribute('selected') || btn.selected) {
                    // save as selected
                    lastSelected = btn;
                }

                btn.setAttribute('aria-pressed', false);

                this.listenTo(btn, 'click', _onButtonClick);

                // save buttons
                this._buttons.push(btn);

                this.appendChild(btn);

            }.bind(this));

            if (lastSelected) {
                // set last button to selected
                this.selectedIndex = [].indexOf.call(this.buttons, lastSelected);
            } else if (this._buttons.length > 0) {
                // set the default value
                this.selectedIndex = 0;
            }
        },

        /**
          * The selected button
          * @type {HTMLElement}
          */
        set selectedItem(selectedItem) {
            this._selectedItem = selectedItem;
            if (this.value !== selectedItem.value) {
                this.value = selectedItem.value;
            }
        },

        get buttons() {
            return this._buttons;
        },

        get selectedItem() {
            return this._selectedItem;
        },

        init: function _() {
            _.super(this);

            this.setupProperties({
                /**
                 * Index of the selected button
                 * @type {Number}
                 */
                selectedIndex: {
                    default: 0,
                    type: Number,
                    change: function(newValue) {
                        var button = this.buttons[newValue];

                        if (button) {
                            _removeARIAPressedFromGroup(this);
                            button.setAttribute('aria-pressed', true);
                            if (this.selectedItem !== button) {
                                this.selectedItem = button;
                            }
                        }
                    }
                },

                /**
                 * Value of the selected button
                 * @type {String}
                 * @emits HASegmentedButton#change
                 */
                value: {
                    default: '',
                    change: function(newValue) {
                        var buttons = [].slice.call(this.buttons);

                        if (newValue) {
                            buttons.every(function(btn, index) {
                                if (btn.value === newValue) {
                                    this.selectedIndex = index;
                                    return false;
                                } else {
                                    return true;
                                }
                            }.bind(this));

                            this.emit('change');
                        }
                    }
                },

                /**
                 * Name of the segmented-button
                 * @type {String}
                 */
                name: {
                    default: ''
                }
            });

            this.on('button:keydown', function(evt) {
                _onButtonKeypress(this, evt);
            }.bind(this));
        },

        postRender: function _() {
            _.super(this);

            var elements = this.querySelectorAll('button');

            this._buttons = [];
            this.buttons = elements;
            a11y.addA11yFocus(this);
        }
    });

    return register('ha-segmented-button', HASegmentedButton);
});

/**
 * Module used to detect what type of device the page is running on.
 * Uses a combination of a check for the presence of touch capabilities
 * and media queries against device width. Only differentiates between
 * 'desktop' and non desktop.
 *
 */
/* istanbul ignore next */define('hui/core/deviceUtils',['./utils', 'ua-parser'], function(utils, uaParser) {
    if (typeof document === 'undefined') {
        // Return a dummy plugin for the build process
        return {
            normalize: function() {},
            load: function() {
                arguments[2]();
            }
        };
    }
    var deviceTypes = {
            pc: 'pc',
            tablet: 'tablet',
            mobile: 'mobile'
        },
        listeners = [],
        orientations = {
            portrait: 'portrait',
            landscape: 'landscape'
        },
        deviceUtils,
        screenParameters,
        oldScreenParameters,
        mobileListenersAdded = false,
        scrollTop = 0,
        cleanupListeners = function() {
            var i;
            for (i = listeners.length - 1; i >= 0; i--) {
                if (listeners[i].remove) {
                    listeners.splice(i, 1);
                }
            }
        },
        cleanupLater = utils.debounce(cleanupListeners, 250, false),
        onViewportChange = function() {
            oldScreenParameters = screenParameters;
            screenParameters = {};
            screenParameters.hasTouch = 'ontouchstart' in document.documentElement || 'ontouchstart' in window ||
                window.DocumentTouch && document instanceof window.DocumentTouch;

            screenParameters.orientation = window.matchMedia('(orientation: landscape)').matches ?
                orientations.landscape : orientations.portrait;

            screenParameters.width = window.screen.width;
            screenParameters.height = window.screen.height;
            var deviceInfo = deviceUtils._uaParser().device;

            screenParameters.deviceType = deviceInfo.type || 'pc';
            screenParameters.isDesktop = screenParameters.deviceType === 'pc';

            cleanupListeners();
            listeners.forEach(function(listener) {
                if (listener.listener === listener.callback) {
                    listener.callback(screenParameters, oldScreenParameters);
                } else if (typeof listener.callback === 'string') {
                    listener.listener[listener.callback](screenParameters, oldScreenParameters);
                } else {
                    listener.callback.bind(listener.listener)(screenParameters, oldScreenParameters);
                }
            });
        },
        getBodyView = function() {
            return document.body.dataset.view || '';
        },
        onTap = function(element, parent, evt) {
            if (parent && (parent.tagName === 'HA-CHECKBOX' || parent.tagName === 'HA-TEXTAREA' ||
                parent.tagName === 'HA-TEXT-FIELD' || parent.tagName === 'HA-DATE-PICKER')) {
                evt.preventDefault();

                // HUI-4246: TextFieldTA and SelectTA have children TextFields;
                // we check if the owner tag is set to ensure only focus on
                // TextField and DatePicker. TFTA and SelectTA require a click.
                if (!parent.ownerTag && (parent.tagName === 'HA-TEXT-FIELD' || parent.tagName === 'HA-DATE-PICKER' || parent.tagName === 'HA-TEXTAREA')) {
                    element.focus();
                } else {
                    element.click();
                }
            } else if (document.activeElement && document.activeElement.tagName === 'INPUT') {
                document.activeElement.blur();
            }
        };

    deviceUtils = {
        /**
         * The uaParser that determines what environment this is running in.
         * This is only exposed as a private property for testing.
         */
        _uaParser: uaParser,

        deviceTypes: deviceTypes,
        /**
         * Convenience method for programmatically checking whether the app is
         * currently running in a desktop environment
         * @returns {boolean}
         */
        isDesktop: function() {
            return screenParameters.deviceType === deviceTypes.pc;
        },
        /**
         * Convenience method for programmatically checking if the app is running on
         * a mobile device or tablet.
         * @returns {boolean}
         */
        isHandheld: function() {
            return screenParameters.deviceType === deviceTypes.mobile ||
                screenParameters.deviceType === deviceTypes.tablet || getBodyView() === 'mobile';
        },
        /**
         * Convenience method for programmatically checking if the app is running on
         * a mobile device.
         * @returns {boolean}
         */
        isMobile: function() {
            return screenParameters.deviceType === deviceTypes.mobile || getBodyView() === 'mobile';
        },
        /**
         * Convenience method for programmatically checking if the app is running on
         * a tablet.
         * @returns {boolean}
         */
        isTablet: function() {
            return screenParameters.deviceType === deviceTypes.tablet || getBodyView() === 'mobile';
        },
        /**
         * Returns the current parameters of the screen
         * @returns {Object} An object containing the deviceType, orientation, height, and width of the viewport,
         * as well as a boolean flag `isDesktop` included for convenience.
         * deviceType can take three values: 'pc', 'mobile', or 'tablet'
         * orientation will either be 'landscape' or 'portrait'
         * height and width are measured in pixels.
         */
        getScreenParameters: function() {
            return screenParameters;
        },
        /**
         * Indicates whether the device supports touch
         * @returns {boolean|*}
         */
        hasTouch: function() {
            return screenParameters.hasTouch;
        }
    };

    // Initialize parameters and then debounce so this function is not called repeatedly while the window is being
    // resized
    onViewportChange();
    onViewportChange = utils.debounce(onViewportChange, 250, false);

    /**
     * Resolves id into a module id based on possibly-nested ternary expression that branches on feature test value(s).
     * @param {string} id The id to normalize
     * @param {Function} toAbsMid Resolves a relative module id into an absolute module id
     */
    deviceUtils.normalize = function(id, toAbsMid) {
        var tokens = id.match(/[\?:]|[^:\?]*/g), i = 0,
            get = function(skip) {
                var term = tokens[i++];
                if (term === ':') {
                    // empty string module name, resolves to 0
                    return 0;
                } else {
                    // postfixed with a ? means it is a feature to branch on, the term is the name of the feature
                    if (tokens[i++] === '?') {
                        if (!skip && deviceUtils[term]()) {
                            // matched the feature, get the first value from the options
                            return get();
                        } else {
                            // did not match, get the second value, passing over the first
                            get(true);
                            return get(skip);
                        }
                    }
                    // a module
                    return term || 0;
                }
            };
        id = get();
        return id && toAbsMid(id);
    };

    /**
     * Returns OS version name from UA Parser.
     * @returns {String}
     */
    deviceUtils.getOSName = function() {
        return this._uaParser().os.name;
    };

    /**
     * Returns OS version number from UA Parser.
     * @param {boolean} shouldRound if version number should be rounded to whole number
     * @returns {Number}
     */
    deviceUtils.getOSVersion = function(shouldRound) {
        var version = parseFloat(this._uaParser().os.version);
        return shouldRound ? Math.round(version) : version;
    };

    /**
     * Convenience utility to check if app is running Android.
     * @returns {boolean}
     */
    deviceUtils.isAndroid = function() {
        return this.getOSName() === 'Android';
    };

    /**
     * HUI-4394: Detect for Android WebView based on UA string. Used in Android
     * embedded shell. See http://bit.ly/2ltZauu for more context.
     * @returns {boolean}
     */
    deviceUtils.isAndroidWebView = function() {
        if (!this.isAndroid()) {
            return false;
        }

        // TODO: extend regex to capture Chrome/ versions (WebView pre-Lollipop)
        // var isWebView = deviceUtils._uaParser().ua.match(/Chrome\/(\d+.\d)/g);

        // Android versions post Lollipop will have 'wv' in their UA string
        return this._uaParser().ua.match(/wv/g);
    };

    /**
    * Adds mobile event listeners to reduce focus delay on iOS 9 devices
    * running Safari Mobile. Delegation is handled on the body; see
    * alxgbsn.co.uk/2011/08/16/event-delegation-for-touch-events-in-javascript/
    * Some test cases include:
    *
    * 1) Immediate focus / click on the input element (text-field, checkbox, button, etc)
    * 2) Blurring from input upon clicking off the element
    * 2) Not blurring from the focused element during scroll
    * 4) Not focusing on an unintended element during scroll
    *
    * Components that have been tested and benchmarked include:
    *
    * A) HATextField
    * B) HATextArea
    * C) HASelectTypeahead
    * D) HACheckbox
    *
    */
    deviceUtils.addiOS9ImmediateFocus = function() {

        // Don't add these listeners unless they're needed;
        if (mobileListenersAdded) {
            return;
        } else {
            mobileListenersAdded = true;
        }

        // Short circuit if greater than or equal to iOS 9.3
        if (deviceUtils.getOSVersion(false) >= 9.3 || deviceUtils.getOSName() !== 'iOS') {
            return;
        }

        // Initialze local state
        var delegatedTapArea = document.body,
            fingerHasMoved = false,
            startX = 0,
            startY = 0;

        // On finger contact, cache starting coordinates
        delegatedTapArea.addEventListener('touchstart', function(evt) {
            fingerHasMoved = false;
            startX = evt.touches[0].clientX;
            startY = evt.touches[0].clientY;
        });

        // Detect finger moving to guard against accidental focus on scroll
        delegatedTapArea.addEventListener('touchmove', function(evt) {

            // If finger moves more than 10px, cancel the tap simulation
            if (Math.abs(evt.touches[0].clientX - startX) > 10 ||
                Math.abs(evt.touches[0].clientY - startY) > 10) {
                fingerHasMoved = true;
            }
        });

        // When finished moving; cancel default event and find the target
        delegatedTapArea.addEventListener('touchend', function(evt) {

            // Tap simulation: only focus on elements if user hasn't been scrolling
            // Capture various element types
            if (!fingerHasMoved) {
                // Get target element; if a textNode (nodeType at 3) we need parent
                var element = evt.changedTouches[0].target;
                if (element.nodeType === 3) {
                    element = element.parentNode;
                }
                var parent = element.parentElement;

                onTap(element, parent, evt);
            }
        });

        // Reset local state when finger is removed
        delegatedTapArea.addEventListener('touchcancel', function() {
            fingerHasMoved = false;
            startX = 0;
            startY = 0;
        });
    };

    /**
     * A function for getting current orientation state.
     */
    deviceUtils.getOrientation = function() {
        return window.matchMedia('(orientation: landscape)').matches ? 'landscape' : 'portrait';
    };

    /**
     * A function for determining iPhone or not.
     */
    deviceUtils.isIOSDevice = function() {
        return deviceUtils.isHandheld() && deviceUtils.getOSName() === 'iOS';
    };

    /**
     * A function for determining iPhone 6+ or iPhone 7+.
     */
    deviceUtils.isIPhonePlus = function() {
        return deviceUtils.isIOSDevice() && window.matchMedia('(-webkit-min-device-pixel-ratio: 3)').matches;
    };

    /**
     * A function for determining iPhone 6+ or iPhone 7+ browser shows a tab bar or not.
     */
    deviceUtils.isIPhonePlusWithTabBar = function() {
        return deviceUtils.isIPhonePlus() && window.innerHeight < 370;
    };

    /**
     * A function for toggle touchmove event on mobile devices.
     * @param {HTMLElement} component The web component need to be handled.
     * @param {boolean}     disable to determine the component should disable touchmove or not.
     */
    deviceUtils.stopTouchMove = function(component, disable) {
        if (disable) {
            component.addEventListener('touchmove', utils.stopEvent);
        } else {
            component.removeEventListener('touchmove', utils.stopEvent, false);
        }
    };

    /**
     * A function for locking HTML body and save the Y offset position.
     */
    deviceUtils.bodyLock = function() {
        scrollTop = window.pageYOffset;
        document.body.classList.add('body-lock');
        deviceUtils.stopTouchMove(document.body, true);
    };

    /**
     * A function for unlocking HTML body and restore the Y offset position.
     */
    deviceUtils.bodyUnlock = function() {
        if (scrollTop) {
            window.scrollTo(0, scrollTop);
        }
        scrollTop = 0;
        document.body.classList.remove('body-lock');
        deviceUtils.stopTouchMove(document.body, false);
    };

    /**
    * Conditional loading of AMD modules based on a feature test value.
    * @param {string} id Gives the resolved module id to load.
    * @param {Function} parentRequire The loader require function with respect to the module that contained the plugin
    * resource in its dependency list.
    * @param {Function} loaded Callback to loader that consumes result of plugin demand.
    */
    deviceUtils.load = /* istanbul ignore next */ function(id, parentRequire, loaded) {
        if (id) {
            parentRequire([id], loaded);
        } else {
            loaded();
        }
    };

    // add a 'desktop' or 'handheld' class to the body so that mobile/desktop
    // specific CSS selectors can be utilized. This will get added only once when
    // this module is loaded into the page
    document.body.classList.add(deviceUtils.isDesktop() ? 'desktop' : 'handheld');
    // Add more specific 'mobile' or 'tablet' classes for any style changes between these
    // environments
    if (deviceUtils.isHandheld()) {
        if (deviceUtils.getScreenParameters().deviceType === deviceTypes.mobile) {
            document.body.classList.add('mobile');
        } else {
            document.body.classList.add('tablet');
        }
    }

    /**
     * This function can be used to register a callback that will be fired when the orientation or size
     * of the viewport changes. Returns a handle that can be used to remove the registered callback.
     * @param {Function | string} callback The function that is called when the page is resized or the orientation
     * changes, or the name of the function to be called on listener. Will be passed the new screen parameters and the
     * old screen parameters, and will be executed in the context of the listener if provided.
     * @param {Object} listener - An optional object that will be used as the context for the callback. If callback is a
     * string, then a listener must be provided.
     * @returns {remove: Function} A handle that can be used to unregister the callback
     */
    deviceUtils.registerCallback = function(callback, listener) {
        if (!listener) {
            listener = callback;
        }

        listeners.push({
            listener: listener,
            callback: callback
        });
        return {
            remove: function() {
                var i;
                for (i = listeners.length - 1; i >= 0; i--) {
                    if (listeners[i].listener === listener) {
                        // This could be called from within a callback, so just flag it
                        // and it will be removed the next time onViewportChange fires.
                        listeners[i].remove = true;
                        cleanupLater();
                    }
                }
            }
        };
    };

    window.addEventListener('orientationChange', onViewportChange);
    window.addEventListener('resize', onViewportChange);
    return deviceUtils;
});

define('hui/radio-button',[
    'register-component/v2/register',
    'register-component/v2/UIComponent',
    './core/deviceUtils',
    'object-utils/classes'
], function(register, UIComponent, deviceUtils, classes) {
    'use strict';

    var HARadioButton = classes.createObject(UIComponent, {

        init: function _() {

            _.super(this);

            this.setupProperties({
                /**
                 * label for the radio control
                 * @type {String}
                 */
                label: {
                    default: '',
                    change: function(newValue) {
                        var label = this._nodes.label;

                        label.textContent = newValue;
                        if (!newValue) {
                            this.removeAttribute('label');
                        }
                    }
                },

                /**
                 * this sets the value for the radio input
                 * @type {String}
                 */
                value: {
                    default: '',
                    change: function(newValue) {
                        this._nodes.input.value = newValue;
                    }
                },

                /**
                 * disabled indicates wheter the component is enabled or disabled
                 * @type {Boolean}
                 */
                disabled: {
                    default: false,
                    type: Boolean,
                    change: function(newValue) {
                        this._nodes.input.disabled = newValue;
                    }
                },

                /**
                 * checked indicates if the radio is checked
                 * @emits HARadioButton#change
                 * @type {Boolean}
                 */
                checked: {
                    default: false,
                    type: Boolean,
                    change: function(newValue) {
                        if (this._nodes.input.checked !== newValue) {
                            this._nodes.input.checked = newValue;
                        }
                    }
                },

                /**
                 * This is the name for the radio button group this element belongs to.
                 * @type {String}
                 */
                name: {
                    default: '',
                    change: function(newValue) {
                        this._nodes.input.name = newValue;
                    }
                }
            });
        },

        /**
         * @emits HARadioButton#click
         */
        postRender: function _() {
            _.super(this);

            this._nodes = {};

            var input = this.querySelector('input'),
                label = this.querySelector('label');

            if (deviceUtils.isHandheld()) {
                this.classList.add('mobile-radio');
            }

            if (!input) {
                input = this.ownerDocument.createElement('input');
                input.type = 'radio';
                this.appendChild(input);
            }
            input.id = 'ha-radio-button-' + this.componentId;
            this._nodes.input = input;

            if (!label) {
                label = this.ownerDocument.createElement('label');
                this.appendChild(label);
            }
            label.htmlFor = this._nodes.input.id;
            this._nodes.label = label;

            //Change listener from "change" to "click" event: regardless events registration sequence, Firefox will trigger click event first
            //and then change event, which would cause an issue in qbo data binding. Change to "click" event would resolve the issue.
            this.listenTo(input, 'click', function(evt) {
                evt.stopPropagation();
                this.checked = evt.target.checked;
                this._nodes.input.focus();
                this.emit('click');
            }.bind(this));

            this.listenTo(input, 'change', function(evt) {
                evt.stopPropagation();
                this.emit('change');
            }.bind(this));

            // Clicking label should prevent click event bubbling up but since label and input are connected
            // by for/id attribute, browser will naturally fire click event of input, code above emits the
            // unified component click event
            this.listenTo(label, 'click', function(evt) {
                evt.stopPropagation();
            });
        }
    });

    return register('ha-radio-button', HARadioButton);
});

define('hui/validatable/base-validator',[
    'object-utils/classes',
    'register-component/v2/UIComponent'
], function(classes, UIComponent) {
    'use strict';

    var BaseValidator = classes.createObject(UIComponent, {
        /**
         * Override this in each validator to define a default message
         */
        init: function(validationType, options) {
            this.options = options;
            // needed so later we can query them if invalidMessage or requiredMessage is updated
            this.validationType = validationType;
            this.element = options.element;
            this.onInit();
        },

        test: function() {
            return false;
        },

        onInit: function() {

        },

        getValue: function() {
            return this.element.value;
        },

        matchToValue: function(regex) {
            var re = new RegExp(regex);
            return re.test(this.getValue());
        }
    });

    return BaseValidator;
});


define('hui/validatable/validators/required',[
    '../base-validator',
    'object-utils/classes'
], function(BaseValidator, classes) {
    'use strict';
    var RequiredValidator = classes.createObject(BaseValidator, {
        test: function() {
            var value = this.getValue();
            if (Array.isArray(value)) {
                return value.length > 0;
            } else {
                return !!value;
            }
        }
    });
    return RequiredValidator;
});

define('hui/validatable/validators/numeric',[
    '../base-validator',
    'object-utils/classes'
], function(BaseValidator, classes) {
    'use strict';

    var NumericValidator = classes.createObject(BaseValidator, {
        test: function() {
            return this.matchToValue('^[0-9]+$');
        }
    });

    return NumericValidator;
});
define('hui/validatable/validators/pattern',[
    '../base-validator',
    'object-utils/classes'
], function(BaseValidator, classes) {
    'use strict';

    var PatternValidator = classes.createObject(BaseValidator, {
        test: function() {
            return this.matchToValue(this.options.pattern);
        }
    });

    return PatternValidator;
});
define('hui/validatable/validators/function',[
    '../base-validator',
    'object-utils/classes'
], function(BaseValidator, classes) {
    'use strict';

    var FunctionValidator = classes.createObject(BaseValidator, {
        test: function(component) {
            return this.options.validatorFunc(component);
        }
    });

    return FunctionValidator;
});

define('hui/validatable/validators/min',[
    '../base-validator',
    'object-utils/classes'
], function(BaseValidator, classes) {
    'use strict';

    var MinValidator = classes.createObject(BaseValidator, {
        test: function() {
            return parseFloat(this.getValue()) >= this.options.minVal;
        }
    });

    return MinValidator;
});
define('hui/validatable/validators/max',[
    '../base-validator',
    'object-utils/classes'
], function(BaseValidator, classes) {
    'use strict';

    var MaxValidator = classes.createObject(BaseValidator, {
        test: function() {
            return parseFloat(this.getValue()) <= this.options.maxVal;
        }
    });

    return MaxValidator;
});
define('hui/validatable/validators/minDate',[
    '../base-validator',
    'object-utils/classes'
], function(BaseValidator, classes) {
    'use strict';

    var Validator = classes.createObject(BaseValidator, {
        test: function() {
            return new Date(this.getValue()) >= new Date(this.options.minDate);
        }
    });

    return Validator;
});

define('hui/validatable/validators/maxDate',[
    '../base-validator',
    'object-utils/classes'
], function(BaseValidator, classes) {
    'use strict';

    var Validator = classes.createObject(BaseValidator, {
        test: function() {
            var maxDate = new Date(this.options.maxDate);
            return new Date(this.getValue()) < new Date(maxDate.getFullYear(), maxDate.getMonth(), maxDate.getDate() + 1);
        }
    });

    return Validator;
});

define('hui/validatable/validators/expected',[
    '../base-validator',
    'object-utils/classes'
], function(BaseValidator, classes) {
    'use strict';

    var expectedValueValidator = classes.createObject(BaseValidator, {
        test: function() {
            return this.getValue() === this.options.expectedValue;
        }
    });

    return expectedValueValidator;
});
define('hui/validatable/validators/min-required',[
    '../base-validator',
    'object-utils/classes'
], function(BaseValidator, classes) {
    'use strict';

    var minRequiredValidator = classes.createObject(BaseValidator, {
        test: function() {
            return this.element.value.length >= this.options.minRequired;
        }
    });

    return minRequiredValidator;
});
define('hui/validatable/validators/minlength',[
    '../base-validator',
    'object-utils/classes'
], function(BaseValidator, classes) {
    'use strict';

    var MinLengthValidator = classes.createObject(BaseValidator, {
        test: function() {
            return this.getValue().length >= this.options.minLength;
        }
    });

    return MinLengthValidator;
});


define('hui/validatable/validators',[
    // REGISTER VALIDATORS HERE
    './validators/required',
    './validators/numeric',
    './validators/pattern',
    './validators/function',
    './validators/min',
    './validators/max',
    './validators/minDate',
    './validators/maxDate',
    './validators/expected',
    './validators/min-required',
    './validators/minlength'
], function(RequiredValidator, NumericValidator, PatternValidator, FunctionValidator, MinValidator, MaxValidator,
    MinDateValidator, MaxDateValidator, ExpectedValidator, MinRequiredValidator, MinLengthValidator) {
    'use strict';

    var registeredValidators = {
        'required': RequiredValidator,
        'numeric': NumericValidator,
        'pattern': PatternValidator,
        'validator': FunctionValidator,
        'min': MinValidator,
        'max': MaxValidator,
        'minDate': MinDateValidator,
        'maxDate': MaxDateValidator,
        'expected': ExpectedValidator,
        'minRequired': MinRequiredValidator,
        'minLength': MinLengthValidator
    };

    return {
        create: function(validationType, options) {
            var validator = registeredValidators[validationType];
            validator.init(validationType, options);

            return validator;
        }
    };
});

define('hui/core/ellipsis',[],function() {
    'use strict';

    /**
     * Returns true if the node exists in the page
     * @param {Element} node
     * @return {Boolean}
     */
    function isInPage(node) {
        return Boolean(node.offsetWidth || node.offsetHeight || node.getClientRects().length);
    }

    /**
     * setInterval, but using requestAnimationFrame
     * @param {Function} fn
     * @param {Number} delay
     * @return {Object}
     */
    function requestInterval(fn, delay) {
        var start = new Date().getTime(),
            anim;

        function loop() {
            anim = requestAnimationFrame(loop);
            var current = new Date().getTime(),
                delta = current - start;

            if (delta >= delay) {
                fn.call();
                start = new Date().getTime();
            }
        }

        anim = requestAnimationFrame(loop);
        return {
            cancel: function() {
                return cancelAnimationFrame(anim);
            }
        };
    }

    /**
     * Provides the number of lines of text that exist in an element
     * @param {Element} el
     * @return {Number}
     */
    function getLines(el) {
        var style = window.getComputedStyle(el),
            display = style.display,
            height,
            lineHeight;

        if (display === 'inline') {
            return el.getClientRects().length;
        }

        height = +style.height.slice(0, -2);
        // as specified here, if line height is "normal" we multiply by roughly 1.2
        // https://developer.mozilla.org/en-US/docs/Web/CSS/line-height#Values
        lineHeight = +style.lineHeight.slice(0, -2) || (1.2 * +style.fontSize.slice(0, -2));

        return Math.round(height / lineHeight);
    }

    /**
     * Check if element is larger than maximum height specified
     * @param {Element} element
     * @param {Object} options
     * @return {Boolean} true if element is taller than maxHeight
     */
    function test(element, options) {
        return getLines(element) > options.lines;
    }

    /**
     * Adds ellipsis to text
     * @param {String} txt
     * @param {Object} options
     * @return {String} modified text including ellipsis
     */
    function addEllipsis(txt, options) {
        while (options.lastCharacter.indexOf(txt.slice(-1)) > -1) {
            txt = txt.slice(0, -1);
        }

        txt += options.ellipsis;

        return txt;
    }

    /**
     * Places ellipsis on specified elements
     * @param {Element} element
     * @param {Element} originalElement
     * @param {Object} options
     * @return {Boolean} true
     */
    function placeEllipsis(element, originalElement, options) {
        var txt = element.nodeValue,
            separator = (txt.indexOf(' ') !== -1) ? ' ' : '\u3000',
            textArr = txt.split(separator),
            position = -1,
            midPos = -1,
            startPos = 0,
            endPos = textArr.length - 1,
            m;

        // Only one word
        if (options.fallbackToLetter && startPos === 0 && endPos === 0) {
            separator = '';
            textArr = txt.split(separator);
            endPos = textArr.length - 1;
        }

        while (startPos <= endPos && !(startPos === 0 && endPos === 0)) {
            m = Math.floor((startPos + endPos) / 2);

            if (m === midPos) {
                break;
            }

            midPos = m;

            element.nodeValue = textArr.slice(0, midPos + 1).join(separator) + options.ellipsis;

            Array.prototype.forEach.call(originalElement.childNodes, function(originalElementChild) {
                if (originalElementChild.nodeType === 3) {
                    return;
                }

                var originalDisplay = originalElementChild.style.display;
                originalElementChild.style.display = 'none';
                originalElementChild.style.display = originalDisplay;
            });

            if (!test(originalElement, options)) {
                position = midPos;
                startPos = midPos;
            } else {
                endPos = midPos;
            }
        }

        if (position !== -1 && !(textArr.length === 1 && textArr[0].length === 0)) {
            txt = addEllipsis(textArr.slice(0, position + 1).join(separator), options);
            element.nodeValue = txt;
        }

        return true;
    }

    /**
     * Determines after which elements to place ellipsis
     * @param {Element} element
     * @param {Mixed} originalElement
     * @param {Object} options
     * @return {Boolean} true if the element is to be truncated
     */
    function ellipsisElement(element, originalElement, options) {
        var isTruncated = false,
            elementChildren = Array.prototype.slice.call(element.cloneNode(true).childNodes);

        if (!originalElement) {
            originalElement = element;
        }

        element.innerHTML = '';

        elementChildren.forEach(function(childNode) {
            if (childNode.tagName && childNode.tagName.toLowerCase() === 'script') {
                element.appendChild(childNode);
            } else if (isTruncated) {
                return true;
            } else {
                element.appendChild(childNode);

                if (test(originalElement, options)) {
                    if (childNode.nodeType === 3) { // node is TEXT
                        isTruncated = placeEllipsis(childNode, originalElement, options);
                    } else {
                        isTruncated = ellipsisElement(childNode, originalElement, options);
                    }
                }
            }
        });

        return isTruncated;
    }

    /**
     * Extends an object
     * @param {Object} source
     * @param {Object} target
     * @return {Object}
     */
    function extend(source, target) {
        var prop;

        for (prop in source) {
            if (target.hasOwnProperty(prop)) {
                target[prop] = source[prop];
            }
        }

        return target;
    }

    /**
     * Coordinates the element truncation
     * @param {Element} element the element to be truncated
     * @param {Object} options
     */
    function ellipsis(element, options) {
        var multiple = [];

        // we need both element and options
        if (!element || element.length === 0 || !options || options.length === 0) {
            return false;
        }

        if (element.length > 1) {
            Array.prototype.forEach.call(element, function(elem, index) {
                multiple[index] = ellipsis(elem, options);
            });

            return multiple;
        }

        var originalContent = Array.prototype.slice.call(element.childNodes),
            trunc = false,
            interval,
            opts = extend(options, {
                ellipsis: '... ',
                fallbackToLetter: true,
                lastCharacter: [' ', '\u3000', ',', ';', '!', '?'],
                lines: 0,
                inPageOffset: 100
            }),
            state = {
                revert: function() {
                    element.innerHTML = '';

                    if (interval) {
                        interval.cancel();
                        interval = null;
                    }

                    originalContent.forEach(function(content) {
                        try {
                            element.appendChild(content);
                        } catch (e) {
                            element.appendChild(document.createTextNode(''));
                        }
                    });

                    element.setAttribute('style', element.getAttribute('ha-ellipsis-style') || '');
                    element.removeAttribute('ha-ellipsis');
                },
                originalContent: originalContent,
                isTruncated: false
            };

        function runEllipsis() {
            element.setAttribute('ha-ellipsis', true);
            element.setAttribute('ha-ellipsis-style', element.getAttribute('style') || '');

            element.style.wordWrap = 'break-word';
            element.style.whiteSpace = 'normal';

            if (test(element, opts)) {
                trunc = ellipsisElement(element, null, opts);
            }

            state.isTruncated = trunc;
        }

        if (element.hasAttribute('ha-ellipsis')) {
            state.revert();
        }

        // for the lines calculation to work properly, the element
        // needs to exist in the page. First, do a check to see if it
        // exists. If yes, perform ellipsis on it. If not,
        // check again at an interval
        if (isInPage(element)) {
            runEllipsis();
        } else {
            interval = requestInterval(function() {
                if (!isInPage(element)) {
                    return;
                }
                if (interval) {
                    interval.cancel();
                    interval = null;
                }
                runEllipsis();
            }, opts.inPageOffset);
        }

        return state;
    }

    ellipsis.getLines = getLines;

    return ellipsis;
});

define('hui/tooltip',[
    'object-utils/classes',
    'register-component/v2/UIComponent',
    'register-component/v2/register',
    './core/popup',
    './core/tooltip',
    './core/utils',
    './core/a11y',
    './core/deviceUtils',
    './core/ellipsis'
],
function(classes, UIComponent, register, popup, coreTooltip, utils, a11y, deviceUtils, ellipsis) {
    'use strict';
    var HaTooltip,
        /**
         * Static var to track the current target of the tooltip.
         * @type {HTMLElement}
         */
        TARGET = null;

    /**
     * Emits dismiss and hides the component
     * @param  {Event} evt Click event
     * @emits dismiss
     */
    function dismissibleTooltipClick(evt) {
        var component = evt.target;
        while (component.tagName !== 'HA-TOOLTIP') {
            component = component.parentElement;
        }
        component.emit('dismiss');
        component.close();
    }

    /**
     * Sets a delay to hide the popup
     */
    function hideAfterTimeout(evt) {
        var tooltip = evt.target;
        setTimeout(tooltip._hideCallback, tooltip.duration);
    }

    /**
     * Sets message on tooltip
     * @param {HTMLElement} tooltip Component to set the message to
     * @param {HTMLElement} target  Component that can have another message
     */
    function setMessage(tooltip, target) {
        var tooltipMessage = false,
            childrenLength,
            i,
            msg,
            content = tooltip.querySelector('.tooltip-inner');

        //Tooltip message can also be defined as an attribute of the target. If the target
        //defines a "tooltipMessage" attribute, we take that as the message for the tooltip
        if (target) {
            tooltipMessage = target.tooltipMessage || target.getAttribute('tooltipMessage');
        }

        //if target does not define a message, we take the one defined in the tooltip itself
        msg = tooltipMessage ? tooltipMessage : tooltip.message;
        if (msg) {
            if ('string' === typeof msg) {
                msg = [tooltip.ownerDocument.createTextNode(msg)];
            } else
            if (msg instanceof HTMLElement) {
                msg = [msg];
            }

            childrenLength = content.childNodes.length;

            for (i = 0; i < childrenLength; i++) {
                content.removeChild(content.childNodes[0]);
            }

            content.innerHTML = '';
            utils.appendChildCollection(content, msg);
        }

        if (deviceUtils.isHandheld() && deviceUtils.getScreenParameters().deviceType === deviceUtils.deviceTypes.mobile) {
            var textNode = tooltip.ownerDocument.createTextNode(content.textContent);
            content.innerHTML = '';
            content.appendChild(textNode);
        }
    }

    function getTrueTarget(tooltip, target) {
        /**
         * aria-describedby needs to go on the actual input, not the component, so do we what we can to
         * find the appropriate element. if it can't find one, it'll look for an `_inputElement` property. If that
         * doesn't exist, use the passed in target
         */
        var betterTargetSelectors = [
                'input', 'select', 'textarea'
            ],
            betterTarget = target.querySelector(betterTargetSelectors.join(','));

        if (betterTarget) {
            return betterTarget;
        }

        return target;
    }

    function handleAccessibility(tooltip, target) {

        if (!tooltip.id) {
            tooltip.id = 'ha-tooltip-' + tooltip.componentId;
        }

        var trueTarget = getTrueTarget(tooltip, target);

        if (trueTarget !== target) {
            trueTarget.setAttribute('aria-describedby', tooltip.id);
        } else if (target._inputElement) {
            target._inputElement.setAttribute('aria-describedby', tooltip.id);
        } else {
            target.setAttribute('aria-describedby', tooltip.id);
        }
    }

    HaTooltip = classes.createObject(UIComponent, {

        init: function _() {
            _.super(this);

            /**
             * Cached listeners of the defined event to show or hide the tooltip
             */
            this._listenersTargets = [];

            /**
             * Message that will be shown.
             * @type {String|HTMLElement}
             */
            this._message = '';

            // I need to store this callbacks in case the consumer changes the triggers
            this._hideCallback = this.close.bind(this);
            this._showCallback = this.show.bind(this);

            /**
             * Flag so that this component will not reset listeners when it's attached to the body
             * @type {Boolean}
             */
            this._attached = false;

            /**
             * This is for screen readers to announce the presence of a tooltip
             */
            this.setAttribute('role', 'tooltip');

            this.setupProperties({

                /**
                 * String describing the alignment of the tooltip.
                 * More than one alignment can be added and will be used as order of preference*
                 * Values can be:
                 *  - left
                 *  - right
                 * @default 'left'
                 * @type {String}
                 * @private
                 */
                _alignment: {
                    default: 'left'
                },

                /**
                 * Selector describing which is / are the parents of the tooltip.
                 * @type {String}
                 */
                targetSelector: {
                    default: '_previousSibling',
                    change: function(newValue) {
                        coreTooltip.removeOldListeners(this);
                        coreTooltip.setTooltipTargets(this, newValue);
                        coreTooltip.resetListeners(this, this.trigger);
                    }
                },

                /**
                 * String describing the position of the tooltip.
                 * More than one position can be added and will be used as order of preference
                 * Values can be:
                 *  - top
                 *  - bottom
                 * @default 'top bottom'
                 * @type {String}
                 */
                position: {
                    default: 'top bottom'
                },

                /**
                 * If the tooltip is dismissible by the user.
                 * A close button will be shown if this is true.
                 * @type {Boolean}
                 */
                dismissible: {
                    type: Boolean,
                    default: false,
                    change: function(newValue) {
                        if (newValue) {
                            this.classList.add('dismissible');
                            this.on('button:click', dismissibleTooltipClick);
                        } else {
                            this.classList.remove('dismissible');
                            this.off('button:click', dismissibleTooltipClick);
                        }
                        coreTooltip.resetTooltipDismissal(this);
                    }
                },

                /**
                 * Event that will be attached to the parent / parents that will trigger
                 * the show of the tooltip.
                 * @type {String}
                 */
                trigger: {
                    default: 'hover',
                    change: function(newValue) {
                        coreTooltip.resetListeners(this, newValue);
                    }
                },

                /**
                 * Sets the timeout (ms) to close the tooltip.
                 * A zero value means disabled.
                 * @type {Number}
                 */
                duration: {
                    default: 0,
                    change: function(newValue) {
                        if (newValue > 0) {
                            this.on('show', hideAfterTimeout);
                        } else {
                            this.off('show', hideAfterTimeout);
                        }
                        coreTooltip.resetTooltipDismissal(this);
                    }
                }
            });
        },

        /**
         * Bind the click event to the close button.
         * @emits HATooltip#show
         * @emits HATooltip#close
         */
        createdCallback: function _() {
            var animationEvts;
            _.super(this);

            animationEvts = utils.getAnimationEventNames();
            this.on(animationEvts.animationend, function(evt) {
                var target = evt.target;
                switch (evt.animationName) {
                    case 'ha-fade-in':
                        target.classList.remove('enter');
                        target.emit('show');
                        break;
                    case 'ha-fade-out':
                        target.classList.remove('leave');
                        target.classList.remove('visible');
                        target.emit('close');
                        popup.clearPosition(target);
                        break;
                }
            });
        },

        /**
         * Sets tooltip initial configs and resets event listeners.
         */
        attachedCallback: function() {
            if (!this._attached) {
                this._attached = true;
                coreTooltip.setTooltipTargets(this, this.targetSelector);
                coreTooltip.resetListeners(this, this.trigger);
                setMessage(this, this._listenersTargets[0]);
            }
        },

        /**
         * Retrieves the targets.
         * Binds some event on them.
         * Makes a verification on the position config.
         */
        postRender: function _() {
            var divContainer,
                divText,
                message,
                innerContent,
                button;

            _.super(this);
            a11y.addA11yFocus(this);

            if (this.hasAttribute('message')) {
                message = this.getAttribute('message');
            } else {
                innerContent = this.querySelector('.tooltip-inner');
                if (innerContent) {
                    message = utils.removeNodesSafe(innerContent, innerContent.childNodes);
                } else {
                    message = utils.removeNodesSafe(this, this.childNodes);
                }
            }

            divContainer = this.querySelector('div.tooltip-container');
            divText = this.querySelector('div.tooltip-inner');
            button = this.querySelector('button.btn-container');
            // We force a minWidth to avoid popup default behaviour of setting minWidth to
            // target's width (required by every other component)
            this.style.minWidth = '1px';

            // Creates template
            if (!divContainer) {
                divContainer = this.ownerDocument.createElement('div');
                divContainer.className = 'tooltip-container';

                button = this.ownerDocument.createElement('button');
                button.className = 'hi hi-close btn-icon-only';
                button.setAttribute('aria-label', 'Close');
                divContainer.appendChild(button);

                divText = this.ownerDocument.createElement('div');
                divText.className = 'tooltip-inner';
                divContainer.appendChild(divText);

                this.appendChild(divContainer);
            }
            this.message = message;
        },

        get message() {
            return this._message;
        },

        set message(newMessage) {
            this._message = newMessage;

            setMessage(this);
        },

        /**
         * Implements the logic to show the tooltip.
         * @param  {Event} evt Optional. When defined an event triggered this call
         */
        show: function(evt) {
            var MARGIN = 17,
                isVisible = this.classList.contains('visible'),
                target = (evt) ? evt.currentTarget : null,
                tooltips = [],
                tooltip,
                hasPositionSet,
                positionTarget,
                position,
                alignment,
                i, customPositions = {};

            if (!target) {
                target = this._listenersTargets[0];
            }

            // If it is visible but target is different is because
            // we are using the same instance in different targets,
            // so we want to move the tooltip to the next target.
            if (target) {
                handleAccessibility(this, target);

                positionTarget = getTrueTarget(this, target);
                setMessage(this, target);
                if (!TARGET || target !== TARGET) {
                    TARGET = target;
                    tooltips = this.ownerDocument.querySelectorAll('ha-tooltip.visible');
                    for (i = 0; i < tooltips.length; i++) {
                        tooltip = tooltips[i];
                        tooltip.close();
                    }
                }

                if (deviceUtils.isHandheld()) {
                    alignment = ['left'];

                    if (deviceUtils.getScreenParameters().deviceType === deviceUtils.deviceTypes.tablet) {
                        position = ['bottom', 'top'];
                    } else {
                        position = ['top', 'bottom'];
                    }
                } else {
                    position = this.position.split(' ');
                    alignment = this._alignment.split(' ');
                }

                // If the same instance is fading out, we need to interrupt the animation and fade in. Position needs to be
                // calculated again if that's the case
                if (isVisible && this.classList.contains('leave')) {
                    this.classList.remove('leave');
                    popup.clearPosition(this);
                }

                if (deviceUtils.isHandheld() && deviceUtils.getScreenParameters().deviceType === deviceUtils.deviceTypes.mobile) {
                    this.ellipsed = ellipsis(this.querySelector('.tooltip-inner'), {lines: 5});
                }

                // If position was already set (because this was called through popup) we don't need to calculate it again
                hasPositionSet = this.className.indexOf('position-') > -1;
                if (!hasPositionSet) {
                    if (popup.setPosition(this, positionTarget, position, alignment, MARGIN, customPositions)) {
                        this._resizeMethod = popup.installResizeMethod(this, positionTarget, position, alignment, MARGIN, customPositions);
                    } else {
                        return;
                    }
                }
                if (!isVisible) {
                    this.classList.add('visible');
                    this.classList.remove('closed');
                }
            }
        },

        /**
         * @deprecated use 'close' method instead
         * Hides the tooltip
         */
        hide: function() {
            this.close();
            console.warn('DEPRECATION WARNING: This method is deprecated, use "close" method instead');
        },

        /**
         * Implements the logic to hide the tooltip.
         */
        close: function() {
            // If we close a tooltip that is timed we
            // will have to ensure that the timeout stops.
            if (this._timed) {
                clearTimeout(this._timed);
                delete this._timed;
            }

            if (this.classList.contains('visible')) {
                this.classList.add('leave');
                this.classList.add('closed');
                // We need to clean this on close to ensure that
                // all behaves as expected on a new show.
                TARGET = null;
                if (this._resizeMethod) {
                    popup.uninstallResizeMethod(this._resizeMethod);
                    this._resizeMethod = null;
                }
            }
        }
    });

    return register('ha-tooltip', HaTooltip);
});

define('hui/validatable/validatable',[
    'object-utils/classes',
    'register-component/v2/UIComponent',
    './validators',
    '../core/popup',
    '../core/deviceUtils',
    '../tooltip'
], function(classes, UIComponent, validators, popup, deviceUtils) {
    'use strict';

    /**
     * Runs all the validations within _validators array.
     *
     * @param  {Array} validatorArray List of validations
     * @return {Object} object.isValid {Boolean}
     *                  object.message {String}
     */
    function _validate(validatorArray) {
        var result = {};
        // iterate all registered validators
        validatorArray.every(function(validator) {
            // run validator
            result = {
                isValid: validator.test(validator.element),  // pass the component as an arg
                message: validator.options.errorMessage,
                type: validator.validationType
            };
            // halt on first error
            return result.isValid;
        });
        // return result from last validator
        return result;
    }

    /**
     * Creates the validators indicated in the component properties.
     * @param  {HTMLElement} component Component to set the validators
     */
    function _createValidators(component) {
        var elemToValidate = component.validationTarget,
            validatorProperty,
            validatorObject,
            validator,
            currentValidator,
            validatorsMap = {
                required: {
                    errorMessage: component.requiredMessage
                },
                pattern: {
                    pattern: component.pattern
                },
                validator: {
                    validatorFunc: component.validator
                },
                min: {
                    minVal: component.min
                },
                max: {
                    maxVal: component.max
                },
                minDate: {
                    minDate: component.minDate
                },
                maxDate: {
                    maxDate: component.maxDate
                },
                numeric: {
                    numeric: component.numeric
                },
                expected: {
                    expectedValue: component.expected
                },
                minRequired: {
                    minRequired: component.minRequired
                },
                minLength: {
                    minLength: component.minLength
                }
            };

        component._validators = [];
        for (validator in validatorsMap) {
            validatorObject = {
                element: elemToValidate,
                errorMessage: component.invalidMessage
            };
            currentValidator = validatorsMap[validator];
            if (component[validator]) {
                for (validatorProperty in currentValidator) {
                    validatorObject[validatorProperty] = currentValidator[validatorProperty];
                }
                component._validators.push(validators.create(validator, validatorObject));
            }
        }
    }

    /**
     * Shows/hides tooltip visibility based on show value
     * @param   {HTMLElement}   component   Component to check state
     * @param   {Boolean}       show        Whether the tooltips should be showed or hided
     */
    function _updateTooltip(component, show) {
        if (show) {
            _showValidationMessage(component);
        } else {
            if (component.tooltip) {
                if (deviceUtils.isDesktop()) {
                    component.tooltip.close();
                } else if (component.tooltip.parentElement) {
                    component.tooltip.parentElement.removeChild(component.tooltip);
                    component.tooltip = null;
                }
            }
        }
    }

    /**
     * Updates the field with or without error state depending
     * on the content validity.
     * @param   {HTMLElement}   component   Component to check state
     * @param   {Boolean}       valid       Whether or not the component has a valid state
     */
    function _updateFieldState(component, valid) {
        var iconEl = component.querySelector('.hi-circle-alert'),
            title = component.querySelector('legend') || component.querySelector('label'),
            highlightElements = component.querySelectorAll(component.highlightElementSelector),
            titleParent;

        if (valid) {
            component.classList.remove('input-error');
            if (iconEl) {
                iconEl.classList.add('hide');
            }
        } else {
            component.classList.add('input-error');
            if (iconEl) {
                iconEl.classList.remove('hide');
            } else {
                if (title) {
                    titleParent = title.parentElement;
                    iconEl = document.createElement('span');
                    iconEl.className = 'hi hi-circle-alert';
                    iconEl.setAttribute('aria-hidden', true);
                    titleParent.insertBefore(iconEl, title);
                }
            }
        }

        Array.prototype.forEach.call(highlightElements, function(element) {
            if (valid) {
                element.removeAttribute('aria-invalid');
                element.removeAttribute('aria-describedby');
            } else {
                element.setAttribute('aria-invalid', true);
            }
        });

    }

    /**
     * Displays the tooltip with the error message.
     * @param {HTMLElement} component Component which contains the validation
     */
    function _showValidationMessage(component) {
        var idForAriaAttr,
            title = component.querySelector('legend') || component.querySelector('label'),
            positions = ['top', 'bottom'],
            alignments = ['left', 'right'],
            titleElement,
            elemToValidate = component.validationTarget,
            highlightElements = component.querySelectorAll(component.highlightElementSelector),
            offset = 0,
            margin = title? -5 : 10,
            customPositioningMethods = {},
            tooltipInner,
            tooltip = component.tooltip || component.querySelector('span.input-error-message');

        if (!component._validationInfo) {
            return;
        }

        idForAriaAttr = 'name-error-' + component.componentId;

        if (deviceUtils.isHandheld()) {
            if (!tooltip) {
                tooltip = document.createElement('span');
                tooltip.classList.add('input-error-message');
                tooltip.setAttribute('role', 'alert');
            }

            tooltip.setAttribute('id', idForAriaAttr);
            tooltip.textContent = component._validationInfo.message;
            component.appendChild(tooltip);
        } else {
            if (!tooltip) {
                //tooltip creation
                tooltip = document.createElement('ha-tooltip');

                if (elemToValidate.id) {
                    tooltip.targetSelector = '#' + elemToValidate.id;
                }

                tooltip.trigger = 'custom';
                tooltip.position = 'top';
                tooltip.setAttribute('role', 'alert');
            }

            tooltip.message = component._validationInfo.message;

            // accesibility attributes setting
            tooltipInner = tooltip.querySelector('.tooltip-inner');
            tooltipInner.id = idForAriaAttr;

            // This shouldn't be modified from outside the tooltip, but it's the only way to interrupt hiding animations from outside.
            // Without this, popup.show won't work because tooltip is still visible.
            if (tooltip.classList.contains('visible') && tooltip.classList.contains('leave')) {
                tooltip.classList.remove('leave');
            } else {
                customPositioningMethods.left = function _tryLeftAlignment(popup, currentPosition, currentPositionType) {
                    function _getPageSize(elementOwnerDocument) {
                        var documentEl = elementOwnerDocument.documentElement,
                            bodyEl = elementOwnerDocument.body;

                        return {
                            width: Math.max(
                                    bodyEl.scrollWidth, documentEl.scrollWidth,
                                    bodyEl.offsetWidth, documentEl.offsetWidth,
                                    bodyEl.clientWidth, documentEl.clientWidth
                                ),
                            height: Math.max(
                                bodyEl.scrollHeight, documentEl.scrollHeight,
                                bodyEl.offsetHeight, documentEl.offsetHeight,
                                bodyEl.clientHeight, documentEl.clientHeight
                                )
                        };
                    }

                    var available = _getPageSize(this.ownerDocument).width - popup.parentPosition.left,
                        finalOffset,
                        needed;

                    if (currentPositionType.position === 'top') {
                        needed = popup.dimensions.width + offset;
                        finalOffset = offset;
                    } else {
                        needed = popup.dimensions.width;
                        finalOffset = 0;
                    }

                    if (needed < available) {
                        currentPositionType.alignment = 'left';
                        currentPosition.x = popup.parentPosition.left + finalOffset;
                    }
                };

                popup.show(tooltip, elemToValidate, positions, alignments, margin, customPositioningMethods);
                tooltip._resizeMethod = popup.installResizeMethod(tooltip, elemToValidate, positions, alignments, margin, customPositioningMethods);
            }
        }

        Array.prototype.forEach.call(highlightElements, function(element) {
            element.setAttribute('aria-describedby', idForAriaAttr);
        });

        if (component.label) {
            titleElement = component.querySelector('legend') || component.querySelector('label');
            offset = titleElement.offsetWidth + 17;
        }

        component.tooltip = tooltip;
    }

    var Validatable = classes.createObject(UIComponent, {

        init: function _() {
            _.super(this);

            /**
             * private array that contains the validators to apply
             * @type {Array}
             */
            this._validators = null;

            /**
             * private object that contains the field validation status and message
             * coming from the validator
             * @type {Object}
             */
            this._validationInfo = null;

            /**
             * Indicates whether the field is required
             * @type {Boolean}
             */
            this.required = false;

            /**
             * Message to be displayed when a field is invalid
             * @type {String}
             */
            //this.invalidMessage = 'Invalid Value';

            /**
             * Function that can be used for validating a field
             * @type {Function}
             */
            this.validator = null;

            /**
             * Sets a minumum numeric value for a field
             * @type {Number}
             */
            this.min = null;

            /**
             * Sets a maximum numeric value for a field
             * @type {Function}
             */
            this.max = null;

            /**
             * The selector for the elements to highlight if an error is detected
             * @type {String}
             */
            this.highlightElementSelector = null;

            /**
             * The element that holds the state to be validated
             * @type {HTMLElement}
             */
            this.validationTarget = null;

            this.setupProperties({
                /**
                 * Required error message to be displayed when it participates in required validation
                 * @type {String}
                 */
                requiredMessage: {
                    default: 'Required Message',
                    type: String,
                    change: function(newValue) {
                        var validator;
                        if (Array.isArray(this._validators) && this._validators.length > 0) {
                            validator = this._validators.filter(function(item) {
                                return item.validationType === 'required';
                            });
                            // usually there is only one required validation
                            if (validator && validator[0]) {
                                validator[0].options.errorMessage = newValue;
                                // if the current component is invalid, refresh the validation info message
                                if (this._validationInfo && this._validationInfo.type === 'required') {
                                    this._validationInfo.message = newValue;
                                }
                            }
                        }
                    }
                },

                /**
                 * Invalid error message to be displayed when it participates in validations other than required
                 * @type {String}
                 */
                invalidMessage: {
                    default: 'Invalid Value',
                    type: String,
                    change: function(newValue) {
                        if (Array.isArray(this._validators) && this._validators.length > 0) {
                            this._validators.forEach(function(item) {
                                if (item.validationType !== 'required') {
                                    item.options.errorMessage = newValue;
                                }
                            });
                            // if the current component is invalid other than required validation, refresh the validation info message
                            if (this._validationInfo && this._validationInfo.type !== 'required') {
                                this._validationInfo.message = newValue;
                            }
                        }
                    }
                }
            });
        },

        /**
         * Displays the tooltip with the error message.
         * @deprecated
         */
        showValidationMessage: function() {
            console.warn('DEPRECATION WARNING: The "showValidationMessage" event is going to be deprecated. From now on, please use "reportValidity" method instead.');
            _showValidationMessage(this);
        },

        /**
         * Checks whether the component content is valid.
         * @param  {Boolean} forceTrue Optional. When true, the component and its values are considered valid
         * @returns {Boolean}
         */
        checkValidity: function(forceTrue) {
            _createValidators(this);

            if (this._validators.length === 0 || forceTrue || (this.value.length === 0 && !this.required)) {
                this._validationInfo = null;
                return true;
            }

            this._validationInfo = _validate(this._validators);

            return this._validationInfo.isValid;
        },

        /**
         * [handleTooltipBinding description]
         * @param  {Boolean} bind [description]
         * @return {[type]}      [description]
         */
        handleTooltipBinding: function(bind) {
            if (bind) {
                this.listenTo(this.validationTarget, 'mouseenter', this.reportValidity);
                this.listenTo(this.validationTarget, 'mouseleave', this.reportValidity);
                this.listenTo(this.validationTarget, 'blur', this.reportValidity, true);
            } else {
                this.stopListening(this.validationTarget, 'mouseenter', this.reportValidity);
                this.stopListening(this.validationTarget, 'mouseleave', this.reportValidity);
                this.stopListening(this.validationTarget, 'blur', this.reportValidity, true);
                //run a validation to update the fieldstate if necessary
                this.reportValidity();
            }

        },

        /**
         * Shows errors for invalid components.
         * @param  {Event} evt Optional. When defined an event triggered this call
         * @param  {Boolean} forceTrue Optional. When true, the component and it's values are consdiered valid
         * @returns {Boolean}
         */
        reportValidity: function(evt, forceTrue) {
            var valid = this._validationInfo && this._validationInfo.isValid,
                handheld = deviceUtils.isHandheld(),
                activeElement = this.ownerDocument.activeElement,
                showTooltip;

            // If no evt is present, the method was called directly and not triggered by an action
            if (!evt) {
                valid = this.checkValidity(forceTrue);
                _updateFieldState(this, valid);
                _updateTooltip(this, !valid);
                return valid;
            }

            switch (evt.type) {
                case 'focus':
                case 'mouseenter':
                case 'mouseover':
                    // If focusing or mouse enters input, there's no need to trigger validation again. It just shows tooltip if necessary
                    if (!handheld) {
                        _updateTooltip(this, !valid);
                    }
                    break;
                case 'mouseout':
                    // If mouse leaves the input, and focus is not on the input, tooltip is hidden
                    if (activeElement !== evt.target && deviceUtils.isDesktop()) {
                        _updateTooltip(this, false);
                    }
                    break;
                case 'mouseleave':
                    if (!evt.target.contains(activeElement) && deviceUtils.isDesktop()) {
                        _updateTooltip(this, false);
                    }
                    break;
                case 'blur':
                case 'hide':
                    valid = this.checkValidity();
                    _updateFieldState(this, valid);
                    // if the page is not showing on a desktop, show the tooltip (error message)
                    _updateTooltip(this, handheld && !valid);
                    break;
                case 'keyup':
                    // If this is a keypress event, and we're entering data into a currently valid field,
                    // don't invalidate it until it loses focus
                    if (valid || !this._validationInfo || this._validationInfo.isValid !== false) {
                        valid = true;
                    } else {
                        valid = this.checkValidity();
                        if (valid) {
                            _updateFieldState(this, valid);
                            // If event is keyup, tooltip is shown if the tooltip if invalid
                            showTooltip = !valid;
                            _updateTooltip(this, showTooltip);
                        }
                    }
            }

            return valid;
        },

        resetValidation: function() {
            this.checkValidity(true);
            _updateFieldState(this, true);
            _updateTooltip(this, false);
        }
    });

    return Validatable;
});

define('hui/radio-button-group',[
        'register-component/v2/register',
        './validatable/validatable',
        'object-utils/classes',
        './core/utils',
        './core/a11y',
        './radio-button'
    ], function(register, validatable, classes, utils, a11y) {
        'use strict';

        /*
        * Determine whether we should show the required * or not
        * If we are given a newValue overwrite the old label string/DOM with it
        * Else reursivly search the label's DOM till we find the last word and manipulate it
        * @param  {String} optional if you want to replace your label string and test showing the required indicator
        */
        function handleRequiredIndicator(component, newValue) {
            var label = component.querySelector('legend'),
                lastString;

            // recursivle walk through the label DOM to find the last work
            function walkLabelDOM(node) {
                if (node.nodeType === 3 && node.textContent.trim() !== '') {
                    lastString = node;
                }
                node = node.firstChild;
                while (node) {
                    walkLabelDOM(node);
                    node = node.nextSibling;
                }
            }

            if (label) {
                if (newValue) {
                    // overwrite old label with newValue, toggle * if needed
                    label.textContent = utils.toggleSuffixText(newValue, ' *', component.required && !component.noRequiredIndicator);
                } else {
                    // start recursion
                    walkLabelDOM(label);
                    if (lastString) {
                        // if we found the last work in the label DOM, toggle * if needed
                        lastString.textContent = utils.toggleSuffixText(lastString.textContent, ' *', component.required && !component.noRequiredIndicator);
                    }
                }
            }
        }

        /**
         * When a ha-radio-button is checked, updates the status of the rest to false
         * @param  {HTMLElement} component The ha-radio-button
         */
        function _uncheckRadios(component) {
            var radios = component.querySelectorAll('ha-radio-button');
            Array.prototype.forEach.call(radios, function(radio) {
                radio.checked = false;
            });
        }

        /**
         * Stops the click/change event from bubbling up and emits the one corresponding to the group, handling
         * the update of the inner radio button
         * @param  {Event} evt  The event coming from the radio-button
         * @emits HARadioButtonGroup#change
         */
        function _interceptEvent(evt) {
            var component = utils.getComponentFromElement(evt.target, 'HA-RADIO-BUTTON-GROUP');

            utils.stopEvent(evt);
            component.reportValidity(null, true);
            if (component._selectedItem !== evt.target) {
                component.value = evt.target.value;
            }
            component.emit(evt.type);
        }

        /**
         * Returns if the component has an active validation
         * @param  {HTMLElement} component The textfield
         * @return {Boolean}     true if there's at least an active validation
         */
        function validationActive(component) {
            return component.required || !!component.expected;
        }

        var HARadioButtonGroup = classes.createObject(validatable, {

            init: function _() {

                _.super(this);

                this._label = null;

                /**
                 * The currently selected ha-radio-button in radio button group
                 * @type {HTMLElement}
                 */

                this._selectedItem = null;

                /**
                 * The element that the validator will use to get the values to validate
                 * @type {HTMLElement}
                 */
                this.validationTarget = this;

                /**
                 * The selector for the elements to highlight if an error is detected
                 * @type {String}
                 */
                this.highlightElementSelector = 'input[type="radio"]';

                /**
                 * radios is the list of ha-radio-buttons that the radio button owns
                 * @type {Array}
                 */

                this._radios = null;

                /**
                 * fieldset is the property which contains the DOM element to append the group title
                 * @type {HTMLElement}
                 */

                this._fieldset = null;

                /**
                 * legend is the property which contains the radio button group title
                 * @type {String}
                 */

                this._legend = null;

                this.setupProperties({

                    /**
                     * This is the name for the radio button group.
                     * @type {String}
                     */
                    name: {
                        default: 'ha-radio-button-group-' + this.componentId,
                        type: String,
                        change: function(newValue) {
                            var name;

                            name = newValue;

                            if (this.radios && this._upgraded) {
                                this.radios.forEach(function(btn) {
                                    if (btn.name) {
                                        btn.name = name;
                                    } else {
                                        btn.setAttribute('name', name);
                                    }
                                });
                            }
                        }
                    },

                    expected: {
                        type: String,
                        default: '',
                        change: function(newValue, oldValue) {
                            if (newValue !== oldValue) {
                                this.handleTooltipBinding(validationActive(this));
                            }
                        }
                    },

                    /**
                     * noRequiredIndicator indicates whether '*' should be
                     * appended to the label when the field is required
                     * @type {Boolean}
                     */
                    noRequiredIndicator: {
                        default: false,
                        type: Boolean,
                        change: function(newValue, oldValue) {
                            if (newValue !== oldValue) {
                                handleRequiredIndicator(this);
                            }
                        }
                    },

                    required: {
                        type: Boolean,
                        default: false,
                        change: function(newValue, oldValue) {
                            if (newValue !== oldValue) {
                                handleRequiredIndicator(this);

                                this.handleTooltipBinding(validationActive(this));
                            }
                        }
                    },

                    /**
                     * This is the current value selected of the ha-radio-button in radio button group
                     * @type {String}
                     */
                    value: {
                        default: '',
                        type: String,
                        change: function(newValue) {
                            var index,
                                btn;
                            if (newValue && this._upgraded) {
                                var radioNumber = this.radios ? this.radios.length : 0;
                                _uncheckRadios(this, newValue);
                                for (index = 0; index < radioNumber; index++) {
                                    btn = this.radios[index];
                                    if (btn.getAttribute('value') === newValue) {
                                        this._selectedItem = btn;
                                        this._selectedItem.checked = true;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                });
            },

            set radios(newValue) {
                if (this._radiosHandle) {
                    this._radiosHandle.pause();
                }

                var fieldset = this.querySelector('fieldset'),
                    updateRadios = function(newValue) {
                        this._radios = [];
                        newValue = [].slice.call(newValue);

                        Array.prototype.slice.call(fieldset.querySelectorAll('ha-radio-button'), 0).forEach(function(node) {
                            this.stopListening(node, 'click', _interceptEvent);
                            this.stopListening(node, 'change', _interceptEvent);
                            fieldset.removeChild(node);
                        }.bind(this));

                        newValue.forEach(function(btn) {
                            this.listenTo(btn, 'click', _interceptEvent);
                            this.listenTo(btn, 'change', _interceptEvent);
                            btn.setAttribute('name', this.name);
                            fieldset.appendChild(btn);
                            this._radios.push(btn);
                            if (btn.hasAttribute('checked') && btn.checked) {
                                this.value = btn.getAttribute('value');
                            }
                        }, this);
                    }.bind(this);

                if (this._upgraded) {
                    updateRadios(newValue);
                }

                if (this._radiosHandle) {
                    this._radiosHandle.resume();
                }
            },

            get radios() {
                return this._radios;
            },

            set label(newValue) {
                var fieldset = this.querySelector('fieldset'),
                    legend = this.querySelector('legend'),
                    labelContainer = fieldset.querySelector('.label-container'),
                    haLabel = fieldset.querySelector('ha-label'),
                    isNode;

                if (newValue) {
                    isNode = Array.isArray(newValue) || newValue.nodeType === 1;
                    if (typeof newValue === 'string') {
                        // if ha-label left from element value, remove <ha-label>
                        if (haLabel) {
                            fieldset.removeChild(haLabel);
                            // recheck legend existance because it may have been removed with ha-label
                            legend = this.querySelector('legend');
                        }
                        // if no legend element create it and add it to label-container
                        if (!legend) {
                            legend = this.ownerDocument.createElement('legend');
                        }

                        // if no labelContainer element create it and add it to fieldset
                        if (!labelContainer) {
                            labelContainer = this.ownerDocument.createElement('div');
                            labelContainer.classList.add('label-container');
                            labelContainer.appendChild(legend);
                            fieldset.insertBefore(labelContainer, fieldset.firstChild);
                        }

                        legend.htmlFor = fieldset.id;
                        // toggle * if needed, and add legend text to legend element
                        handleRequiredIndicator(this, newValue);

                        // sync legend attribute
                        this.setAttribute('label', newValue);
                    } else if (isNode) {
                        // remove label attribute first
                        if (this.hasAttribute('label')) {
                            this.removeAttribute('label');
                        }

                        // if label-container left from string value, remove .label-container
                        if (labelContainer) {
                            fieldset.removeChild(labelContainer);
                        }

                        legend = this.ownerDocument.createElement('legend');
                        legend.htmlFor = fieldset.id;

                        if (Array.isArray(newValue)) {
                            if (haLabel) {
                                fieldset.removeChild(haLabel);
                            }
                            [].forEach.call(newValue, function(node) {
                                legend.appendChild(node);
                            });
                            haLabel = this.ownerDocument.createElement('ha-label');
                            haLabel.appendChild(legend);
                        } else if (!haLabel) {
                            legend.appendChild(newValue);
                            haLabel = this.ownerDocument.createElement('ha-label');
                            haLabel.appendChild(legend);
                        } else {
                            fieldset.removeChild(haLabel);
                            legend.innerHTML = newValue.innerHTML;
                            haLabel.innerHTML = legend.outerHTML;
                        }

                        fieldset.insertBefore(haLabel, fieldset.firstChild);

                        // toggle * if needed
                        handleRequiredIndicator(this);
                    }

                    this.listenTo(legend, 'click', function(evt) {
                        if (evt.target.localName === 'legend') {
                            evt.stopPropagation();
                        }
                    });

                } else {
                    // if falsy empty string, null or undefined

                    this.stopListening(legend, 'click');
                    // remove <ha-label> if it exists
                    if (haLabel) {
                        fieldset.removeChild(haLabel);
                    } else if (labelContainer) {
                        fieldset.removeChild(labelContainer);
                    }

                    // remove label attribute
                    if (this.hasAttribute('label')) {
                        this.removeAttribute('label');
                    }
                }

                this._label = newValue;
            },

            get label() {
                return this._label;
            },

            /**
             * Dummy method to avoid problems with getter without setters
             */
            set selectedItem(newValue) {
                // jshint unused:false
            },

            get selectedItem() {
                return this._selectedItem;
            },

            attributeChangedCallback: function _(attrName, oldValue, newValue) {
                // happens when we modify the attribute via browser inspector or via setAttribute
                if (attrName === 'label') {
                    // call the label setter which handles the logic
                    this.label = newValue;
                } else {
                    _.super(this, attrName, oldValue, newValue);
                }
            },

            ready: function _() {
                _.super(this);

                var fieldset = this.querySelector('fieldset'),
                    haLabel = this.querySelector('ha-label'),
                    labelAttributeValue = this.getAttribute('label'),
                    attributeValue = this.getAttribute('value'),
                    radios = Array.prototype.slice.call(fieldset ? fieldset.querySelectorAll('ha-radio-button') : this.querySelectorAll('ha-radio-button')),
                    tempName = this.name,
                    tempValue = this.value;

                if (!fieldset) {
                    this.appendChild(this.ownerDocument.createElement('fieldset'));
                    this.radios = utils.removeNodesSafe(this, radios);
                } else {
                    this.radios = radios;
                }

                if (attributeValue) {
                    this.value = attributeValue;
                }

                if (!haLabel) {
                    if (labelAttributeValue) {
                        this.label = labelAttributeValue;
                    }
                } else if (haLabel) {
                    this.label = haLabel;
                } else if (attributeValue) {
                    this.removeAttribute('label');
                }

                this.name = '';
                this.value = '';
                this.name = tempName;
                this.value = tempValue;

                a11y.addA11yFocus(this);

                if (this.hasAttribute('label')) {
                    this.label = this.getAttribute('label');
                }
            },

            attachedCallback: function _() {
                _.super(this);
            },

            detachedCallback: function() {
                if (this._radiosHandle) {
                    this._radiosHandle.remove();
                    this._radiosHandle = null;
                }
            }
        });

        return register('ha-radio-button-group', HARadioButtonGroup);
    }
);

define('hui/switch-button',[
    'register-component/v2/UIComponent',
    'register-component/v2/register',
    './core/utils',
    'object-utils/classes',
    './core/a11y'
], function(UIComponent, register, utils, classes, a11y) {

    var HASwitchbutton;

    /**
     * Sets the width of the label to let the button knows its size.
     * @param {HTMLElement} component The Switch Button component
     * @param {HTMLElement} label Element that will hold the width value.
     * @param {HTMLElement} on Element that hold the text of the on status.
     * @param {HTMLElement} off Element that hold the text of the off status.
     */
    function _setWidth(component, label, on, off) {
        var finalWidth, font, padding,
            onText = on.firstChild.textContent.toUpperCase(),
            offText = off.firstChild.textContent.toUpperCase();

        //we assume that the total padding and font are the same for both, on and off labels
        padding = parseInt(window.getComputedStyle(on).paddingLeft.replace('px', ''), 10) +
            parseInt(window.getComputedStyle(on).paddingRight.replace('px', ''), 10);
        font = window.getComputedStyle(on).fontSize + ' ' + window.getComputedStyle(on).fontFamily;

        // if we could not get the font from the computed styles we need to flag this to be
        // recalculated when it's attached
        // This happens when the instantiation has been done by js and the component is not on the DOM yet.
        if (font === ' ' && isNaN(padding) || (padding === 0)) {
            component._widthNotSet = true;
            return;
        }

        finalWidth = Math.max(utils.getTextWidth(onText, font), utils.getTextWidth(offText, font)) + 1;
        label.style.width = finalWidth + padding + 'px';
    }

    HASwitchbutton = classes.createObject(UIComponent, {

        /**
         * @emits click
         * @emits change
         */
        init: function _() {
            _.super(this);

            this.setupProperties({
                /**
                 * The default value for the checkbox "on"
                 * https://html.spec.whatwg.org/multipage/forms.html#dom-input-value-default-on
                 * @type {String}
                 */
                value: {
                    default: 'on',
                    change: function(newValue) {
                        this._nodes.input.value = newValue;
                    }
                },

                /**
                 * This is the name of the switchbutton.
                 * @type {String}
                 */
                name: {
                    default: '',
                    change: function(newValue) {
                        this._nodes.input.name = newValue;
                    }
                },

                label: {
                    default: '',
                    change: function(newValue) {
                        var label = this.querySelector('.label-div'),
                            input = this.querySelector('input'),
                            wrapper = this.querySelector('div:not(.label-div)');

                        if (newValue) {
                            if (!label) {
                                label = this.ownerDocument.createElement('div');
                                label.classList.add('label-div');
                                label.id = 'ha-switch-button-label-' + this.componentId;
                                input.setAttribute('aria-describedby', label.id);
                                this.insertBefore(label, wrapper);
                            }
                            label.textContent = newValue;
                        } else if (label) {
                            this.removeChild(label);
                            input.removeAttribute('aria-describedby');
                        }
                    }
                },

                /**
                 * This is the labelOff property for the switchbutton.
                 * @type {String}
                 */
                labelOff: {
                    default: 'OFF',
                    change: function(newValue) {
                        this._nodes.labelOff.textContent = newValue;
                        _setWidth(this, this._nodes.label, this._nodes.labelOn, this._nodes.labelOff);
                    }
                },

                /**
                 * This is the labelOn property for the switchbutton.
                 * @type {String}
                 */
                labelOn: {
                    default: 'ON',
                    change: function(newValue) {
                        this._nodes.labelOn.textContent = newValue;
                        _setWidth(this, this._nodes.label, this._nodes.labelOn, this._nodes.labelOff);
                    }
                },

                /**
                 * checked indicates if the switchbutton is checked
                 * @type {Boolean}
                 */
                checked: {
                    type: Boolean,
                    default: false,
                    change: function(newValue) {
                        this._nodes.input.checked = newValue;
                        this._nodes.input.setAttribute('aria-checked', newValue);
                    }
                }
            });
        },

        postRender: function _() {
            var wrapperEl,
                innerInput = this.querySelector('input'),
                labelOn = this.querySelector('.is-switch-on'),
                labelOff = this.querySelector('.is-switch-off'),
                label = this.querySelector('label'),
                circleButtonEl,
                ownerDocument = this.ownerDocument;

            _.super(this);

            if (!label) {
                circleButtonEl = ownerDocument.createElement('i');

                labelOff = ownerDocument.createElement('span');
                labelOff.classList.add('is-switch-off');
                labelOff.setAttribute('data-switch', 'OFF');

                labelOn = ownerDocument.createElement('span');
                labelOn.classList.add('is-switch-on');
                labelOn.setAttribute('data-switch', 'ON');

                label = ownerDocument.createElement('label');

                label.setAttribute('aria-live', 'assertive');
                label.appendChild(labelOn);
                label.appendChild(labelOff);
                label.appendChild(circleButtonEl);
            } else {
                circleButtonEl = label.querySelector('i');
            }

            if (!innerInput) {
                innerInput = ownerDocument.createElement('input');
                innerInput.type = 'checkbox';

                innerInput.appendChild(label);

                wrapperEl = ownerDocument.createElement('div');
                wrapperEl.appendChild(innerInput);
                wrapperEl.appendChild(label);
                this.appendChild(wrapperEl);
            }

            label.htmlFor = 'ha-switch-button-' + this.componentId;
            innerInput.id = 'ha-switch-button-' + this.componentId;
            labelOff.textContent = this.labelOff;
            labelOn.textContent = this.labelOn;

            this._nodes = {
                'input': innerInput,
                'label': label,
                'labelOn': labelOn,
                'labelOff': labelOff
            };

            //This is for stopping the inner element's click event.
            utils.stopNativeEvent(this, labelOn, 'click');
            utils.stopNativeEvent(this, labelOff, 'click');
            utils.stopNativeEvent(this, circleButtonEl, 'click');

            //Change listener from "change" to "click" event: regardless events registration sequence, Firefox will trigger click event first
            //and then change event, which would cause an issue in qbo data binding. Change to "click" event would resolve the issue.
            this.listenTo(innerInput, 'click', function(evt) {
                evt.stopPropagation();
                this.checked = evt.target.checked;
                this.emit('click');
            }.bind(this));

            this.listenTo(innerInput, 'change', function(evt) {
                evt.stopPropagation();
                this.emit('change');
            }.bind(this));

            a11y.addA11yFocus(this, innerInput, label);
        },

        attachedCallback: function _() {
            _.super(this);
            if (this._widthNotSet) {
                this._widthNotSet = false;
                _setWidth(this, this._nodes.label, this._nodes.labelOn, this._nodes.labelOff);
            }
        }

    });

    return register('ha-switch-button', HASwitchbutton);
});

define('hui/checkbox',[
    'register-component/v2/register',
    'register-component/v2/UIComponent',
    'object-utils/classes',
    './core/a11y',
    './core/deviceUtils'
], function(register, UIComponent, classes, a11y, deviceUtils) {
    'use strict';

    var HACheckbox = classes.createObject(UIComponent, {
        init: function _() {
            _.super(this);

            this.setupProperties({
                /**
                 * name indicates the name of the checkbox
                 * type {String}
                 **/
                name: {
                    default: '',
                    change: function(newValue) {
                        this._nodes.input.name = newValue;
                    }
                },
                /**
                 * disabled indicates whether the component is enabled or disabled
                 * @type {Boolean}
                 */
                disabled: {
                    default: false,
                    type: Boolean,
                    change: function(newValue) {
                        this._nodes.input.disabled = newValue;
                    }
                },
                /**
                 * checked indicates if the checkbox is checked
                 * @type {Boolean}
                 */
                checked: {
                    default: false,
                    type: Boolean,
                    change: function(newValue) {
                        if (this._nodes.input.checked !== newValue) {
                            this._nodes.input.checked = newValue;
                        }
                        this.emit('change');
                    }
                },
                /**
                 * The default value for the checkbox "on"
                 * https://html.spec.whatwg.org/multipage/forms.html#dom-input-value-default-on
                 * @type {String}
                 */
                value: {
                    default: 'on',
                    change: function(newValue) {
                        this._nodes.input.value = newValue;
                    }
                },
                /**
                 * This is the label property for the checkbox.
                 * @type {String}
                 */
                label: {
                    default: '',
                    change: function(newValue) {
                        var label = this._nodes.label;

                        label.textContent = newValue;

                        // update ariaLabel if label changes and ariaLabel DNE
                        if (!this.ariaLabel) {
                            this.ariaLabel = label.textContent;
                        }

                        if (!newValue) {
                            this.removeAttribute('label');
                        }
                    }
                },
                /**
                 * This is the indeterminate property for the checkbox
                 * @type {Boolean}
                 */
                indeterminate: {
                    default: false,
                    type: Boolean,
                    change: function(newValue) {
                        var checkbox = this.querySelector('input');
                        checkbox.indeterminate = newValue;
                    }

                },
                /**
                 * This is the arialabel property for the checkbox.
                 * @type {String}
                 */
                ariaLabel: {
                    default: '',
                    change: function(newValue) {
                        // note: setting ariaLabel to empty string will also remove aria-label from child input
                        var childInput = this.querySelector('input');
                        if (newValue) {
                            childInput.setAttribute('aria-label', newValue);
                        } else {
                            childInput.removeAttribute('aria-label');
                        }
                    }
                }
            });
        },

        postRender: function _() {
            _.super(this);

            // note: this._nodes is a deprecated caching mechanism -- avoid it moving forward
            this._nodes = {};

            var input = this.querySelector('input'),
                label,
                id;

            if (deviceUtils.isHandheld()) {
                this.classList.add('mobile-checkbox');
            }

            if (!input) {
                input = this.ownerDocument.createElement('input');
                input.type = 'checkbox';
                this.appendChild(input);
            }
            id = 'ha-checkbox-' + this.componentId;
            input.id = id;
            this._nodes.input = input;

            label = this.querySelector('label');
            if (!label) {
                label = this.ownerDocument.createElement('label');
                this.appendChild(label);
            }
            label.htmlFor = id;
            this._nodes.label = label;

            // set ariaLabel property from label content if ariaLabel DNE
            if (!this.ariaLabel) {
                if (this.label) {
                    this.ariaLabel = this.label;
                }
            }

            //Change listener from "change" to "click" event: regardless events registration sequence, Firefox will trigger click event first
            //and then change event, which would cause an issue in qbo data binding. Change to "click" event would resolve the issue.
            this.listenTo(input, 'click', function(evt) {
                evt.stopImmediatePropagation();
                this.checked = evt.target.checked;
                this.emit('click');
            }.bind(this));

            this.on('click', function(event) {
                event.preventDefault();
            });

            //This event listeners are created for preventing the change and click events to bubble up.
            this.listenTo(input, 'change', function(evt) {
                evt.stopPropagation();
            }.bind(this));

            //This event listeners are created for preventing the change and click events to bubble up.
            this.listenTo(label, 'click', function(evt) {
                evt.stopPropagation();
            });

            this.listenTo(input, 'blur', function() {
                this.emit('blur');
            }.bind(this));

            this.listenTo(input, 'focus', function() {
                this.emit('focus');
            }.bind(this));

            a11y.addA11yFocus(this);
        }
    });

    return register('ha-checkbox', HACheckbox);
});

define('hui/core/domObserver',[],function() {
    var matchesSelector = (function() {
        var matcher =
            Element.prototype.matchesSelector ||
            Element.prototype.mozMatchesSelector ||
            Element.prototype.msMatchesSelector ||
            Element.prototype.oMatchesSelector ||
            Element.prototype.webkitMatchesSelector;

        return function(root, element, selector) {
            return (element.parentElement === null || element.parentElement === root) && matcher.call(element, selector);
        };
    })();

    function pause(observer) {
        observer.disconnect();
    }

    function resume(observer, root, properties) {
        observer.observe(root, properties);
    }

    function _observe(root, observerProperties, matcher, callback) {
        var observer = new MutationObserver(function(mutations) {
            var doesMatch = false,
                i;

            for (i = 0; i < mutations.length; i++) {
                if (matcher(mutations[i])) {
                    doesMatch = true;
                    break;
                }
            }

            if (doesMatch) {
                pause(observer);
                callback(mutations);
                resume(observer, root, observerProperties);
            }
        });

        observer.observe(root, observerProperties);

        return {
            remove: function() {
                observer.disconnect();
            },
            pauses: 0,
            pause: function() {
                if (!this.pauses) {
                    pause(observer);
                }
                this.pauses++;
            },
            resume: function() {
                this.pauses = Math.max(0, this.pauses - 1);
                if (!this.pauses) {
                    resume(observer, root, observerProperties);
                }
            }
        };
    }

    /**
     * Observe an element for changes to its content. Content changes would be any change in
     * an element that is a descendant of the `root` element (including text nodes). The
     * callback function is called from the `root` context.
     *
     * @param {HTMLElement} root            The node to monitor for content changes
     * @param {Function}    callback        A function to call when changes are detected.
     * @returns {{remove, pause, resume}|*} An object containing methods for managing the observer lifecycle
     */
    function observeContent(root, callback) {
        return _observe(root, {
            childList: true,
            characterData: true,
            subtree: true,
            attributes: true
        }, function(mutation) {
            // attribute modifications to the node we are watching don't count
            return !(mutation.type === 'attributes' && mutation.target === root);
        }, function() {
            callback.call(root);
        });
    }

    /**
     * Observe an element for changes to children that match a particular CSS selector. To
     * increase performance, only additions/removals/attribute changes to the elements child list are monitored.
     * The callback function is called from the `root` context with an array of elements that match the selector as the
     * only parameter.
     *
     * @param {HTMLElement} root            The node to monitor for element changes
     * @param {string}      selector        A CSS selector specifying what nodes to watch
     * @param {Function}    callback        A function to call when changes are detected
     * @returns {{remove, pause, resume}|*} An object containing methods for managing the observer lifecycle
     */
    function observeElements(root, selector, callback) {
        return _observe(root, {
            childList: true,
            characterData: false,
            subtree: true,
            attributes: true
        }, function(mutation) {
            var i;

            if (mutation.type === 'childList' && mutation.target === root) {
                if (mutation.addedNodes.length > 0) {
                    for (i = 0; i < mutation.addedNodes.length; i++) {
                        if (matchesSelector(root, mutation.addedNodes[i], selector)) {
                            return true;
                        }
                    }
                }

                if (mutation.removedNodes.length > 0) {
                    for (i = 0; i < mutation.removedNodes.length; i++) {
                        if (matchesSelector(root, mutation.removedNodes[i], selector)) {
                            return true;
                        }
                    }
                }
            } else if (mutation.type === 'attributes' && matchesSelector(root, mutation.target, selector)) {
                return true;
            }

            return false;
        }, function() {
            var elements = [];

            Array.prototype.slice.call(root.querySelectorAll(selector), 0).forEach(function(element) {
                if (element.parentElement === root) {
                    elements.push(element);
                }
            });

            callback.call(root, elements);
        });
    }

    /**
     * Update an object property when the contents of a DOM node change. This method
     * is a continence wrapper for `observeContentChanges`.
     *
     * @param {HTMLElement} node        The node in which to watch for content changes
     * @param {Object}      object      The object whose property will get updated
     * @param {string}      property    The name of the property to update
     * @param {Function}    valueFn     A function that returns a value that the property will be set to
     */
    function bindContentChanges(node, object, property, valueFn) {
        var value = valueFn();

        if (object[property] !== value) {
            object[property] = value;
        }

        return observeContent(node, function() {
            object[property] = valueFn();
        });
    }

    function areNodesDifferent(list1, list2) {
        if (list1.length !== list2.length) {
            return true;
        }

        for (var i = 0; i < list1.length; i++) {
            if (!list1[i].isEqualNode(list2[i])) {
                return true;
            }
        }

        return false;
    }

    function bindChildrenChanges(node, selector, object, property) {
        var existingNodes = [];

        Array.prototype.slice.call(node.querySelectorAll(selector), 0).forEach(function(element) {
            if (element.parentElement === node) {
                existingNodes.push(element);
            }
        });

        if (areNodesDifferent(existingNodes, object[property])) {
            object[property] = existingNodes;
        }

        return observeElements(node, selector, function(newNodes) {
            object[property] = newNodes;
        });
    }

    return {
        observeContentChanges: observeContent,
        observeElementChanges: observeElements,
        bindContentChanges: bindContentChanges,
        bindChildrenChanges: bindChildrenChanges
    };
});
define('hui/checkbox-group',[
    'register-component/v2/register',
    './validatable/validatable',
    'object-utils/classes',
    './core/utils',
    './core/domObserver',
    './checkbox'
], function(register, Validatable, classes, utils, domObserver) {
    'use strict';

    /*
    * Determine whether we should show the required * or not
    * If we are given a newValue overwrite the old label string/DOM with it
    * Else reursivly search the label's DOM till we find the last word and manipulate it
    * @param  {String} optional if you want to replace your label string and test showing the required indicator
    */
    function handleRequiredIndicator(component, newValue) {
        var label = component.querySelector('legend'),
            lastString;

        // recursivle walk through the label DOM to find the last work
        function walkLabelDOM(node) {
            if (node.nodeType === 3 && node.textContent.trim() !== '') {
                lastString = node;
            }
            node = node.firstChild;
            while (node) {
                walkLabelDOM(node);
                node = node.nextSibling;
            }
        }

        if (label) {
            if (newValue) {
                // overwrite old label with newValue, toggle * if needed
                label.textContent = utils.toggleSuffixText(newValue, ' *', component.required && !component.noRequiredIndicator);
            } else {
                // start recursion
                walkLabelDOM(label);
                if (lastString) {
                    // if we found the last work in the label DOM, toggle * if needed
                    lastString.textContent = utils.toggleSuffixText(lastString.textContent, ' *', component.required && !component.noRequiredIndicator);
                }
            }
        }
    }

    /**
     * Stops the click event from bubbling up and emits the one corresponding to the group
     * @param  {Event} evt  The event coming from the radio-button
     * @emits HARadioButtonGroup#click
     */
    function _interceptClickEvent(evt) {
        var component = utils.getComponentFromElement(evt.target, 'HA-CHECKBOX-GROUP');

        utils.stopEvent(evt);
        component.emit(evt.type);
    }

    function _updateState(component, checkbox) {
        var index = component._value.indexOf(checkbox.value);
        if (checkbox.checked && !checkbox.disabled) {
            if (index === -1) {
                component._value.push(checkbox.value);
                component._selectedItems.push(checkbox);
                component.reportValidity(true);
            }
        } else if ((component._value) && (index !== -1)) {
            component._value.splice(index, 1);
            component._selectedItems.splice(index, 1);
        }
        component.reportValidity(null, true);
    }

    /**
     * Stops the change event from bubbling up and emits the one corresponding to the group, handling
     * the update of the inner radio button
     * @param  {Event} evt  The event coming from the radio-button
     * @emits HARadioButtonGroup#change
     */
    function _interceptChangeEvent(evt) {
        var component = utils.getComponentFromElement(evt.target, 'HA-CHECKBOX-GROUP');

        utils.stopEvent(evt);
        _updateState(component, evt.target);
        component.emit(evt.type);
    }

    var HACheckboxGroup = classes.createObject(Validatable, {

        init: function _() {

            _.super(this);

            this._label = null;

            /**
             * The currently selected ha-radio-button in radio button group
             * @type {HTMLElement}
             */
            this._selectedItems = [];

            /**
             * This is the list of current value selected in checkbox group.
             * @type {Array}
             */
            this._value = [];

            /**
             * List of ha-checkbox that the checkbox group owns.
             * @type {Array}
             */
            this._checkboxes = [];

            /**
             * The element that the validator will use to get the values to validate
             * @type {HTMLElement}
             */
            this.validationTarget = this;

            /**
             * The selector for the elements to highlight if an error is detected
             * @type {String}
             */
            this.highlightElementSelector = 'input[type="checkbox"]';

            this.setupProperties({

                /**
                 * This is the name for the checkbox button group.
                 * @type {String}
                 */
                name: {
                    default: 'ha-checkbox-group-' + this.componentId,
                    type: String,
                    change: function(newValue) {
                        if (this._checkboxes.length > 0) {
                            this._checkboxes.forEach(function(checkbox) {
                                if (checkbox.name) {
                                    checkbox.name = newValue;
                                } else {
                                    checkbox.setAttribute('name', newValue);
                                }
                            });
                        }
                    }
                },

                minRequired: {
                    default: 0,
                    type: Number,
                    change: function(newValue, oldValue) {
                        if (newValue !== oldValue) {
                            this.handleTooltipBinding(newValue || this.required);
                        }
                    }
                },

                /**
                 * noRequiredIndicator indicates whether '*' should be
                 * appended to the label when the field is required
                 * @type {Boolean}
                 */
                noRequiredIndicator: {
                    default: false,
                    type: Boolean,
                    change: function(newValue, oldValue) {
                        if (newValue !== oldValue) {
                            handleRequiredIndicator(this);
                        }
                    }
                },

                required: {
                    type: Boolean,
                    default: false,
                    change: function(newValue, oldValue) {
                        if (newValue !== oldValue) {
                            handleRequiredIndicator(this);

                            this.handleTooltipBinding(newValue || this.minRequired);
                        }
                    }
                }
            });
        },

        set value(newValue) {
            this._value.length = 0;
            this._selectedItems.length = 0;

            if (newValue) {
                newValue.forEach(function(value) {
                    this._checkboxes.forEach(function(checkbox) {
                        if (value === checkbox.value) {
                            this._selectedItems.push(checkbox);
                            this._value.push(value);
                            checkbox.checked = true;
                        } else if (this._value.indexOf(checkbox.value) === -1) {
                            checkbox.checked = false;
                        }
                    }.bind(this));
                }.bind(this));
            }
        },

        get value() {
            return this._value;
        },

        set checkboxes(newValue) {
            var fieldset = this.querySelector('fieldset');

            if (this._checkboxHandle) {
                this._checkboxHandle.pause();
            }

            this._checkboxes.length = 0;

            Array.prototype.slice.call(fieldset.querySelectorAll('ha-checkbox'), 0).forEach(function(node) {
                this.stopListening(node, 'click', _interceptClickEvent);
                this.stopListening(node, 'change', _interceptChangeEvent);
                fieldset.removeChild(node);
            }.bind(this));

            if (newValue) {
                newValue = [].slice.call(newValue);

                newValue.forEach(function(checkbox) {
                    this.listenTo(checkbox, 'click', _interceptClickEvent);
                    this.listenTo(checkbox, 'change', _interceptChangeEvent);
                    fieldset.appendChild(checkbox);
                    this._checkboxes.push(checkbox);
                    _updateState(this, checkbox);
                }, this);
            }

            if (this._checkboxHandle) {
                this._checkboxHandle.resume();
            }
        },

        get checkboxes() {
            return this._checkboxes;
        },

        /**
         * Dummy method to avoid problems with getter without setters
         * @param {Array} newValue Not used.
         */
        set selectedItems(newValue) {
            // jshint unused:false
        },

        get selectedItems() {
            return this._selectedItems;
        },

        set label(newValue) {
            var fieldset = this.querySelector('fieldset'),
                legend = this.querySelector('legend'),
                labelContainer = fieldset.querySelector('.label-container'),
                haLabel = fieldset.querySelector('ha-label'),
                isNode;

            if (newValue) {
                isNode = Array.isArray(newValue) || newValue.nodeType === 1;
                if (typeof newValue === 'string') {
                    // if ha-label left from element value, remove <ha-label>
                    if (haLabel) {
                        fieldset.removeChild(haLabel);
                        // recheck legend existance because it may have been removed with ha-label
                        legend = this.querySelector('legend');
                    }
                    // if no legend element create it and add it to label-container
                    if (!legend) {
                        legend = this.ownerDocument.createElement('legend');
                    }

                    // if no labelContainer element create it and add it to fieldset
                    if (!labelContainer) {
                        labelContainer = this.ownerDocument.createElement('div');
                        labelContainer.classList.add('label-container');
                        labelContainer.appendChild(legend);
                        fieldset.insertBefore(labelContainer, fieldset.firstChild);
                    }

                    legend.htmlFor = fieldset.id;
                    // toggle * if needed, and add legend text to legend element
                    handleRequiredIndicator(this, newValue);

                    // sync legend attribute
                    this.setAttribute('label', newValue);
                } else if (isNode) {
                    // remove label attribute first
                    if (this.hasAttribute('label')) {
                        this.removeAttribute('label');
                    }

                    // if label-container left from string value, remove .label-container
                    if (labelContainer) {
                        fieldset.removeChild(labelContainer);
                    }

                    legend = this.ownerDocument.createElement('legend');
                    legend.htmlFor = fieldset.id;

                    if (Array.isArray(newValue)) {
                        if (haLabel) {
                            fieldset.removeChild(haLabel);
                        }
                        [].forEach.call(newValue, function(node) {
                            legend.appendChild(node);
                        });
                        haLabel = this.ownerDocument.createElement('ha-label');
                        haLabel.appendChild(legend);
                    } else if (!haLabel) {
                        legend.appendChild(newValue);
                        haLabel = this.ownerDocument.createElement('ha-label');
                        haLabel.appendChild(legend);
                    } else {
                        fieldset.removeChild(haLabel);
                        legend.innerHTML = newValue.innerHTML;
                        haLabel.innerHTML = legend.outerHTML;
                    }

                    fieldset.insertBefore(haLabel, fieldset.firstChild);

                    // toggle * if needed
                    handleRequiredIndicator(this);
                }

                this.listenTo(legend, 'click', function(evt) {
                    if (evt.target.localName === 'legend') {
                        evt.stopPropagation();
                    }
                });

            } else {
                // if falsy empty string, null or undefined

                this.stopListening(legend, 'click');

                // remove <ha-label> if it exists
                if (haLabel) {
                    fieldset.removeChild(haLabel);
                } else if (labelContainer) {
                    fieldset.removeChild(labelContainer);
                }

                // remove label attribute
                if (this.hasAttribute('label')) {
                    this.removeAttribute('label');
                }
            }

            this._label = newValue;
        },

        get label() {
            return this._label;
        },

        attributeChangedCallback: function _(attrName, oldValue, newValue) {
            // happens when we modify the attribute via browser inspector or via setAttribute
            if (attrName === 'label') {
                // call the label setter which handles the logic
                this.label = newValue;
            } else {
                _.super(this, attrName, oldValue, newValue);
            }
        },

        postRender: function _() {
            _.super(this);

            var elements = this.querySelectorAll('ha-checkbox'),
                fieldset = this.querySelector('fieldset'),
                haLabel = this.querySelector('ha-label'),
                checkboxesParent = fieldset || this;

            if (!fieldset) {
                fieldset = this.ownerDocument.createElement('fieldset');
                this.appendChild(fieldset);
            }

            if (elements.length > 0) {
                elements = utils.removeNodesSafe(checkboxesParent, elements);
                this.checkboxes = elements;
            }

            var attributeValue = this.getAttribute('label');
            if (!haLabel) {
                if (attributeValue) {
                    // lets sync the attribute "label" to the component "label" property which then sets to the local input
                    this.label = attributeValue;
                }
            } else if (haLabel) {
                this.label = haLabel;
            } else if (attributeValue) {
                this.removeAttribute('label');
            }
        },

        /**
         * This function is to set checkboxHandle for mutation observer
         */
        _setCheckboxHandle: function() {
            if (this._checkboxes && !this._checkboxHandle) {
                this._checkboxHandle = domObserver.bindChildrenChanges(this.querySelector('fieldset'), 'ha-checkbox', this, 'checkboxes');
            }
        },

        attachedCallback: function _() {
            this._setCheckboxHandle();
            _.super(this);
        },

        detachedCallback: function() {
            if (this._checkboxHandle) {
                this._checkboxHandle.remove();
                this._checkboxHandle = null;
            }
        }
    });

    return register('ha-checkbox-group', HACheckboxGroup);
});

define('hui/core/contentNode',[],function() {
    'use strict';

    /**
     * The ContentNode provide us the ability to get from the HTML that the consumer
     * inputs the childNodes and place them into the corresponding place.
     * The mapping is being doing from the tag that wraps the content.
     * The basic interface convention is:
     *     <header></header>
     *     <main></main>
     *     <footer></footer>
     *
     * Then, each component takes those nodes and maps them to a property, as an array.
     * This mapping is done in a hash called 'ContentPropertyMap'.
     * For instance:
     *     ContentPropertyMap: {
     *         'header': 'titleText';
     *         'main': 'content',
     *         'footer': 'buttons'
     *     }
     */

    /**
    * Parse will apply some transformations to the input template if defined in the child component
    * If no transformation is defined in the child component, it will return the unchanged fragment
    * @param  {HTMLElement}    component           Component to apply the transformations
    * @param  {HTMLElement}    htmlFragment        The fragment to be transformed or not
    * @param  {String}         targetSelector      The selector to identify the target
    * @param  {Object}         transformations     Optional. Map of transformations to apply to HTML content
    */
    function _parse(component, htmlFragment, targetSelector, transformations) {
        var parsedFragment;
        if (transformations && transformations.hasOwnProperty(targetSelector)) {
            parsedFragment = transformations[targetSelector](component, htmlFragment, targetSelector);
            component._cachedChildNodes[targetSelector] = parsedFragment;
        } else {
            component._cachedChildNodes[targetSelector] = htmlFragment.parentElement.removeChild(htmlFragment);
        }
    }

    /**
     * Must be called before the template is rendered. Takes the content within the contentSelectors
     * and saves them to be applied later on the postRender, where the template is already in place.
     * @param  {HTMLElement}    component           Component to apply the mapping
     * @param  {Object}         contentPropertyMap  Mapping between HTML and properties
     * @param  {Object}         transformations     Optional. Map of transformations to apply to HTML content
     */
    function cacheInputContent(component, contentPropertyMap, transformations) {
        var key;

        if (contentPropertyMap && component.childNodes && component.childNodes.length) {
            component._cachedChildNodes = {};

            for (key in contentPropertyMap) {
                if (contentPropertyMap.hasOwnProperty(key) && component.querySelector(key)) {
                    _parse(component, component.querySelector(key), key, transformations);
                }
            }
        }
    }

    /**
     * If there was something on the input HTML to import into the Component template,
     * we should move it to the property that the ContentPropertyMap specifies,
     * and let the setter of the property update the content.
     * Then, we clean the cachedChildNodes so they are not accesible from the Component node.
     * @param  {HTMLElement}    component           Component to apply the mapping
     * @param  {Object}         contentPropertyMap  Mapping between HTML and properties
     */
    function storeCachedInput(component, contentPropertyMap) {
        var key,
            target;

        if (component._cachedChildNodes) {
            for (key in component._cachedChildNodes) {
                if (component._cachedChildNodes.hasOwnProperty(key)) {
                    target = contentPropertyMap[key];
                    component[target] = [].slice.call(component._cachedChildNodes[key].childNodes);
                }
            }

            delete component._cachedChildNodes;
        }
    }

    /**
     * Public method to add content.
     * @param {HTMLElement}   component           Component to add the content
     * @param {Object}        contentConfig       Could be a node or a list of nodes.
     * @param {Object}        contentPropertyMap  Mapping between HTML and properties
     * @deprecated
     */
    function addContent(component, contentConfig, contentPropertyMap) {
        var target,
            key,
            warningMessage;

        for (key in contentConfig) {
            if (contentConfig[key] && contentPropertyMap.hasOwnProperty(key)) {
                target = contentPropertyMap[key];
                if (Array.isArray(contentConfig[key])) {
                    component[target] = contentConfig[key];
                } else {
                    component[target] = [contentConfig[key]];
                }
            }
        }
        warningMessage = 'DEPRECATION WARNING: addContent method should not be used anymore to add ' +
            'content to the component. This will be removed in the future so please assign content ' +
            'directly to the corresponding component properties instead.';
        console.warn(warningMessage);
    }

    return {
        cacheInputContent: cacheInputContent,
        storeCachedInput: storeCachedInput,
        addContent: addContent
    };
});

define('hui/drawer/DrawerBase',[
    '../core/a11y',
    '../core/keys',
    '../core/utils',
    'register-component/v2/UIComponent',
    'object-utils/classes',
    '../core/contentNode'
], function(a11y, keys, utils, UIComponent, classes, contentNode) {
    'use strict';

    /**
     * Inserts the title in the rendered component
     * @param {HTMLElement} component The Drawer
     * @param {String} title   The title text
     */
    function setTitle(component, title) {
        var titleEl = component.querySelector('.content h3');
        if (titleEl) {
            titleEl.textContent = title;
        }
    }

    /**
     * Determines whether the element is a child of the drawer
     * @param {HTMLElement} element The possible child element
     * @param {HTMLElement} drawer The drawer
     */
    function elementIsInsideDrawer(element, drawer) {
        var parent = element && element.parentNode;
        while (parent) {
            if (parent === drawer) {
                return true;
            }
            parent = parent.parentNode;
        }

        return false;
    }

    var DrawerBase = classes.createObject(UIComponent, {

        init: function _() {

            _.super(this);
            /**
             * Used for accesibility reasons to set the focus to the last active element
             * before the Drawer appeareanse.
             * @private
             * @type {HTMLElement}
             */
            this._lastFocus = null;

            /**
             * Indicates whether the component is visible after calling show
             * @private
             * @type {Boolean}
             */
            this._open = false;

            this.setupProperties({
                /**
                 * A string that the consumer can set as an atributte/property
                 * which is going to be displayed on the Drawer as a Title.
                 * @type {String}
                 */
                titleText: {
                    default: '',
                    change: function(newValue) {
                        setTitle(this, newValue);
                    }
                }
            });

            /**
             * @emits dismiss.
             */
            this.on('keydown', function(evt) {
                if (keys.ESCAPE === evt.keyCode) {
                    utils.stopEvent(evt);
                    this.emit('dismiss');

                    // Check of the component is Large Drawer or Small Drawer.
                    // We need the change before close only for Large Drawer.
                    if (this.localName === 'ha-drawer-large') {
                        if (!this.noCloseOnDismiss) {
                            this.close();
                        }
                    } else if (this.localName === 'ha-drawer-small') {
                        this.close();
                    }
                } else {
                    a11y.keepFocusInsideListener(evt, this);
                }
            });

            this.listenTo(window, 'resize', function() {
                if (this._open && this.ownerDocument.activeElement.tagName === 'INPUT' &&
                    elementIsInsideDrawer(this.ownerDocument.activeElement, this)) {
                    setTimeout(function() {
                        if (this.ownerDocument.activeElement && this.ownerDocument.activeElement.scrollIntoViewIfNeeded) {
                            this.ownerDocument.activeElement.scrollIntoViewIfNeeded();
                        }
                    }.bind(this), 0);
                }
            }.bind(this));
        },

        /**
         * @deprecated. The 'close' method should be used instead
         */
        hide: function() {
            console.warn('DEPRECATION WARNING: The "hide" method is going to be deprecated. From now on, please use the "close" method instead.');
            this.close();
        },

        /**
         * Callback attached after the Component render
         * Here we check if the element was already rendered, if not we render it for the first time.
         * If it was rendered, we check if some property has change to apply the visual changes.
         */
        postRender: function _() {
            _.super(this);
            a11y.addA11yFocus(this);
            //Setting up things related to accesibility
            this.tabIndex = -1;
            this.role = 'dialog';

        },

        /**
         * This method must be removed, once the hide method is also removed.
         */
        addEventListener: function _() {
            HTMLElement.prototype.addEventListener.apply(this, arguments);
            if (arguments[0] === 'hide') {
                console.warn('DEPRECATION WARNING: The hide event is going to be deprecated. From now on, please use "close" instead.');
            }
        },

        /**
         * Adds content to the component
         * @param {object} config Mapping between HTML and properties
         * @deprecated Properties should be used directly instead
         */
        addContent: function(config) {
            var _contentPropertyMap = {
                'section': 'section',
                'main': 'section',
                'footer': 'footer'
            };
            contentNode.addContent(this, config, _contentPropertyMap);
        },

        _focusFirst: function() {
            var content = this.querySelector('.content');

            a11y.setFocusOnFirst(content);
            content.scrollTop = 0;
        }
    });

    return DrawerBase;
});

define('hui/core/underlay',[
    './a11y',
    './position'
],
function(a11y, position) {
    'use strict';

    var setFocusMethod,
        Underlay,
        previousZindexes = [];

    Underlay = {
        /**
         * Add underlay to the body and shows it
         * @param {HTMLElement} component The component that needs to set an underlay
         */
        show: function(component) {
            var bodyEl = document.body,
                underlayElement = bodyEl.querySelector('.ha-underlay');

            if (underlayElement) {
                previousZindexes.push(underlayElement.style.zIndex);
            } else {
                underlayElement = document.createElement('div');
                underlayElement.classList.add('ha-underlay');
                underlayElement.tabIndex = -1;
                bodyEl.appendChild(underlayElement);
                setFocusMethod = function() {
                    a11y.setFocusOnFirst(this);
                }.bind(component);
                underlayElement.addEventListener('focus', setFocusMethod);
            }

            position.bringToFront(underlayElement);

            this._hiddenAriaRemoveHandle = a11y.hideChildElementsFromAria(document.body, [component]);

            return underlayElement;
        },

        /**
         * Hides the underlay and removes the component from the body
         */
        hide: function() {
            var _animationend = 'webkitAnimationName' in document.documentElement.style ? 'webkitAnimationEnd' : 'animationend',
                bodyEl = document.body,
                underlayElement = bodyEl.querySelector('.ha-underlay');

            if (underlayElement && !underlayElement.classList.contains('fade-out')) {
                if (this._hiddenAriaRemoveHandle) {
                    this._hiddenAriaRemoveHandle.remove();
                    this._hiddenAriaRemoveHandle = null;
                }

                if (previousZindexes.length) {
                    underlayElement.style.zIndex = previousZindexes.pop();
                } else {
                    bodyEl.addEventListener(_animationend, function onHide() {
                        bodyEl.removeEventListener(_animationend, onHide);
                        underlayElement.removeEventListener('focus', setFocusMethod);
                        setFocusMethod = null;
                        bodyEl.removeChild(underlayElement);
                    });
                    underlayElement.classList.add('fade-out');
                }
            }
        },

        /**
         * Set desired z-index to the underlay
         * @param {Number} zIndex Value of z-index to set to the overlay
         */
        setZIndex: function(zIndex) {
            var underlayElement = document.body.querySelector('.ha-underlay');
            if (underlayElement) {
                underlayElement.style.zIndex = zIndex;
            }
        }
    };

    return Underlay;
});

define('hui/drawer-large',[
    'register-component/v2/register',
    './drawer/DrawerBase',
    './core/position',
    './core/underlay',
    'object-utils/classes',
    './core/utils',
    './core/deviceUtils'
], function(register, DrawerBase, position, Underlay, classes, utils, deviceUtils) {
    'use strict';

    var el = utils.createElement,

        renderedFooter = function(component) {
            return component.querySelector('aside > footer > *');
        },

        renderedSection = function(component) {
            return component.querySelector('aside > section > div.inner-content > *');
        },

        userProvidedMain = function(component) {
            var mainTag = component.querySelector('main'),
                message = 'DEPRECATION WARNING: <main> tags should not be used anymore to add ' +
                    'content to <ha-drawer-large>. Please add content through a <section> tag.';

            if (mainTag) {
                console.warn(message);
            }

            return mainTag;
        },

        userProvidedSection = function(component) {
            return component.querySelector('section');
        },

        userProvidedFooter = function(component) {
            return component.querySelector('footer');
        },

        renderCloseButton = function() {
            var closeButton = el('button', {'className': 'drawer-close first-focus'}, [
                    el('span', {'className': 'hi hi-close'})
                ]);

            closeButton.setAttribute('aria-label', 'close');

            return closeButton;
        },

        renderHeader = function() {
            return el('header', {'className': 'header'}, [renderCloseButton()]);
        },

        renderSection = function(content, id) {
            var section = el('section', {'className': 'content'}, [
                    el('h3', {'id': 'drawer-large-title-' + id}),
                    el('div', {'className': 'inner-content'}, [content])
                ]);

            section.setAttribute('tabindex', '-1');

            return section;
        },

        renderFooter = function(content) {
            var footer = el('footer', {'className': 'footer'}, [content]);

            footer.setAttribute('tabindex', '-1');

            return footer;
        },

        renderAside = function(sectionContent, componentId, footerContent) {
            var aside = el('aside', {'className': 'drawer-panel'}, [
                    renderHeader(),
                    renderSection(sectionContent, componentId),
                    renderFooter(footerContent)
                ]);

            aside.setAttribute('aria-labelledby', 'drawer-large-title-' + componentId);
            aside.setAttribute('tabindex', '-1');

            return aside;
        },

        HADrawerLarge;

    HADrawerLarge = classes.createObject(DrawerBase, {

        init: function _() {
            _.super(this);

            var animationEvents = utils.getAnimationEventNames();

            this.setupProperties({
                /**
                 * Indicates whether or not the Drawer needs to have a full
                 * screen overlay with opacity.
                 * @type {Boolean}
                 */
                backdrop: {
                    default: false,
                    type: Boolean
                },
                /**
                 * Indicates whether the component is rendered into the body by react
                 * @type {Boolean}
                 */
                reactLayering: {
                    type: Boolean,
                    default: false
                },
                /**
                 * @deprecated 'backdrop' should be used instead
                 * @type {Boolean}
                 */
                overlay: {
                    default: false,
                    type: Boolean,
                    change: function(newValue, oldValue) {
                        /* istanbul ignore if */
                        if (newValue !== oldValue) {
                            this.backdrop = newValue;
                            console.warn('DEPRECATION WARNING: The "overlay" property is going to be deprecated. From now on, please use the "backdrop" property instead.');
                        }
                    }
                },

                /**
                 * Indicates whether the component closes by default when X is clicked
                 * or ESC key is pressed
                 * @type {Boolean}
                 */
                noCloseOnDismiss: {
                    type: Boolean,
                    default: false
                }
            });

            /**
             * @emits dismiss.
             */
            this.on('button.drawer-close:click', function() {
                this.emit('dismiss');
                if (!this.noCloseOnDismiss) {
                    this.close();
                }
            }.bind(this));

            // animation end for show/close
            this.on(animationEvents.animationend, function(evt) {
                evt.stopPropagation();

                // focus on first tabbable element after show
                if (evt.animationName === 'ha-drawer-slide-in') {
                    this._focusFirst();
                } else if (evt.animationName === 'ha-drawer-slide-out') {
                    // Listener for removing show class after ha-drawer-slide-out is completed
                    this.classList.remove('show');
                }
            }.bind(this));
        },

        get footer() {
            return utils.arrayOfChildrenFrom(renderedFooter(this));
        },

        /**
         * Set a node or an array of nodes for footer
         * @param {HTMLElement|[HTMLElement]} newFooter Node or nodes to set
         */
        set footer(newFooter) {
            utils.replaceChildrenOf(
                this.querySelector('aside > footer'),
                utils.wrapIfNotWrapped('footer', newFooter));
        },

        get section() {
            return utils.arrayOfChildrenFrom(renderedSection(this));
        },

        /**
         * Set a node or an array of nodes for section
         * @param {HTMLElement|[HTMLElement]} newSection Node or nodes to set
         */
        set section(newSection) {
            utils.replaceChildrenOf(
                this.querySelector('aside > section > div.inner-content'),
                utils.wrapIfNotWrapped('section', newSection));
        },

        get headerNode() {
            return this.querySelector('aside > header');
        },

        get footerNode() {
            return this.querySelector('aside > footer');
        },

        /**
         * Opens the Drawer, and makes the elements inside to be accessible from the keyboard.
         * @emits show
         */
        show: function() {
            if (!this._open) {
                this._open = true;

                // save the last focused element so we can refocus to it later when closed
                this._lastFocus = this.ownerDocument.activeElement;

                // making elements inside the Drawer visible for the keyboard
                // the show class makes the drawer visible in order to execute the corresponding animations
                this.classList.add('show');
                this.classList.remove('slide-out');
                this.classList.add('slide-in');

                if (this.backdrop) {
                    if (!this.reactLayering) {
                        Underlay.show(this);
                    }
                    // adding a class to the html tag does not work, we need to add the style inline
                    this.ownerDocument.documentElement.style.overflow = 'hidden';
                }

                // fix bleeding (overscroll) Safari mobile (see HUI-3618)
                if (deviceUtils.isHandheld()) {
                    this.ownerDocument.body.classList.add('no-overscroll');
                }

                if (!this.reactLayering) {
                    position.bringToFront(this);
                }

                if (deviceUtils.isIOSDevice()) {
                    if (this.backdrop) {
                        deviceUtils.stopTouchMove(this.ownerDocument.querySelector('.ha-underlay'), true);
                        if (deviceUtils.isTablet()) {
                            this.ownerDocument.body.classList.add('body-lock');
                        }
                    }
                    if (this.headerNode) {
                        deviceUtils.stopTouchMove(this.headerNode, true);
                    }
                    if (this.footerNode) {
                        deviceUtils.stopTouchMove(this.footerNode, true);
                    }
                }
                this.emit('show');
            }
        },

        /**
         * Closes the Drawer, and remove the elements inside from the keyboard access.
         * @emits close
         * @emits hide - for backward compatibility
         */
        close: function() {
            if (this._open) {
                this._open = false;
                this.classList.remove('slide-in');
                this.classList.add('slide-out');

                // remove backdrop if we have one
                if (this.backdrop) {
                    if (!this.reactLayering) {
                        Underlay.hide();
                    }
                    setTimeout(function() {
                        this.ownerDocument.documentElement.style.overflow = '';
                    }.bind(this), 350);
                }

                // fix bleeding (overscroll) Safari mobile (see HUI-3618)
                if (deviceUtils.isHandheld()) {
                    this.ownerDocument.body.classList.remove('no-overscroll');
                }

                if (deviceUtils.isIOSDevice()) {
                    if (this.backdrop && deviceUtils.isTablet()) {
                        this.ownerDocument.body.classList.remove('body-lock');
                    }
                    if (this.headerNode) {
                        deviceUtils.stopTouchMove(this.headerNode, false);
                    }
                    if (this.footerNode) {
                        deviceUtils.stopTouchMove(this.footerNode, false);
                    }
                }

                // restore focus to last active element before drawer was opened
                if (this._lastFocus) {
                    this._lastFocus.focus();
                }
                this._lastFocus = null;
                this.emit('close');
                this.emit('hide'); // for backward compatibility
            }
        },

        postRender: function _() {
            _.super(this);

            // Cache input
            var section = renderedSection(this) || userProvidedMain(this) || userProvidedSection(this),
                footer = renderedFooter(this) || userProvidedFooter(this);

            // Destroy children
            utils.removeAllChildrenFrom(this);

            // Create and append "template"
            this.appendChild(renderAside(section, this.componentId, footer));
        }
    });

    return register('ha-drawer-large', HADrawerLarge);
});

define('hui/drawer-small',[
    'register-component/v2/register',
    './drawer/DrawerBase',
    'object-utils/classes',
    './core/utils'
], function(register, DrawerBase, classes, utils) {
    'use strict';

    var el = utils.createElement,
        /**
         * We save a reference to the previous parent node, since the consumer could
         * direclty append the component into another place without removing. This makes the detachedCallback
         * happen when this.parentElement is the new parent, and we cannot do the clean up.
         * @type {HTMLElement}
         */
        _previousParentNode = null,
        HADrawerSmall;

    function _setContentHeight(drawer) {
        var doc = drawer.ownerDocument,
            docHeight = Math.max(
                doc.body.scrollHeight, doc.documentElement.scrollHeight,
                doc.body.offsetHeight, doc.documentElement.offsetHeight,
                doc.body.clientHeight, doc.documentElement.clientHeight
            ),
            contentHeight = docHeight - drawer.offsetTop + 'px';

        drawer.querySelector('.content').style.height = contentHeight;
    }

    /**
     * This method is used to toggle the visiblity of the Drawer
     */
    function _toggle() {
        /*jshint validthis:true */
        if (this._open) {
            this.close();
        } else {
            this.show();
        }
    }

    function _setTargetSibling(component, targetSelector, prevTargetSelector) {
        var parent = component.parentElement,
            prevTarget,
            target;

        if (parent) {
            if (prevTargetSelector !== undefined && prevTargetSelector !== '') {
                prevTarget = parent.querySelector('.ha-flex-flexible');
            } else {
                prevTarget = component.previousElementSibling;
            }

            if (prevTarget) {
                prevTarget.classList.remove('ha-flex-flexible');
            }
        }

        if (targetSelector) {
            target = component.ownerDocument.querySelector(targetSelector) || component.previousElementSibling;
        } else {
            target = component.previousElementSibling;
        }

        if (target) {
            target.classList.add('ha-flex-flexible');
        }
    }

    function renderedSection(component) {
        return component.querySelector('section > div.inner-content > *');
    }

    function userProvidedSection(component) {
        return component.querySelector('section');
    }

    function renderCloseButton() {
        var closeButton = el('button', {'className': 'btn-toggle drawer-hide first-focus'}, [
                el('i', {'className': 'hi hi-chevron-left drawer-arrow'}),
                el('i', {'className': 'hi hi-chevron-right drawer-arrow'})
            ]);

        closeButton.setAttribute('aria-label', 'close');

        return closeButton;
    }

    function renderSection(componentId, sectionContent) {
        return el('section', { 'className': 'content'}, [
                el('h3', { 'id': 'drawer-small-title-' + componentId }),
                el('div', { 'className': 'inner-content' }, [
                    sectionContent
                ])
            ]);
    }

    HADrawerSmall = classes.createObject(DrawerBase, {

        init: function _() {
            _.super(this);

            this.setupProperties({
                /**
                 * Defines the previous sibling element to which the ha-flex-flexible class will be added.
                 * @type String
                 */
                targetSiblingSelector: {
                    default: '',
                    type: String,
                    change: function(newValue, oldValue) {
                        _setTargetSibling(this, newValue, oldValue);
                    }
                }
            });

            this.classList.add('ha-flex-fixed');

            this.on('button.drawer-hide:click', _toggle.bind(this));
        },

        get section() {
            return utils.arrayOfChildrenFrom(renderedSection(this));
        },

        set section(newSection) {
            utils.replaceChildrenOf(
                this.querySelector('section > div.inner-content'),
                utils.wrapIfNotWrapped('section', newSection));
        },

        /**
         * Adding CSS Classes to the parent in case the host app doesn't use flexbox and to fix the layout
         * for what the drawer needs it to be.
         */
        attachedCallback: function _() {
            _.super(this);
            _previousParentNode = this.parentElement;

            if (_previousParentNode && !_previousParentNode.classList.contains('ha-flex-columns') &&
                !_previousParentNode.classList.contains('ha-flex-flexible')) {
                _previousParentNode.classList.add('ha-flex-columns');
                _previousParentNode.classList.add('ha-flex-flexible');
            }

            _setTargetSibling(this, this.targetSiblingSelector);
        },

        postRender: function _() {
            _.super(this);

            // Cache input
            var documentFragment = document.createDocumentFragment(),
                section = renderedSection(this) || userProvidedSection(this);

            // Destroy children
            utils.removeAllChildrenFrom(this);

            // Create template
            utils.appendChildren(documentFragment, [
                renderCloseButton(),
                renderSection(this.componentId, section)
            ]);

            this.appendChild(documentFragment);

            this.setAttribute('aria-labelledby', 'drawer-small-title-' + this.componentId);
        },

        /**
         * Removing the classes we added on the attachement to the parent and the previous sibling so in
         * case that the consumer moves the drawer around the DOM, we can ensure that the layout will be consistent
         * and no extra flexbox clases will remain there innecesary.
         */
        detachedCallback: function() {
            if (_previousParentNode) {
                _previousParentNode.classList.remove('ha-flex-columns');
                _previousParentNode.classList.remove('ha-flex-flexible');
            }

            if (this.targetSiblingSelector) {
                this.targetSiblingSelector = null;
            }
        },

        /**
         * Opens the Drawer, and makes the elements inside to be accesible from the keyboard.
         * @emits show
         */
        show: function() {
            if (!this._open) {
                this._open = true;

                _setContentHeight(this);

                // making elements inside the Drawer visible for the keyboard
                // the class slideIn, removes all the display:none in the header, content and footer
                this.classList.add('slide-in');
                this._lastFocus = this.ownerDocument.activeElement;
                // focus on first tabbable element
                this._focusFirst();

                this.emit('show');
            }
        },

        /**
         * Closes the Drawer, and remove the elements inside from the keyboard access.
         * @emits close
         * @emits hide - for backward compatibility
         */
        close: function() {
            if (this._open) {
                this._open = false;
                this.classList.remove('slide-in');

                // restore focus to last active element before drawer was opened
                if (this._lastFocus) {
                    if (this._lastFocus.className.indexOf('btn-toggle') > -1) {
                        this._lastFocus.blur();
                    } else {
                        this._lastFocus.focus();
                    }
                }

                this._lastFocus = null;

                this.emit('close');
                this.emit('hide'); // for backward compatibility
            }
        },

        /**
         * Adds ha-flex-columns ha-flex-flexible to an element or an array of elements.
         * @param {Array} param
         */
        addFlexColumnClass: function(param) {
            var temp = [];
            if (param && Array.isArray(param)) {
                temp = param;
                temp.forEach(function(element) {
                    element.classList.add('ha-flex-columns');
                    element.classList.add('ha-flex-flexible');
                });
            }
        },

        /**
         * Adds ha-flex-children to an array of elements.
         * @param {Array} param
         */
        addFlexChildrenClass: function(param) {
            var temp = [];
            if (param && Array.isArray(param)) {
                temp = param;
                temp.forEach(function(element) {
                    element.classList.add('ha-flex-children');
                });
            }
        }
    });

    return register('ha-drawer-small', HADrawerSmall);
});

define('hui/core/dojoUtils',[], function() {
    return {
        /**
         * Determines if the element is a Dojo widget (dijit) popup.
         * Climbs to parent element searching for the dijitPopup class.
         * @param {HTMLElement}  element       is the potential Dojo widget.
         * @returns {Boolean} If the element is a Dojo widget popup.
         */
        isDojoWidgetPopup: function(element) {
            while (element && element.tagName !== 'BODY') {
                if (element.classList.contains('dijitPopup')) {
                    return true;
                } else {
                    element = element.parentNode;
                }
            }
            return false;
        },

        /**
         * Search a specific element and return it from the Dojo component.
         * @param {HTMLElement}  element       is the component which could have searched target.
         * @param {String}       targetTagName   is the component name to be searched.
         * @returns {HTMLElement} The component searched.
         */
        getDojoWidgetPopup: function(element, targetTagName) {
            while (element && element.tagName !== 'BODY') {
                if (element.classList.contains('dijitPopup')) {
                    // If sibling is HA-POPOVER, return this element
                    // Once we've reached the dijitPopup root - examine sibling
                    // for HA-POPOVER or targetTagName
                    if (element.parentNode && element.parentNode.childNodes) {
                        for (var i = 0; i < element.parentNode.childNodes.length; ++i) {
                            if (element.parentNode.childNodes[i].tagName === targetTagName) {
                                return element;
                            }
                        }
                    }
                } else {
                    element = element.parentNode;
                }
            }
            return element;
        },

        /**
         * Returns the owner element of the dijitPopup.
         * @param {HTMLElement}  popover       is the sibling 'container' popover.
         * @param {HTMLElement}  dojoWidget    is the sibling element of the popover.
         * @returns {HTMLElement} The target selector.
         */
        getTargetSelector: function(popover, dojoWidget) {
            var selectorTargetID = dojoWidget.getAttribute('dijitpopupparent');
            return popover.querySelector('#' + selectorTargetID);
        },

        /**
         * If the element that received the click / blur event isn't a child
         * of either popover type, then we should dismiss the popover.
         *
         * Notable example: if a DateTextBox is open under an HA-POPOVER, and the
         * user clicks on a separate tab, then we should dismiss both the
         * DateTextBox and HA-POPOVER. Both popovers are siblings and neither are
         * children of the tab content.
         * @param {HTMLElement}  element       the evt.relatedTarget element
         * @param {String}  targetTagName      the component name to be searched.
         * @returns {Boolean} If the popover should be dismissed.
         */
        shouldDismissPopover: function(element, targetTagName) {
            while (element && element.tagName !== 'BODY') {
                if (element.tagName === targetTagName || element.classList.contains('dijitPopup')) {
                    return false;
                } else {
                    element = element.parentNode;
                }
            }
            return true;
        }
    };
});

define('hui/popover',[
    'register-component/v2/register',
    'object-utils/classes',
    'register-component/v2/UIComponent',
    './core/a11y',
    './core/keys',
    './core/utils',
    './core/popup',
    './core/dojoUtils'
],
function(register, classes, UIComponent, a11y, keys, utils, popup, dojoUtils) {
    var HAPopover;

    /** Handler popover close.
     * @param {HTMLElement} component The popover component
     */
    function _closePopover(component) {
        // FireFox and Safari do not emit a blur event when an ancestor node of the currently focused
        // element is hidden, so we need to blur it in case any tooltips(or anything else) are listening
        if (component.contains(document.activeElement)) {
            document.activeElement.blur();
        }
        component.classList.remove('visible');
        component.classList.remove('leave');

        // the default behavior is to focus on the last activeElement before we open the popover
        // to bypass that use this._noAutoFocusLastActiveElementOnClose=true, usually set when a popover is used as composite component
        if (!component._noAutoFocusLastActiveElementOnClose && component.lastFocus) {
            component.lastFocus.focus();
        }

        component.open = false;
        component.emit('hide');
        component.emit('close');
    }

    /** Handler onanimationend.
     * @param {AnimationEvent} eventName
     * @param {HTMLElement} component The popover component
     * @fires HA-Popover#show
     * @fires HA-Popover#close
     * @fires HA-Popover#hide (deprecated)
     */
    function _onAnimationEnd(eventName, component) {
        var lastElementChild, focusedElement;

        switch (eventName) {
            case 'ha-fade-in':
                component.classList.remove('enter');

                // focus on first child tabbable element when needed
                if (!component._noAutoFocusFirstTabbableElementOnShow) {
                    lastElementChild = component.lastElementChild;
                    if (lastElementChild) {
                        focusedElement = a11y.setFocusOnAnyFirst(lastElementChild);
                        if (!focusedElement) {
                            lastElementChild.focus();
                        }
                    }
                }

                component.open = true;
                component.emit('show');
                break;
            case 'ha-fade-out':
                _closePopover(component);
                break;
        }
    }

    /**
     * Finds the container element of the click event. In the case of a Dojo
     * popover, we allow both a Dojo and regular popover to dismiss upon
     * blur events. This is to support Dojo popovers being siblings of HA-POPOVERS.
     * @param {HTMLElement} popover  The popover used for searching
     * @param {HTMLElement} element  The popover component
     * @return {HTMLElement}         The component that owns the popover
     */
    function _handleOwnerPopover(popover, element) {
        var ownerElement, popoverElement;

        if (dojoUtils.isDojoWidgetPopup(element)) {

            // find the dijit popover and query the origin of the selection
            popoverElement = dojoUtils.getDojoWidgetPopup(element, 'HA-POPOVER');
            if (popoverElement) {
                ownerElement = dojoUtils.getTargetSelector(popover, popoverElement);
            }

            var closePopover = function(evt) {
                if (evt.relatedTarget) {
                    // close the root popover if the click was outside the root popover scope
                    if (dojoUtils.shouldDismissPopover(evt.relatedTarget, 'HA-POPOVER')) {
                        popover.close();
                    }
                    document.activeElement.removeEventListener('blur', closePopover);
                }
            };

            // add a one-time blur listener to elements within the dijit
            document.activeElement.addEventListener('blur', closePopover);
        } else {
            // find popover that contains the element, then query the actual owner
            popoverElement = utils.getComponentFromElement(element, 'HA-POPOVER');
            if (popoverElement) {
                ownerElement = popover.querySelector(popoverElement.targetSelector);
            }
        }

        return ownerElement;
    }

    /**
     * Tries to find the component that owns the popover
     * @param  {HTMLElement} popover The popover used for searching
     * @param  {HTMLElement} element The contaning element
     * @return {HTMLElement}         The component that owns the popover
     */
    function ownerComponentFromPopover(popover, element) {
        var ownerElement;

        if (element.tagName === 'HA-POPOVER') {
            // if the element is a popover it means the popover has a containing component that opens another popover
            // use the targetSelector to query the actual owner
            ownerElement = popover.querySelector(element.targetSelector);
        } else {
            ownerElement = _handleOwnerPopover(popover, element);
        }

        return ownerElement;
    }

    /**
     * Determines if an element is contained in a popover.
     * If the element tested is a popover, then it is in the body. Use the owner of the element (popover) for matching.
     * @param  {HTMLElement} popover The containing popover
     * @param  {HTMLElement} element The element to test
     * @return {Boolean}         True if the element is a child of the popover
     */
    function contains(popover, element) {
        var result,
            elementToMatch = element;

        if (popover.contains(elementToMatch)) {
            result = true;
        } else {
            elementToMatch = ownerComponentFromPopover(popover, element);
            result = elementToMatch ? popover.contains(elementToMatch) : false;
        }

        return result;
    }

    /**
     * Adds/removes connector element inside component, only if targetSelector matches a button element
     * @param {HTMLElement} component Where to add the element
     * @param {String} targetSelector The selector to position this component
     */
    function updateConnector(component, targetSelector) {
        var connector = component.querySelector('.connector'),
            target;

        if (targetSelector === '_previousSibling') {
            target = component.previousElementSibling;
        } else if (targetSelector !== '') {
            target = component.ownerDocument.querySelector(targetSelector);
        } else {
            target = component.target;
        }

        if (!target) {
            return;
        }

        if ((target.tagName === 'BUTTON' || target.tagName === 'A') && !target.classList.contains('no-connector')) {
            if (!connector) {
                connector = component.ownerDocument.createElement('div');
                connector.classList.add('connector');
                component.insertBefore(connector, component.firstChild);
            }
        } else if (connector) {
            component.removeChild(connector);
        }
    }

    HAPopover = classes.createObject(UIComponent, {

        init: function _() {
            _.super(this);

            this.setupProperties({
                /**
                 * The selector for the "target" or "trigger" element - the element that invokes the popover
                 * @type {String}
                 */
                targetSelector: {
                    default: '_previousSibling',
                    change: function(newValue) {
                        if (newValue === '_previousSibling') {
                            this._target = this.previousElementSibling;
                        }

                        updateConnector(this, newValue);
                    }
                }
            });
        },

        get openOrOpening() {
            return this.open || this.classList.contains('enter');
        },

        set section(content) {
            var connector = this.querySelector('.connector');

            while (this.firstChildElement) {
                this.removeChild(this.firstChildElement);
            }

            if (connector) {
                this.appendChild(connector);
            }

            this.appendChild(content);

            this._section = content;
        },

        get section() {
            return this._section;
        },

        get target() {
            var target = this._target;

            if (!target) {
                if (this.targetSelector === '_previousSibling') {
                    this._target = this.previousElementSibling;
                    target = this._target;
                } else {
                    target = this.ownerDocument.querySelector(this.targetSelector);
                }
            }

            return target;
        },

        set target(newTarget) {
            this._target = newTarget;

            updateConnector(this, this.targetSelector);
        },

        /**
         * Updates connector property if we are using cloneNode
         */
        postRender: function _() {
            _.super(this);

            /**
             * Flag to determine if component's first child tabbable element should get focus on show
             * Used usually when a popover is used as part of another component
             * @default false
             * @private
             * @type {Boolean}
             */
            this._noAutoFocusFirstTabbableElementOnShow = false;

            /**
             * Flag to determine if component should focus back on the last active element when closed
             * Used usually when a popover is used as part of another component
             * @default false
             * @private
             * @type {Boolean}
             */
            this._noAutoFocusLastActiveElementOnClose = false;

            /**
             * Flag to determine if the popover should close when blurred out
             * @default true
             * @private
             * @type {Boolean}
             */
            this._closeOnBlur = true;

            this.open = false;

            var content = this.querySelector('.connector') ? this.children[1] : this.children[0];

            if (content) {
                this._section = content;
            }

            this.tabIndex = -1;

            this.listenTo(this, 'blur', function(evt) {
                // only run blur handler if this._closeOnBlur is true
                /* istanbul ignore next */
                if (this._closeOnBlur) {
                    if (!evt.currentTarget.contains(evt.target)) {
                        utils.stopEvent(evt);
                    }
                    this._handleCloseOnBlur(this, evt.target);
                }
            }.bind(this), true);

            this.on('keydown', function(evt) {
                if (keys.ESCAPE === evt.keyCode) {
                    var component = utils.getComponentFromElement(evt.target, this.tagName);

                    if (component) {
                        component.close();
                    }
                    this.postHandleKeydown(component);
                }
            }.bind(this));

            var anim = utils.getAnimationEventNames();
            this.on(anim.animationend, function(evt) {
                // the animation event could be triggered by a child element. We only listen for the event
                // directly triggered on the current popover
                if (evt.target === this) {
                    _onAnimationEnd(evt.animationName, evt.target);
                }
            }.bind(this));
        },

        /**
         * Handler blur.
         * @param {HTMLElement} popover The current popover
         * @param {HTMLElement} target The target element user clicked that caused the blur
         */
        _handleCloseOnBlur: function(popover, target) {
            var activeElement,
                that = this;

            setTimeout(function() {
                activeElement = popover.ownerDocument.activeElement;
                // after a blur, if the activeElement is not in this popover then proceed to close
                // special case if the activeElement is a popover, see description in contains()
                if (!contains(popover, activeElement)) {
                    popover.close();

                    that.postHandleCloseOnBlur(popover, target);
                }
            }, 1);
        },

        /**
         * Post Handler blur.
         * This function is for the target component do some extra work with blur handle.
         */
        postHandleCloseOnBlur: function() {},

        /**
         * Post Keydown Handler.
         * This function is for the target component do some extra work with keydown handle.
         */
        postHandleKeydown: function() {},

        /**
         * Add listener for losing focus
         */
        attachedCallback: function() {
            updateConnector(this);
        },

        /**
         * Adds html content to the component
         * @param {HTMLElement} content Content to append to the popover
         * @deprecated
         */
        addContent: function(content) {
            this.section = content;
            console.warn('DEPRECATION WARNING: addContent method should not be used anymore. Use section property instead.');
        },

        /**
         * Saves properties on conf object as private properties. Saves last focus
         * Adds 'enter' and 'visible' classes to trigger show animation
         */
        show: function() {
            var hasPositionSet = this.className.indexOf('position-') > -1,
                resizeMethod,
                self = this;

            if (!this.target || this.classList.contains('visible')) {
                return;
            }

            if (hasPositionSet || popup.setPosition(this, this.target)) {
                resizeMethod = popup.installResizeMethod(this, this.target);

                this.on('close', function onClose(evt) {
                    self.off('close', onClose);
                    // close event could be triggered by a child element. We only listen for a close event
                    // directly triggered on the current popover
                    if (evt.target === this) {
                        popup.uninstallResizeMethod(resizeMethod);
                        popup.clearPosition(this);
                    }
                });

                this.lastFocus = this.ownerDocument.activeElement;
                this.classList.remove('leave');
                this.classList.add('enter');
                this.classList.add('visible');
                this.tabIndex = 0;
            }
        },

        /**
         * Adds 'leave' class to trigger close animation
         * @param {Boolean}  noAnimate indicates to force close popover without animation
         */
        close: function(noAnimate) {
            if (noAnimate) {
                _closePopover(this);
            } else {
                this.classList.add('leave');
            }
        },

        /**
         * Adds 'leave' class to trigger hide animation
         * @deprecated
         */
        hide: function() {
             this.close();
             console.warn('DEPRECATION WARNING: hide method should not be used anymore. Use close instead.');
         },

        /**
         * This method must be removed, once the hide method is also removed.
         */
        addEventListener: function _() {
              HTMLElement.prototype.addEventListener.apply(this, arguments);
              if (arguments[0] === 'hide') {
                  console.warn('DEPRECATION WARNING: The hide event is going to be deprecated. From now on, please use "close" instead.');
              }
          }
    });

    return register('ha-popover', HAPopover);
});

define('hui/popover-form',[
    'register-component/v2/register',
    'object-utils/classes',
    'register-component/v2/UIComponent',
    './core/contentNode',
    './core/a11y',
    './core/utils'
],
function(register, classes, UIComponent, contentNode, a11y, utils) {
    'use strict';

    function arrayOrNull(nodes) {
        return (Array.isArray(nodes) && nodes.length > 0) ?
            nodes :
            null;
    }

    var HAPopoverForm = classes.createObject(UIComponent, {

        init: function _() {
            _.super(this);

            this.setupProperties({
                /**
                 * Sets the selector that will hold the name of a new item
                 * (relevant to Form Popover from Select Drop Down to add a new item)
                 * @type {String}
                 */
                addNewNameSelector: {
                    default: '',
                    type: String
                }
            });

            this.tabIndex = -1;

            // Prevent the parent popover from being closed when there is another
            // popover open when this is shown.
            // @see https://jira.intuit.com/browse/HUI-3346
            if (this.parentNode && this.parentNode.tagName === 'HA-POPOVER') {
                this.parentNode._noAutoFocusLastActiveElementOnClose = true;
            }

            this.on('keydown', function(evt) {
                a11y.keepFocusInsideListener(evt, this);
            });
        },

        /**
         * Returns the element or an array of elements inside the section
         * @return {HTMLElement|[HTMLElement]} Element or HTMLCollection of elements
         */
        get section() {
            var sectionNode = utils.queryChildOf(this, 'section'),
                sectionChildren = utils.arrayOfChildrenFrom(sectionNode);

            return arrayOrNull(sectionChildren);
        },

        set section(newSection) {
            var section = utils.queryChildOf(this, 'section');

            utils.replaceChildrenOf(section, newSection);
        },

        /**
         * Returns the element or an array of elements inside the footer
         * @return {HTMLElement|[HTMLElement]} Element or HTMLCollection of elements
         */
        get footer() {
            var footerNode = utils.queryChildOf(this, 'footer'),
                footerChildren = utils.arrayOfChildrenFrom(footerNode);

            return arrayOrNull(footerChildren);
        },

        set footer(newFooter) {
            var footer = utils.queryChildOf(this, 'footer');

            utils.removeAllChildrenFrom(footer);
            utils.replaceChildrenOf(footer, newFooter);
        },

        postRender: function _() {
            var section, footer;

            _.super(this);

            // cache input
            section = utils.queryChildOf(this, 'section') || this.ownerDocument.createElement('section');
            footer = utils.queryChildOf(this, 'footer') || this.ownerDocument.createElement('footer');

            // destroy children
            utils.removeAllChildrenFrom(this);

            // render "template"
            utils.appendChildren(this, [
                section,
                footer
            ]);
        },

        /**
         * Adds content to the component
         * @param       {object} config Mapping between HTML and properties
         * @deprecated                  Properties should be used directly instead
         */
        addContent: function(config) {
            var contentPropertyMap = {
                    'section': 'section',
                    'footer': 'footer'
                };

            contentNode.addContent(this, config, contentPropertyMap);
            console.warn('DEPRECATION WARNING: addContent method should not be used anymore. Use section or footer property instead.');
        }
    });

    return register('ha-popover-form', HAPopoverForm);
});

define('hui/textarea',[
    'register-component/v2/register',
    './validatable/validatable',
    './core/deviceUtils',
    './core/utils',
    'object-utils/classes'
], function(register, Validatable, deviceUtils, utils, classes) {

    /*
    * Determine whether we should show the required * or not
    * If we are given a newValue overwrite the old label string/DOM with it
    * Else reursivly search the label's DOM till we find the last word and manipulate it
    * @param  {String} optional if you want to replace your label string and test showing the required indicator
    */
    function handleRequiredIndicator(component, newValue) {
        var label = component.querySelector('label'),
            lastString;

        // recursivle walk through the label DOM to find the last work
        function walkLabelDOM(node) {
            if (node.nodeType === 3 && node.textContent.trim() !== '') {
                lastString = node;
            }
            node = node.firstChild;
            while (node) {
                walkLabelDOM(node);
                node = node.nextSibling;
            }
        }

        if (label) {
            if (newValue) {
                // overwrite old label with newValue, toggle * if needed
                label.textContent = utils.toggleSuffixText(newValue, ' *', component.required && !component.noRequiredIndicator);
            } else {
                // start recursion
                walkLabelDOM(label);
                if (lastString) {
                    // if we found the last work in the label DOM, toggle * if needed
                    lastString.textContent = utils.toggleSuffixText(lastString.textContent, ' *', component.required && !component.noRequiredIndicator);
                }
            }
        }
    }

    function passthrough(component, propertyName) {
        return function(value) {
            component._inputElement[propertyName] = value;
        };
    }
    var HATextarea = classes.createObject(Validatable, /** @lends HATextarea# */ {

        /** @constructs */
        init: function _() {

            _.super(this);

            // Flag to check if validation-related event listeners were already added to component
            this._validationListenersAdded = false;

            this._label = '';

            this._validator = null;

            this._customValidatorFunction = null;

            /**
             * The selector for the elements to highlight if an error is detected
             * @type {String}
             */
            this.highlightElementSelector = 'textarea';

            this.setupProperties(/** @lends HATextarea# */ {
                /**
                 * The visible width of the component, in average character widths
                 * @type {number}
                 * @default 20
                 */
                cols: {
                    type: Number,
                    default: 20,
                    change: passthrough(this, 'cols')
                },
                /**
                 * If true, the component is disabled in the UI
                 * @type {boolean}
                 */
                disabled: {
                    type: Boolean,
                    change: function(newValue) {
                        this._inputElement.disabled = newValue;

                        if (newValue) {
                            this.classList.add('disabled');
                        } else {
                            this.classList.remove('disabled');
                        }
                    }
                },
                /**
                 * Extra text to display in label if the value is optional
                 * @type {string}
                 * @default optional
                 */
                labelOptional: {
                    default: 'optional',
                    change: function(newValue) {
                        var labelOptional = this.querySelector('.optional');

                        if (this.optional && labelOptional) {
                            labelOptional.innerHTML = ' ' + newValue;
                        }
                    }
                },
                /**
                 * The maximum number of characters that the user can enter
                 * @type {number}
                 * @default 524288
                 */
                maxLength: {
                    default: 524288,
                    type: Number,
                    change: passthrough(this, 'maxLength')
                },
                /**
                 * The minimum number of characters that the user can enter
                 * @type {number}
                 * @default 0
                 */
                minLength: {
                    default: 0,
                    type: Number,
                    change: passthrough(this, 'minLength')
                },
                /**
                 * Name for the component
                 * @type {string}
                 */
                name: {
                    default: '',
                    type: String,
                    change: function(newValue) {
                        if (newValue) {
                            this._inputElement.name = newValue;
                        } else {
                            this._inputElement.removeAttribute('name');
                        }
                    }
                },
                /**
                 * Indicates whether the value is optional
                 * @type {boolean}
                 * @default false
                 */
                optional: {
                    default: false,
                    type: Boolean,
                    change: function(newValue) {
                        var spanOptional,
                            label = this.querySelector('label');

                        if (label) {
                            spanOptional = label.querySelector('span.optional');

                            if (newValue) {
                                if (!spanOptional) {
                                    spanOptional = this.ownerDocument.createElement('span');
                                    spanOptional.className = 'optional';
                                    label.appendChild(spanOptional);
                                }

                                spanOptional.innerHTML = ' ' + this.labelOptional;
                            } else {
                                if (spanOptional) {
                                    label.removeChild(spanOptional);
                                }
                            }
                        }
                    }
                },
                /**
                 * Regular expression pattern for validation
                 * @type {string}
                 */
                pattern: {
                    default: '',
                    change: function(newValue) {
                        if (newValue) {
                            _addValidationListeners(this);
                        } else {
                            _removeValidationListeners(this);
                        }
                    }
                },
                /**
                 * Placeholder text to display when no value is specified
                 * @type {string}
                 */
                placeholder: {
                    default: '',
                    type: String,
                    change: function(newValue) {
                        var textarea = this._inputElement;

                        textarea.placeholder = newValue;

                        if (!this.label) {
                            textarea.setAttribute('aria-label', newValue);
                        }
                    }
                },
                /**
                 * If true the value cannot be edited in the UI
                 * @type {boolean}
                 */
                readOnly: {
                    type: Boolean,
                    change: passthrough(this, 'readOnly')
                },
                /**
                 * noRequiredIndicator indicates whether '*' should be
                 * appended to the label when the field is required
                 * @type {Boolean}
                 */
                noRequiredIndicator: {
                    default: false,
                    type: Boolean,
                    change: function(newValue, oldValue) {
                        if (newValue !== oldValue) {
                            handleRequiredIndicator(this);
                        }
                    }
                },
                /**
                 * Indicates whether the value is required
                 * @type {boolean}
                 * @default false
                 */
                required: {
                    default: false,
                    type: Boolean,
                    change: function(newValue, oldValue) {
                        var textarea = this._inputElement;

                        if (newValue !== oldValue) {
                            handleRequiredIndicator(this);

                            if (newValue) {
                                _addValidationListeners(this, textarea);
                            } else {
                                _removeValidationListeners(this, textarea);
                            }
                            textarea.required = newValue;
                            textarea.setAttribute('aria-required', newValue);
                        }
                    }
                },
                /**
                 * The number of visible text lines for the component
                 * @type {number}
                 * @default 2
                 */
                rows: {
                    type: Number,
                    default: 2,
                    change: passthrough(this, 'rows')
                },
                /**
                 * @property value Value for the component
                 * @type {string}
                 */
                value: {
                    type: String,
                    default: '',
                    change: function(value) {
                        var textarea = this._inputElement,
                            textareaStyles,
                            div;
                        textarea.value = value;

                        if (!value) {
                            this.classList.remove('mobile-textarea-content');
                            this._previousHeight = '';
                        } else {
                            this.classList.add('mobile-textarea-content');
                            if ((deviceUtils.isHandheld())) {
                                textareaStyles = getComputedStyle(textarea);
                                div = this.ownerDocument.createElement('div');
                                div.style.fontSize = textareaStyles.fontSize;
                                div.style.whiteSpace = 'pre-wrap';
                                div.style.wordBreak = 'break-all';
                                div.style.fontFamily = textareaStyles.fontFamily;
                                div.style.width = textareaStyles.width;
                                div.style.maxHeight = this.mobileMaxHeight + 'px';
                                div.style.position = 'absolute';
                                div.style.top = '-' + (this.mobileMaxHeight + 10) + 'px';
                                div.style.left = '-' + (parseInt(textareaStyles.width) + 10) + 'px';
                                div.textContent = value.indexOf('\n') === value.length - 1 ? (value + '_') : value;
                                this.ownerDocument.body.appendChild(div);
                                // Get the height. Add 15 px to the offsetHeight of the div to account for padding
                                this._previousHeight = Math.min(this.mobileMaxHeight, div.offsetHeight + 15) + 'px';
                                this.ownerDocument.body.removeChild(div);
                            }
                        }
                        this._resize();
                    }
                },

                /**
                 * Value specifying the maximum height this component's text area can expand to to display text content.
                 * This will also be the size the textarea expands to when it is focused. This must be set programmatically
                 * Because the textarea expands with content the height must be set programmatically. The height is
                 * in pixels
                 * @type {number}
                 * @default 80
                 */
                mobileMaxHeight: {
                    type: Number,
                    default: 80,
                    change: function() {
                        // expand to the correct height
                        this._resize();
                    }
                }
            });

            // @FIXME We need to reset this object for every instance.
            // It seems that the extend function makes the parent properties
            // work as static properties. Some research is needed here.
            this._validationData = {};
        },

        postRender: function _() {
            _.super(this);

            var textarea = this._inputElement,
                haLabel = this.querySelector('ha-label'),
                valueAttribute = this.getAttribute('value'),
                notDesktop = deviceUtils.isHandheld(),
                labelAttributeValue;

            this._notDesktop = notDesktop;
            if (!textarea) {
                textarea = this.ownerDocument.createElement('textarea');
                textarea.className = 'ha-input';
                this.appendChild(textarea);
            }
            this._resize();
            textarea.id = 'ha-textarea-' + this.componentId;
            this.validationTarget = this;

            if (valueAttribute) {
                this.value = valueAttribute;

                if (notDesktop) {
                    this.classList.add('mobile-textarea-content');
                }
            }

            if (notDesktop) {
                this.style.paddingTop  = (40 + this.mobileMaxHeight) + 'px';
                this.style.height = (58 + this.mobileMaxHeight) + 'px';

                this.classList.add('mobile-textarea');

                // Only add immediate focus utils if iOS 9
                deviceUtils.addiOS9ImmediateFocus();

                // In total the HATextarea should take up
                this.listenTo(textarea, 'focus', function() {
                    this.classList.add('mobile-textarea-focused');
                    this._resize();
                }.bind(this));

                this.listenTo(textarea, 'blur', function() {
                    this.classList.remove('mobile-textarea-focused');
                    if (this.checkValidity()) {
                        this._resize();
                    }
                }.bind(this));
            }

            labelAttributeValue = this.getAttribute('label');
            if (!haLabel) {
                if (labelAttributeValue) {
                    // lets sync the attribute "label" to the component "label" property which then sets to the local input
                    this.label = labelAttributeValue;
                }
            } else {
                this.label = Array.prototype.slice.call(haLabel.childNodes);
            }

            this.listenTo(textarea, 'change', function(event) {
                event.stopPropagation();

                if (notDesktop) {
                    if (this.value) {
                        this.classList.add('mobile-textarea-content');
                    } else {
                        this.classList.remove('mobile-textarea-content');
                    }
                }

                this.emit('change');
            }.bind(this));

            this.listenTo(textarea, 'input', function(event) {
                event.stopPropagation();
                this.value = event.target.value;
                this.emit('input');
            }.bind(this));

            this.listenTo(textarea, 'invalid', function(evt) {
                // stop default messages
                evt.preventDefault();
            });
        },

        attachedCallback: function() {
            // Reset the value after any inherited styles are applied, because
            // we need to calculate the size again.
            var value = this.value;
            this.value = '';
            this.value = value;
        },

        get validator() {
            return this._customValidatorFunction;
        },

        set validator(newValue) {
            if (newValue && newValue !== this.validator) {
                this._customValidatorFunction = newValue;
                _addValidationListeners(this);
            } else if (!newValue) {
                this._customValidatorFunction = null;
                _removeValidationListeners(this);
            }
        },

        get _inputElement() {
            return this.querySelector('textarea');
        },

        set label(newValue) {
            var input = this._inputElement,
                label = this.querySelector('label'),
                haLabel = this.querySelector('ha-label'),
                isNode;

            if (newValue) {
                isNode = Array.isArray(newValue) || newValue.nodeType === 1;
                if (typeof newValue === 'string') {
                    // if ha-label left from element value, remove <ha-label>
                    if (haLabel) {
                        this.removeChild(haLabel);
                        // recheck label existance because it may have been removed with ha-label
                        label = this.querySelector('label');
                    }

                    // if no label element create it and add it to text-field
                    if (!label) {
                        label = this.ownerDocument.createElement('label');
                        this.insertBefore(label, input);
                    }
                    label.htmlFor = input.id;
                    // toggle * if needed, and add label text to label element
                    handleRequiredIndicator(this, newValue);

                    // sync label attribute
                    this.setAttribute('label', newValue);
                } else if (isNode) {
                    // remove label attribute first
                    if (this.hasAttribute('label')) {
                        this.removeAttribute('label');
                    }

                    label = this.querySelector('label');
                    // if label left inside <ha-label> remove <ha-label>, else remove <label>
                    if (label && !haLabel) {
                        this.removeChild(label);
                    } else if (haLabel) {
                        this.removeChild(haLabel);
                    }

                    label = this.ownerDocument.createElement('label');
                    haLabel = this.ownerDocument.createElement('ha-label');
                    newValue = Array.isArray(newValue) ? newValue : [newValue];

                    newValue.forEach(function(node) {
                        label.appendChild(node);
                    });

                    haLabel.appendChild(label);
                    this.insertBefore(haLabel, this.firstElementChild);

                    // toggle * if needed
                    handleRequiredIndicator(this);
                }
                // make sure we don't have aria-label since we have label
                if (input.hasAttribute('aria-label')) {
                    input.removeAttribute('aria-label');
                }
            } else {
                // if falsy empty string, null or undefined

                // remove label attribute
                if (this.hasAttribute('label')) {
                    this.removeAttribute('label');
                }

                label = this.querySelector('label');
                haLabel = this.querySelector('ha-label');

                // remove <ha-label> if it exists
                if (haLabel) {
                    this.removeChild(haLabel);
                } else if (label) {  // otherwise just remove <label>
                    this.removeChild(label);
                }

                // if we don't have a label and we have a placeholder, set aria-label
                if (input.placeholder) {
                    input.setAttribute('aria-label', input.placeholder);
                }
            }

            this._label = newValue;
        },

        get label() {
            return this._label;
        },

        attributeChangedCallback: function _(attrName, oldValue, newValue) {
            // happens when we modify the attribute via browser inspector or via setAttribute
            if (attrName === 'label') {
                // call the label setter which handles the logic
                this.label = newValue;
            } else {
                _.super(this, attrName, oldValue, newValue);
            }
        },

        /**
         * Search in the target defined the component that will check the validity.
         * @param {Event} event
         * @private
         */
        _reportValidity: function(event) {
            var textField = utils.getComponentFromElement(event.target, this.tagName);
            if (textField) {
                textField.reportValidity(event);
            }
        },

        /**
         * Set the height of the component, its padding, and the height of the inner text textarea
         * based on its current contents, its focused state, and the `mobileMaxHeight` property
         */
        _resize: function() {
            if (this._notDesktop) {
                this.style.height = (58 + this.mobileMaxHeight) + 'px';
                if (this.classList.contains('mobile-textarea-focused')) {
                    this.querySelector('textarea').style.height = this.mobileMaxHeight + 'px';
                    this.style.paddingTop = 40 + 'px';
                } else {
                    this.style.paddingTop =
                        ((40 + this.mobileMaxHeight) - Number((this._previousHeight ||  '').split('px')[0])) + 'px';
                    this.querySelector('textarea').style.height = this._previousHeight;
                }
            }
        }
    });

    /**
     * Add the events listener needed for the component
     * @param {HTMLElement} component context defined
     * @private
     */
    function _addValidationListeners(component) {
        var input = component._inputElement;
        if (!component._validationListenersAdded) {
            component._boundValidator = component._reportValidity.bind(component);
            component.listenTo(input, 'mouseenter', component._boundValidator);
            component.listenTo(input, 'mouseout', component._boundValidator);
            component.listenTo(input, 'focus', component._boundValidator);
            component.listenTo(input, 'blur', component._boundValidator);
            component.listenTo(input, 'keyup', component._boundValidator);
            component.listenTo(component, '.ha-icon-alert:mouseover', component._boundValidator);
            component.listenTo(component, '.ha-icon-alert:mouseout', component._boundValidator);
            component.classList.add('ha-validatable');
            component._validationListenersAdded = true;
        }
    }

    /**
     * Remove all the events listener for the component.
     * @param {HTMLElement} component context defined
     * @private
     */
    function _removeValidationListeners(component) {
        var input = component._inputElement;
        if (!utils.validationRequired(component) && component._validationListenersAdded) {
            component.stopListening(input, 'mouseenter', component._boundValidator);
            component.stopListening(input, 'mouseout', component._boundValidator);
            component.stopListening(input, 'focus', component._boundValidator);
            component.stopListening(input, 'blur', component._boundValidator);
            component.stopListening(input, 'keyup', component._boundValidator);
            component.stopListening(component, '.ha-icon-alert:mouseover', component._boundValidator);
            component.stopListening(component, '.ha-icon-alert:mouseout', component._boundValidator);
            component.classList.remove('ha-validatable');
            component._validationListenersAdded = false;
        }
    }

    return register('ha-textarea', HATextarea);
});

define('hui/core/icon',{
    onChangeIconProperty: function(newValue) {
        if (this._textField) {
            this._textField.icon = newValue;

            if (!newValue) {
                this.removeAttribute('icon');
            }

            return;
        }

        var icon = this.querySelector('i');

        if (!newValue) {
            if (icon) {
                icon.parentNode.removeChild(icon);
            }

            this.removeAttribute('icon');
        } else {
            if (!icon) {
                icon = this.ownerDocument.createElement('i');

                switch (this.tagName.toLowerCase()) {
                    case 'ha-select':
                        this.querySelector('button').appendChild(icon);
                        break;

                    case 'ha-text-field':
                        this.insertBefore(icon, this.querySelector('input'));
                        break;

                    default:
                        throw new Error('Embedded icon not implemented for ' + this.tagName);
                }
            }

            icon.className = 'hi embedded ' + newValue;
        }
    }
});

define('hui/text-field',[
    'register-component/v2/register',
    './validatable/validatable',
    './core/icon',
    './core/utils',
    './core/deviceUtils',
    './core/keys',
    'object-utils/classes'
], function(register, Validatable, icon, utils, deviceUtils, keys, classes) {
    /*
    * Determine whether we should show the required * or not
    * If we are given a newValue, overwrite the old label string/DOM with it
    * Else recursively search the label's DOM until we find the last word and manipulate it
    * @param  {String} optional if you want to replace your label string and test showing the required indicator
    */
    function handleRequiredIndicator(component, newValue) {
        var label = component.querySelector('label'),
            lastString;

        // recursively walk through the label DOM to find the last work
        function walkLabelDOM(node) {
            if (node.nodeType === 3 && node.textContent.trim() !== '') {
                lastString = node;
            }
            node = node.firstChild;
            while (node) {
                walkLabelDOM(node);
                node = node.nextSibling;
            }
        }

        if (label) {
            if (newValue) {
                // overwrite old label with newValue, toggle * if needed
                label.textContent = utils.toggleSuffixText(newValue, ' *', component.required && !component.noRequiredIndicator);
            } else {
                // start recursion
                walkLabelDOM(label);
                if (lastString) {
                    // if we found the last work in the label DOM, toggle * if needed
                    lastString.textContent = utils.toggleSuffixText(lastString.textContent, ' *', component.required && !component.noRequiredIndicator);
                }
            }
        }
    }

    /**
     * Returns true if the component has an active validation
     * @param  {HTMLElement} component The textfield
     * @return {Boolean}     true if there's at least an active validation
     */
    function validationActive(component) {
        return component.required || !!component.max || !!component.min || !!component.pattern || !!component.minLength || !!component.validator;
    }

    function onChangeMaxMin(newValue, oldValue) {
        if (newValue !== oldValue) {
            this.handleTooltipBinding(validationActive(this));
        }
    }

    var HATextField = classes.createObject(Validatable, {

        init: function _() {

            _.super(this);

            /**
             * Flag to check if listeners were already added to component
             * @type {Boolean}
             */
            this._validationListenersAdded = false;

            this._label = null;

            /**
             * The element that the validator will use to get the values to validate
             * @type {HTMLElement}
             */
            this.validationTarget = this;

            /**
             * The selector for the elements to highlight if an error is detected
             * @type {String}
             */
            this.highlightElementSelector = 'input';

            this._customValidatorFunction = null;

            /**
             * An array of the component's supported classes - these
             * should not be overwritten during any props change to the
             * React component. They were determined by grepping classList.add()
             * and classList.remove() for this component.
             *
             * Please see updateClassWithProps() of utils.js for more information.
             * @type{Array}
             */
            this.supportedClasses = [
                'mobile-text-field',
                'mobile-text-field-focused',
                'mobile-text-field-attachment-focused',
                'mobile-text-field-show-placeholder',
                'mobile-text-field-content',
                'disabled',
                'ha-validatable'
            ];

            this.setupProperties({
                optional: {
                    default: false,
                    type: Boolean,
                    change: function(newValue) {
                        if (newValue) {
                            this.required = false;
                        }
                        var spanOptional,
                            label = this.querySelector('label');

                        if (label) {
                            spanOptional = label.querySelector('span.optional');

                            if (newValue) {
                                if (!spanOptional) {
                                    spanOptional = this.ownerDocument.createElement('span');
                                    spanOptional.className = 'optional';
                                    label.appendChild(spanOptional);
                                    spanOptional.innerHTML = ' ' + this.labelOptional;
                                }
                            } else {
                                if (spanOptional) {
                                    label.removeChild(spanOptional);
                                }
                            }
                        }
                    }
                },

                /**
                 * Declares the text that will be used to describe optional fields
                 * @type {String}
                 */
                labelOptional: {
                    default: 'optional',
                    change: function(newValue) {
                        var labelOptional = this.querySelector('.optional');

                        if (this.optional && labelOptional) {
                            labelOptional.innerHTML = ' ' + newValue;
                        }
                    }
                },

                /**
                 * Sets the name for the text input
                 * @type {String}
                 */
                name: {
                    default: '',
                    change: function(newValue) {
                        var input = this.querySelector('input'),
                            fileInput = this.querySelector('input[type="file"]');

                        if (newValue) {
                            if (fileInput) {
                                fileInput.name = newValue;
                                input.removeAttribute('name');
                            } else {
                                input.name = newValue;
                            }
                        } else {
                            input.removeAttribute('name');
                            if (fileInput) {
                                fileInput.removeAttribute('name');
                            }
                        }
                    }
                },

                /**
                 * Sets the autoComplete for the text input
                 * @type {String}
                 */
                autoComplete: {
                    default: 'on',
                    change: function(newValue) {
                        this.querySelector('input').autocomplete = newValue;
                    }
                },

                /**
                 * Sets the size for the text input
                 * @type {Number}
                 */
                size: {
                    default: 20,
                    type: Number,
                    change: function(newValue) {
                        this.querySelector('input').size = newValue;
                    }
                },

                /**
                 * Placeholder for the text-field control
                 * @type {String}
                 */
                placeholder: {
                    default: '',
                    change: function(newValue) {
                        var input = this.querySelector('input');

                        input.placeholder = newValue;

                        if (!this.label) {
                            if (!this.ariaLabel) {
                                input.setAttribute('aria-label', newValue);
                            }
                        }

                        // clean up attributes
                        if (!newValue) {
                            if (input.hasAttribute('aria-label')) {
                                input.removeAttribute('aria-label');
                            }
                            if (input.hasAttribute('placeholder')) {
                                input.removeAttribute('placeholder');
                            }
                        }
                    }
                },

                /**
                 * The name of a Harmony icon to display within the component
                 * @type {string}
                 */
                icon: {
                    default: '',
                    type: String,
                    change: icon.onChangeIconProperty
                },

                /**
                 * Disabled indicates whether the field is disabled
                 * @type {Boolean}
                 */
                disabled: {
                    default: false,
                    type: Boolean,
                    change: function(newValue) {
                        this.querySelector('input').disabled = newValue;

                        if (newValue) {
                            this.classList.add('disabled');
                        } else {
                            this.classList.remove('disabled');
                        }
                    }
                },

                /**
                 * noRequiredIndicator indicates whether '*' should be
                 * appended to the label when the field is required
                 * @type {Boolean}
                 */
                noRequiredIndicator: {
                    default: false,
                    type: Boolean,
                    change: function(newValue, oldValue) {
                        if (newValue !== oldValue) {
                            handleRequiredIndicator(this);
                        }
                    }
                },

                /**
                 * required indicates whether the field is optional
                 * @type {Boolean}
                 */
                required: {
                    default: false,
                    type: Boolean,
                    change: function(newValue, oldValue) {
                        var input = this.querySelector('input');

                        if (newValue) {
                            this.optional = false;
                        }
                        if (newValue !== oldValue) {
                            handleRequiredIndicator(this);

                            if (newValue) {
                                _addValidationListeners(this, input);
                            } else {
                                _removeValidationListeners(this, input);
                            }
                            this.handleTooltipBinding(validationActive(this));

                            input.required = newValue;
                            input.setAttribute('aria-required', newValue);
                        }
                    }
                },

                /**
                 * Specifies the maximum number of characters that the user can enter
                 * @type {Number}
                 */
                maxLength: {
                    default: 524288,
                    type: Number,
                    change: function(newValue) {
                        this.querySelector('input').maxLength = newValue;
                    }
                },

                /**
                 * Specifies the minimum length required for the field to verify
                 * @type {Number}
                 */
                minLength: {
                    default: 0,
                    type: Number,
                    change: function(newValue) {
                        var input = this.querySelector('input');

                        if (newValue) {
                            input.minLength = newValue;
                            input.setAttribute('minLength', newValue);
                            _addValidationListeners(this, input);
                        } else {
                            input.removeAttribute('minLength');
                            input.minLength = 0;
                            _removeValidationListeners(this, input);
                        }
                    }
                },

                /**
                 * Specifies the pattern the value should match
                 * @type {String}
                 */
                pattern: {
                    default: '',
                    change: function(newValue) {
                        var input = this.querySelector('input');

                        if (newValue) {
                            input.pattern = newValue;
                            _addValidationListeners(this, input);
                        } else {
                            input.removeAttribute('pattern');
                            _removeValidationListeners(this, input);
                        }
                    }
                },

                min: {
                    change: this._onChangeMin
                },

                max: {
                    change: this._onChangeMax
                },

                /**
                 * Specifies the height of this component's input element in pixels
                 * @type {number}
                 * @default 34
                 */
                mobileMaxHeight: {
                    type: Number,
                    default: 34,
                    change: function(newValue) {
                        if (deviceUtils.isHandheld()) {
                            if (this.classList.contains('mobile-text-field-focused')) {
                                this._inputElement.style.height = newValue + 'px';
                            } else {
                                if (this.value) {
                                    this._previousHeight = Math.min(this.mobileMaxHeight, this._getDefaultHeight(this.value) + 15) + 'px';
                                }

                                this._inputElement.style.height = this._previousHeight || '';
                            }
                        }
                    }
                },

                attachment: {
                    type: Boolean,
                    change: function(newValue) {
                        if (newValue) {
                            this._setUpAttachmentField();
                        } else {
                            this._removeAttachmentField();
                        }
                    }
                },

                type: {
                    type: String,
                    default: 'text',
                    change: function(newValue) {
                        var input = this.querySelector('input');

                        if (!this.attachment) {
                            input.setAttribute('type', newValue ? newValue : 'text');
                        }
                    }
                },

                /**
                 * This is the arialabel property for the ha-text-field.
                 * ariaLabel takes precedence over label property at any time.
                 * @type {String}
                 */
                ariaLabel: {
                    default: '',
                    change: function(newValue) {
                        var textFieldChildInput = this.querySelector('input');
                        if (textFieldChildInput) {
                            if (newValue) {
                                textFieldChildInput.setAttribute('aria-label', newValue);
                            } else {
                                if (!textFieldChildInput.placeholder) {
                                    textFieldChildInput.removeAttribute('aria-label');
                                }
                            }
                        }
                    }
                }
            });

            // @FIXME We need to reset this object for every instance.
            // It seems that the extend function makes the parent properties
            // work as static properties. Some research is needed here.
            this._validationData = {};

        },

        postRender: function _() {
            _.super(this);

            var input = this.querySelector('input'),
                haLabel = this.querySelector('ha-label'),
                attributeValue,
                labelAttributeValue;

            if (!input) {
                input = this.ownerDocument.createElement('input');
                input.className = 'ha-input';
                this.appendChild(input);
            }

            if (deviceUtils.isHandheld()) {
                this.classList.add('mobile-text-field');

                // Only add immediate focus utils if iOS 9
                deviceUtils.addiOS9ImmediateFocus();

                this.listenTo(input, 'focus', function() {
                    this.classList.add('mobile-text-field-focused');
                    input.style.height = this.mobileMaxHeight + 'px';
                }.bind(this));

                this.listenTo(input, 'blur', function() {
                    this.classList.remove('mobile-text-field-focused');
                    input.style.height = this._previousHeight || '';
                }.bind(this));
            }

            input.id = 'ha-text-field-' + this.componentId;
            this.highlightElement = input;

            // if declarative instantiation has an attribute, sync to the this.value
            attributeValue = this.getAttribute('value');
            if (attributeValue) {
                // lets sync the attribute "value" to the component "value" property which then sets to the local input
                this.value = attributeValue;
                if (deviceUtils.isHandheld()) {
                    this.classList.add('mobile-text-field-content');
                }
            }

            labelAttributeValue = this.getAttribute('label');
            if (!haLabel) {
                if (labelAttributeValue) {
                    // lets sync the attribute "label" to the component "label" property which then sets to the local input
                    this.label = labelAttributeValue;
                }
            } else {
                this.label = Array.prototype.slice.call(haLabel.childNodes);
            }

            // this assures while typing, the local input.value is copied to the host this.value
            this.listenTo(input, 'input', function(evt) {
                evt.stopPropagation();
                this.value = evt.target.value;
                // this makes sure the evt.target is the host component
                this.emit('input');
            }.bind(this));

            //This event listeners are created for preventing the change and click events to bubble up.
            this.listenTo(input, 'change', function(evt) {
                evt.stopPropagation();
                // this makes sure the evt.target is the host component
                if (this.value && deviceUtils.isHandheld()) {
                    this.classList.add('mobile-text-field-content');
                } else {
                    this.classList.remove('mobile-text-field-content');
                }
                this.emit('change');
            }.bind(this));

            this.listenTo(input, 'blur', function() {
                this.emit('blur');
            }.bind(this));

            this.listenTo(input, 'focus', function() {
                this.emit('focus');
            }.bind(this));

            this.listenTo(input, 'invalid', function(evt) {
                // stop default messages
                evt.preventDefault();
            });

            this.listenTo(input, 'click', function(evt) {
                var fileInput = this.querySelector('input[type="file"]');
                if (fileInput) {
                    evt.preventDefault();
                    evt.stopPropagation();
                    fileInput.click();
                }
            }.bind(this));

            this.listenTo(this, 'input[type="file"]:change', function(evt) {
                var fullPath = evt.target.value,
                    startIndex,
                    filename;
                if (fullPath) {
                    startIndex = (fullPath.indexOf('\\') >= 0 ? fullPath.lastIndexOf('\\') : fullPath.lastIndexOf('/'));
                    filename = fullPath.substring(startIndex);
                    if (filename.indexOf('\\') === 0 || filename.indexOf('/') === 0) {
                        filename = filename.substring(1);
                    }
                    input.value = filename;
                    if (deviceUtils.isHandheld()) {
                        this.classList.add('mobile-text-field-content');
                    }
                }
            }.bind(this));

            this.listenTo(input, 'keydown', function(evt) {
                if (this.attachment) {
                    evt.preventDefault();
                    if (evt.keyCode === keys.BACKSPACE || evt.keyCode === keys.DELETE) {
                        input.value = '';
                        this.classList.remove('mobile-text-field-content');
                        var fileInput = this.querySelector('input[type="file"]'),
                            clone,
                            parent;
                        if (fileInput) {
                            clone = fileInput.cloneNode(true);
                            parent = fileInput.parentNode;
                            parent.removeChild(fileInput);
                            parent.appendChild(clone);
                        }
                    }
                }
            }.bind(this));

            this._setUpMobileListeners();
            // This is separate because date-picker needs unique logic
            this.listenTo(input, 'blur', function() {
                this.classList.remove('mobile-text-field-focused');
                this.classList.remove('mobile-text-field-attachment-focused');
                this.classList.remove('mobile-text-field-show-placeholder');
            }.bind(this));
        },

        /**
         * This is exposed as a protected method so that sub-classes can extend it
         * @protected
         */
        _onChangeMax: onChangeMaxMin,

        /**
         * This is exposed as a protected method so that sub-classes can extend it
         * @protected
         */
        _onChangeMin: onChangeMaxMin,

        /**
         * Search in the target defined the component that will check the validity.
         * @argument {Event} event
         * @private
         */
        _reportValidity: function(event) {
            var textField = utils.getComponentFromElement(event.target, this.tagName);
            if (textField) {
                textField.reportValidity(event);
            }
        },

        startValidation: function() {
            _addValidationListeners(this);
        },

        stopValidation: function() {
            _removeValidationListeners(this);
        },

        /**
         * Reusable function for setting up mobile listeners. It's directly
         * called in this class, but subclasses(e.g date-picker) may not want
         * all of the events in this class but may still want mobile events.
         * @private
         */
        _setUpMobileListeners: function() {
            var input = this.querySelector('input');
            this.listenTo(input, 'focus', function() {
                if (deviceUtils.isHandheld()) {
                    if (!this.attachment) {
                        this.classList.add('mobile-text-field-focused');
                        input.style.height = '34px';
                    } else {
                        this.classList.add('mobile-text-field-attachment-focused');
                    }
                }
            }.bind(this));

            this.listenTo(input, 'blur', function() {
                if (deviceUtils.isHandheld()) {
                    if (!this.attachment) {
                        this.classList.remove('mobile-text-field-focused');
                        input.style.height = this._previousHeight || '';
                    } else {
                        this.classList.remove('mobile-text-field-attachment-focused');
                    }
                }
            }.bind(this));
        },

        _removeAttachmentField: function() {
            var fileInput = this.querySelector('input[type="file"]'),
                inputParent,
                input = this.querySelector('input'),
                label = this.querySelector('label'),
                name = this.name;
            if (fileInput) {
                if (this.icon === 'hi-attach') {
                    this.icon = '';
                }
                inputParent = fileInput.parentNode;
                inputParent.parentNode.removeChild(inputParent);
            }
            if (input) {
                input.removeAttribute('aria-hidden');
            }
            if (label) {
                label.removeAttribute('aria-hidden');
            }
            // Reset name to switch it to the appropriate input
            this.name = '';
            this.name = name;
        },

        _setUpAttachmentField: function() {
            var fileInput,
                fileInputLabel,
                fileInputId,
                inputParent,
                name = this.name,
                input,
                label,
                icon;

            fileInput = this.querySelector('input[type="file"]');
            if (fileInput) {
                fileInput.parentNode.parentNode.removeChild(fileInput.parentNode);
            }
            if (this.icon !== 'hi-attach') {
                this.icon = 'hi-attach';
            }
            input = this.querySelector('input');
            label = this.querySelector('label');
            fileInputId = input.id + '-file-upload';
            icon = this.querySelector('.hi-attach');

            // Hide existing content from screen reader
            if (label) {
                label.setAttribute('aria-hidden', 'true');
            }
            input.setAttribute('aria-hidden', 'true');
            icon.setAttribute('aria-hidden', 'true');

            fileInput = document.createElement('input');
            fileInput.setAttribute('type', 'file');
            fileInput.setAttribute('id', fileInputId);

            inputParent = document.createElement('div');
            inputParent.classList.add('ha-textfield-file-input-container');
            inputParent.classList.add('sr-only');
            if (label) {
                fileInputLabel = document.createElement('label');
                fileInputLabel.innerHTML = label.innerHTML;
                fileInputLabel.setAttribute('for', fileInputId);
                inputParent.appendChild(fileInputLabel);
            }
            inputParent.appendChild(fileInput);
            this.appendChild(inputParent);
            // Reset name to switch it to the appropriate input
            this.name = '';
            this.name = name;
        },

        // we added get/set value and attributeChangedCallback for value instead of using
        // setupProperties because when user types in a value we use the input event to
        // hydrate the this.value property when we are typing at the middle of a text,
        // the cursor is set back to the end because the change observer reset local input value
        get value() {
            return this.querySelector('input').value;
        },

        set value(newValue) {
            var input = this.querySelector('input'),
                isHandheld = deviceUtils.isHandheld();

            if (typeof (newValue) === 'number') {
                newValue = newValue + '';
                if (newValue && isHandheld) {
                    this.classList.add('mobile-text-field-content');
                } else {
                    this.classList.remove('mobile-text-field-content');
                }
            }

            // sync the newValue to the local input value if they are different
            if (newValue !== this.value) {
                this.querySelector('input').value = newValue;
            }

            // if empty we just remove the attribute
            if (!newValue) {
                this.removeAttribute('value');
                if (isHandheld) {
                    this.classList.remove('mobile-text-field-content');
                    this._previousHeight = '';
                    if (!this.classList.contains('mobile-text-field-focused')) {
                        input.style.height = '';
                    }
                }
            } else {
                if (newValue !== this.getAttribute('value')) {
                    // sync the newValue to the host attribute "value" if they are different
                    this.setAttribute('value', newValue);
                }
            }

            this._calculateMobileHeight(newValue);
        },

        _calculateMobileHeight: function(newValue) {
            var input = this.querySelector('input'),
                isHandheld = deviceUtils.isHandheld();

            if (isHandheld) {
                if (!newValue) {
                    this._previousHeight = '';

                    if (!this.classList.contains('mobile-text-field-focused')) {
                        input.style.height = '';
                    }
                } else {
                    this.classList.add('mobile-text-field-content');
                    // Get the height. Add 15 px to the offsetHeight of the div to account for padding
                    this._previousHeight = Math.min(this.mobileMaxHeight, this._getDefaultHeight(newValue) + 15) + 'px';
                    if (!this.classList.contains('mobile-text-field-focused')) {
                        input.style.height = this._previousHeight;
                    }
                }
            }
        },

        get validator() {
            return this._customValidatorFunction;
        },

        set validator(newValue) {
            if (newValue && newValue !== this.validator) {
                this._customValidatorFunction = newValue;
                this.startValidation();
            } else if (!newValue) {
                this._customValidatorFunction = null;
                this.stopValidation();
            }
        },

        get _inputElement() {
            return this.querySelector('input');
        },

        set label(newValue) {
            var input = this.querySelector('input'),
                label = this.querySelector('label'),
                haLabel = this.querySelector('ha-label'),
                isNode;

            if (newValue) {
                isNode = Array.isArray(newValue) || newValue.nodeType === 1;
                if (typeof newValue === 'string') {
                    // if ha-label left from element value, remove <ha-label>
                    if (haLabel) {
                        this.removeChild(haLabel);
                        // recheck label existance because it may have been removed with ha-label
                        label = this.querySelector('label');
                    }

                    // if no label element create it and add it to text-field
                    if (!label) {
                        label = this.ownerDocument.createElement('label');
                        this.insertBefore(label, input);
                    }
                    label.htmlFor = input.id;
                    // toggle * if needed, and add label text to label element
                    handleRequiredIndicator(this, newValue);

                    // sync label attribute
                    this.setAttribute('label', newValue);
                } else if (isNode) {
                    // remove label attribute first
                    if (this.hasAttribute('label')) {
                        this.removeAttribute('label');
                    }

                    label = this.querySelector('label');
                    // if label left inside <ha-label> remove <ha-label>, else remove <label>
                    if (label && !haLabel) {
                        this.removeChild(label);
                    } else if (haLabel) {
                        this.removeChild(haLabel);
                    }

                    label = this.ownerDocument.createElement('label');
                    haLabel = this.ownerDocument.createElement('ha-label');
                    newValue = Array.isArray(newValue) ? newValue : [newValue];

                    newValue.forEach(function(node) {
                        label.appendChild(node);
                    });

                    haLabel.appendChild(label);
                    this.insertBefore(haLabel, this.firstElementChild);

                    // toggle * if needed
                    handleRequiredIndicator(this);
                }
                // make sure we don't have aria-label since we have label
                if (!this.ariaLabel) {
                    if (input.hasAttribute('aria-label')) {
                        input.removeAttribute('aria-label');
                    }
                }
            } else {
                // if falsy empty string, null or undefined

                // remove label attribute
                if (this.hasAttribute('label')) {
                    this.removeAttribute('label');
                }

                label = this.querySelector('label');
                haLabel = this.querySelector('ha-label');

                // remove <ha-label> if it exists
                if (haLabel) {
                    this.removeChild(haLabel);
                } else if (label) {  // otherwise just remove <label>
                    this.removeChild(label);
                }

                // if we don't have a label and we have a placeholder, set aria-label
                if (input.placeholder) {
                    if (!this.ariaLabel) {
                        input.setAttribute('aria-label', input.placeholder);
                    }
                }
            }

            this._label = newValue;
            if (this.attachment) {
                this._setUpAttachmentField();
            }
        },

        get label() {
            return this._label;
        },

        attributeChangedCallback: function _(attrName, oldValue, newValue) {
            // happens when we modify the attribute via browser inspector or via setAttribute
            if (attrName === 'value') {
                // call the value setter which handles the logic
                // put guard here to prevent value double setting,
                // the null guard condition is polyfill for IE11 since empty value will be null.
                if (this.value !== newValue && newValue !== null) {
                    this.value = newValue;
                }
            } else if (attrName === 'label') {
                this.label = newValue;
            } else {
                _.super(this, attrName, oldValue, newValue);
            }
        },

        /**
         * Calling on the focus method should in turn focus on the internal text field
         * @method focus
         * @public
         */
        focus: function() {
            this._inputElement.focus();
        },

        /**
         * Calling on the blur method should in turn blur on the internal text field
         * @method blur
         * @public
         */
        blur: function() {
            this._inputElement.blur();
        },

        /*
         * Calculate the default height of a node with the provided content,
         * taking into consideration the component's 'mobileMaxHeight' property.
         */
        _getDefaultHeight: function(content) {
            var nodeStyles = getComputedStyle(this._inputElement),
                div,
                defaultHeight;

            content = String(content || '');
            div = this.ownerDocument.createElement('div');
            div.style.fontSize = nodeStyles.fontSize;
            div.style.whiteSpace = 'pre-wrap';
            div.style.wordBreak = 'break-all';
            div.style.fontFamily = nodeStyles.fontFamily;
            div.style.width = nodeStyles.width;
            div.style.maxHeight = this.mobileMaxHeight + 'px';
            div.style.position = 'absolute';
            div.style.top = '-44px';
            div.style.left = '-' + (parseInt(nodeStyles.width, 10) + 10) + 'px';
            div.textContent = content.endsWith('\n') ? (content + '_') : content;
            this.ownerDocument.body.appendChild(div);
            defaultHeight = div.offsetHeight;
            this.ownerDocument.body.removeChild(div);

            return defaultHeight;
        }
    });

    /**
     * Add the event listeners needed for the component
     * @param {HTMLElement} component context defined
     * @private
     */
    function _addValidationListeners(component) {
        var input = component.querySelector('input');
        if (!component._validationListenersAdded) {
            component._boundValidator = component._reportValidity.bind(component);
            component.listenTo(input, 'mouseenter', component._boundValidator);
            component.listenTo(input, 'mouseout', component._boundValidator);
            component.listenTo(input, 'focus', component._boundValidator);
            component.listenTo(input, 'blur', component._boundValidator);
            component.listenTo(input, 'keyup', component._boundValidator);
            component.listenTo(component, '.ha-icon-alert:mouseover', component._boundValidator);
            component.listenTo(component, '.ha-icon-alert:mouseout', component._boundValidator);
            component.classList.add('ha-validatable');
            component._validationListenersAdded = true;
        }
    }

    /**
     * Remove all the event listeners for the component
     * @param {HTMLElement} component context defined
     * @private
     */
    function _removeValidationListeners(component) {
        var input = component.querySelector('input');
        if (!utils.validationRequired(component) && component._validationListenersAdded) {
            component.stopListening(input, 'mouseenter', component._boundValidator);
            component.stopListening(input, 'mouseout', component._boundValidator);
            component.stopListening(input, 'focus', component._boundValidator);
            component.stopListening(input, 'blur', component._boundValidator);
            component.stopListening(input, 'keyup', component._boundValidator);
            component.stopListening(component, '.ha-icon-alert:mouseover', component._boundValidator);
            component.stopListening(component, '.ha-icon-alert:mouseout', component._boundValidator);
            component.classList.remove('ha-validatable');
            component._validationListenersAdded = false;
        }
    }

    return register('ha-text-field', HATextField);
});

/**
 * Plugin that loads a template from a specified module id and returns a function to
 * generate DOM corresponding to that template. Uses Mustache.
 *
 * When that function is run, it returns another function.
 *
 * Template has a format like:
 *
 * ```html
 * <button>
 *   <span class="ha-reset {{iconClass}}"></span>
 *   {{label}}
 * </button>
 * ```
 *
 * Usage is typically like:
 *
 * ```js
 * define([..., "register-component/template!./templates/MyTemplate.html"], function(..., template) {
 *     ...
 *     template: template,
 *     ...
 * });
 * ```
 *
 * @module register-component/template
 */
define('register-component/template',["mustache"], function(Mustache) {

    var buildMap = {},

        // Text plugin to load the templates and do the build.
        textPlugin = "text";

    return { /** @lends module:register-component/template */
        /**
         * Returns a function to generate the DOM specified by the template.
         * This is the function run when you use this module as a plugin.
         * @param {string} mid - Absolute path to the resource.
         * @param {Function} require - AMD's require() method.
         * @param {Function} onload - Callback function which will be called with the compiled template.
         * @param {Object} config - Configuration object from the loader with `isBuild === true`
         * when doing a build.
         * @private
         */
        load: function(mid, require, onload, config) {
            if (buildMap[mid]) {
                onload(buildMap[mid]);
            } else {
                var textOnload;

                textOnload = function(source) {
                    if (config && config.isBuild) {
                        // Don't bother doing anything else during build.
                        onload();
                    } else {
                        Mustache.parse(source);
                        buildMap[mid] = function(data) {
                            return Mustache.render(source, data);
                        };

                        onload(buildMap[mid]);
                    }
                };

                require([textPlugin + "!" + mid], textOnload);
            }
        }
    };
});

define('text!hui/toast-message/toast-message.html',[],function () { return '<template>\n\t<div class="toast-wrapper">\n\t\t<button aria-label="Close" class="hi hi-close"></button>\n\t\t<i class="hi hi-confirm hi-circle-check"></i>\n\t\t<p>{{{message}}}</p>\n\t</div>\n</template>';});


define('hui/toast-message',[
    'object-utils/classes',
    'register-component/v2/register',
    'register-component/v2/UIComponent',
    'register-component/template!./toast-message/toast-message.html',
    './core/keys',
    './core/utils',
    './core/a11y',
    './core/event'
], function(classes, register, UIComponent, template, keys, utils, a11y, eventUtil) {
    'use strict';

    var HAToastMessage,
        /**
         * keeps track of the last visible toast, to close it when a new one is shown
         * @type {HTMLElement}
         */
        _lastShownToast,

        /**
         * keeps track of the hidden timeout id to be clean before using it again.
         */
        _closeTimeout,

        /**
         * The animation entrance duration.
         * Used to wait the animation out before hidding the element.
         * @type {Number}
         */
        _ANIMATION_DURATION = 200;

    /**
     * Cleans the timer for the given ID.
     * @param {Number} timerId The timer ID to be cleaned.
     */
    function _cleanTimer(timerId) {
        window.clearTimeout(timerId);
        timerId = null;
    }

    /**
     * Animates the leaving of the ToasMessage as the entrance, but backwards.
     * @param {HTML} component The component to be inspected.
     */
    function _animateBackwards(component) {
        _cleanTimer(_closeTimeout);

        component.classList.remove('animate');

        _closeTimeout = window.setTimeout(function() {
            component.classList.remove('visible');
            if (component._clearTimeout) {
                component._clearTimeout();
            }
        }.bind(component), _ANIMATION_DURATION);
    }

    HAToastMessage = classes.createObject(UIComponent, {

        init: function _() {

            _.super(this);

            /**
             * Template of the element.
             * @type {String}
             */
            this.template = template;

            /**
             * Text to display, can be html.
             * @type {String / HTMLElement}
             */
            this._message = '';

            /**
             * Type of toaster that display, shows an icon before the
             * message (e.g. 'confirm', 'info', 'error', 'alert', 'warn') and
             * changes the border.
             * @type {String}
             * @default confirm
             */
            this._type = 'confirm';

            /**
             * shows close icon if true and user can dismiss immediately
             * @type {String}
             */
            this._dismissible = true;

            this.setupProperties({
                /**
                 * ms, -1 remains visible until dismissed explicitly
                 * @type {Number}
                 */
                duration: {
                    default: 8000,
                    type: Number
                }
            });

            this.tabIndex = '-1';

            /**
             * @emits dismiss
             */
            this.on('button:click', function() {
                this.emit('dismiss');
                this.close();
            }.bind(this));

            this.on('keydown', function(evt) {
                var key = evt.keyCode;
                if (key === keys.ESCAPE) {
                    this.close();
                }
            }.bind(this));
        },

        // This setter is left just for compatibilty with older versions
        set type(newValue) {
            // jshint unused:false
            console.warn('DEPRECATION WARNING: "type" property is going to be deprecated, please from now on don\'t use it.');
        },

        get type() {
            console.warn('DEPRECATION WARNING: "type" property is going to be deprecated, please from now on don\'t use it.');
            return this._type;
        },

        set message(newValue) {
            var container = this.querySelector('.toast-wrapper > p'),
                i = 0,
                value;

            while (container.firstChild) {
                container.removeChild(container.firstChild);
            }

            if (newValue) {
                if (typeof newValue === 'string') {
                    container.innerHTML = newValue;
                } else if (Array.isArray(newValue)) {
                    for (; i < newValue.length; i++) {
                        value = newValue[i];
                        if (value && value.nodeType) {
                            container.appendChild(value);
                        }
                    }
                } else if (newValue.nodeType) {
                    container.appendChild(newValue);
                }
            }
            this._message = newValue;
        },

        get message() {
            return this._message;
        },

        set dismissible(newValue) {
            var closeButton = this.querySelector('button');

            if (newValue) {
                closeButton.classList.remove('hidden');
                closeButton.classList.add('show');
            } else {
                closeButton.classList.remove('show');
                closeButton.classList.add('hidden');
            }

            this._dismissible = newValue;
        },

        get dismissible() {
            return this._dismissible;
        },

        /**
         * Show toast message
         * @emits show
         */
        show: function() {
            if (_lastShownToast &&
                _lastShownToast.classList.contains('visible') &&
                !_lastShownToast.isEqualNode(this)) {
                _lastShownToast.close();
            }
            _lastShownToast = this;

            var _timeoutId,
                _pageModal;

            // HUI-4337 Pull Toast to absolute center in a containerless context
            this.style.marginLeft = '-' + (Number(this.offsetWidth) / 2) + 'px';

            this._clearTimeout();
            this.classList.add('animate');
            this.classList.add('visible');
            this.emit('show');

            if (this.duration > 0) {
                _timeoutId = setTimeout(this.close.bind(this), this.duration);
                this._clearTimeout = function() {
                    clearTimeout(_timeoutId);
                    this._clearTimeout = function() {};
                };
            }
            this._lastFocus = document.activeElement;
            this.focus();

            // HUI-4337: When a trowser is dismissed - ensure toast is too
            _pageModal = document.querySelector('ha-page-modal[visible]');
            if (_pageModal) {
                eventUtil.on(_pageModal, 'did-close', function onTrowserClose() {
                    _lastShownToast.close();
                    eventUtil.off(_pageModal, 'did-close', onTrowserClose);
                });
            }
        },

        /**
         * Close toast message
         * @emits close
         * @emits hide
         */
        close: function() {
            _lastShownToast = null;

            _animateBackwards(this);

            this.emit('close');
            this.emit('hide');

            if (this._lastFocus) {
                this._lastFocus.focus();
            }
        },

        /**
         * Calls the close method.
         * @deprecated
         */
        hide: function() {
            console.warn('DEPRECATION WARNING: This method is going to be deprecated, please from now on use "close" instead.');
            this.close();
        },

        preRender: function _() {
            var messages = this.querySelector('.toast-wrapper > p');
            this._message = messages ? utils.removeNodesSafe(messages, messages.childNodes) : utils.removeNodesSafe(this, this.childNodes);
            this._clearTimeout = function() {
            };
        },

        postRender: function _() {
            a11y.addA11yFocus(this);
            this.setAttribute('role', 'status');

            this.message = this._message;

            if (this.getAttribute('dismissible') === 'false') {
                this.dismissible = false;
            } else {
                this.dismissible = true;
            }
        },

        detachedCallback: function _() {
            _lastShownToast = null;
            _cleanTimer(_closeTimeout);
            _closeTimeout = null;

            this._clearTimeout = null;
            delete this._clearTimeout;
        },

        /**
         * This method must be removed, once the hide method is also removed.
         */
        addEventListener: function _() {
            HTMLElement.prototype.addEventListener.apply(this, arguments);
            if (arguments[0] === 'hide') {
                console.warn('DEPRECATION WARNING: The hide event is going to be deprecated. From now on, please use "close" instead.');
            }
        }
    });

    return register('ha-toast-message', HAToastMessage);
});

define('hui/trowser/trowser-base',[
    'object-utils/classes',
    'register-component/v2/UIComponent',
    '../core/contentNode',
    '../core/a11y',
    '../core/event',
    '../core/utils',
    '../core/deviceUtils'
],
function(classes, UIComponent, contentNode, a11y, eventUtil, utils, deviceUtils) {
    'use strict';

    function _updateHeaderItem(component, isNew, type, icon, position) {
        ifExists(component, function(pageModal) {
            var item,
                newItems,
                pageModalHeader = pageModal.querySelector('ha-page-modal-header'),
                headerItems = pageModalHeader.headerItems;
            if (isNew) {
                item = pageModal.ownerDocument.createElement('ha-page-modal-header-item');
                item.type = type;
                item.icon = icon;
                item.setAttribute('position', position);
                pageModalHeader.headerItems = headerItems.concat(item);
            } else {
                newItems = pageModal.querySelectorAll('ha-page-modal-header-item:not([type="' + type + '"])');
                pageModalHeader.headerItems = Array.prototype.slice.call(newItems);
            }
        });
    }

    function arrayOrNull(nodes) {
        return (Array.isArray(nodes) && nodes.length > 0) ?
            nodes :
            null;
    }

    /**
     * Partitions a footers children into labeled spans which is the new
     * API contract for declaratively setting the footer items
     *
     * ex: input:
     *      <footer>
     *          <button action="tertiary"></button>
     *          <button action="secondary"></button>
     *          <button action="primary"></button>
     *      </footer>
     *
     *     output:
     *      <footer>
     *          <span class="footer-center">
     *              <button action="tertiary"></button>
     *          </span>
     *          <span class="footer-right">
     *              <button action="secondary"></button>
     *              <button action="primary"></button>
     *          </span>
     *      </footer>
     *
     * @param {HTMLElement} footerNode A footer node with children that have
     *                                 an action attribute
     * @return {HTMLElement} footerNode'
     */
    function massageFooterData(footerNode) {
        var el = utils.createElement,
            validActions = {
                'primary': [],
                'secondary': [],
                'tertiary': []
            },
            children = [].slice.call(footerNode.children),
            byPartitioning = function(actions, node) {
                var actionName = node.getAttribute('action'),
                    isValidAction = Object.keys(validActions)
                                          .indexOf(actionName) !== -1;

                if (isValidAction) {
                    // partition into the action "buckets"
                    actions[actionName].push(node);
                }

                return actions;
            };

        // cache the input
        children.reduce(byPartitioning, validActions);

        // destroy the children
        utils.removeAllChildrenFrom(footerNode);

        // append the valid action elements
        if (deviceUtils.isHandheld()) {
            utils.appendChildren(footerNode, [
                el('span', {'className': 'footer-left'},
                    (validActions.tertiary).concat(validActions.secondary)
                ),
                el('span', {'className': 'footer-center'}),
                el('span', {'className': 'footer-right'},
                    validActions.primary
                )
            ]);
        } else {
            utils.appendChildren(footerNode, [
                el('span', {'className': 'footer-left'}),
                el('span', {'className': 'footer-center'},
                    validActions.tertiary
                ),
                el('span', {'className': 'footer-right'},
                    (validActions.secondary).concat(validActions.primary)
                )
            ]);
        }

        return footerNode;
    }

    var ifExists = utils.ifExists,
        ifSafeChain = utils.ifSafeChain,
        TrowserBase = classes.createObject(UIComponent, {

            init: function _() {
                _.super(this);

                /**
                 * Stores a reference to the page modal so that setters and
                 * getters can be delegated once the page modal has moved to the
                 * document body.
                 * @type {HTMLElement}
                 */
                this._pageModal = null;

                this.setupProperties({

                    /**
                     * Indicates whether the component is rendered into the body by react
                     * @type {Boolean}
                     */
                    reactLayering: {
                        type: Boolean,
                        default: false
                    },

                    /**
                     * The Title of the Trowser.
                     * @type {String}
                     */
                    titleText: {
                        type: String,
                        default: '',
                        change: function(newValue) {
                            ifSafeChain(this, ['_pageModal', 'querySelector'], function(querySelector) {
                                querySelector('ha-page-modal-header').titleText = newValue;
                            });
                        }
                    },

                    /**
                     * The secondary info message displayed on the right of the title.
                     * @type {String}
                     */
                    infoText: {
                        type: String,
                        default: '',
                        change: function(newValue) {
                            ifSafeChain(this, ['_pageModal', 'querySelector'], function(querySelector) {
                                querySelector('ha-page-modal-header').infoText = newValue;
                            });
                        }
                    },

                    /**
                     * Shows history icon button.
                     * NOTE: by default is false.
                     * @type {Boolean}
                     */
                    history: {
                        type: Boolean,
                        default: false,
                        change: function(newValue) {
                            _updateHeaderItem(this, newValue, 'history', 'history', 'left');
                        }
                    },

                    /**
                     * Shows settings icon button.
                     * NOTE: by default is false.
                     * @type {Boolean}
                     */
                    settings: {
                        type: Boolean,
                        default: false,
                        change: function(newValue) {
                            _updateHeaderItem(this, newValue, 'settings', 'settings-o', 'right');
                        }
                    },

                    /**
                     * Type can be "step-flow" which removes the footer, section padding and the backgroud color is $blue-gray-whiter.
                     * Otherwise it renders a normal ha-trowser with footer
                     * Note that it does not support dynamic changing of types because there is no use case for it
                     * @type {String}
                     */
                    type: {
                        type: String,
                        default: '',
                        change: function(newValue) {
                            if (newValue === 'step-flow') {
                                ifSafeChain(this, ['_pageModal'], function(pageModal) {
                                    var pageModalPanel = pageModal.querySelector('.page-modal-panel');
                                    // note this is a workaround where we search for the footer element and remove it for step-flow
                                    // long term, it's best that page-modal handle it by not rendering a footer in the first place
                                    // if the user didn't provide one.
                                    pageModalPanel.removeChild(pageModal.querySelector('.page-modal-panel > footer'));
                                });
                            }
                        }
                    },

                    /**
                     * Indicates whether the component closes by default when X is clicked
                     * or ESC key is pressed. This is actually passed to ha-page-modal which handles the logic.
                     * @type {Boolean}
                     */
                    noCloseOnDismiss: {
                        type: Boolean,
                        default: false,
                        change: function(newValue) {
                            if (this._pageModal) {
                                this._pageModal.noCloseOnDismiss = newValue;
                            }
                        }
                    }
                });
            },

            //dismissible and help properties are simple booleans. We should be declaring them in the setupProperties
            //method, in order to achieve dynamic binding. But currently, because of a known issue en setupProperties,
            //a boolean property will always have a default false value, no matter what we set.
            //When the issue is resolved, and we're able to set a true default value, change this logic to allow
            //dynamic binding
            set dismissible(newValue) {
                ifSafeChain(this, ['_pageModal', 'querySelector'], function(querySelector) {
                    querySelector('ha-page-modal-header').dismissible = newValue;
                });
            },

            get dismissible() {
                return ifSafeChain(this, ['_pageModal', 'querySelector'], function(querySelector) {
                    return querySelector('ha-page-modal-header').dismissible;
                });
            },

            set help(newValue) {
                _updateHeaderItem(this, newValue, 'help', 'help-o', 'right');
            },

            /**
             * Shows help icon button.
             * NOTE: by default is true.
             * @type {Boolean}
             */
            get help() {
                return true;
            },

            set footerItems(newItems) {
                var footer = utils.createElement('footer', {}, newItems);

                footer = massageFooterData(footer);

                ifSafeChain(this, ['_pageModal'], function(pageModal) {
                    pageModal.footer = footer;
                });
            },

            get footerItems() {
                return ifSafeChain(this, ['_pageModal'], function(pageModal) {
                    var root = 'div.page-modal-panel > footer > footer > ',
                        footerLeft = pageModal.querySelector(root + 'span.footer-left'),
                        footerCenter = pageModal.querySelector(root + 'span.footer-center'),
                        footerRight = pageModal.querySelector(root + 'span.footer-right'),
                        toFooterItems = function(items, footerSpan) {
                            return items.concat(utils.arrayOfChildrenFrom(footerSpan));
                        },
                        footerSpans = [footerLeft, footerCenter, footerRight];

                    return arrayOrNull(footerSpans.reduce(toFooterItems, []));
                });
            },

            set section(newSection) {
                ifSafeChain(this, ['_pageModal'], function(pageModal) {
                    pageModal.section = newSection;
                });
            },

            get section() {
                return ifSafeChain(this, ['_pageModal', 'section'], function(section) {
                    return section;
                });
            },

            postRender: function _() {
                var el = utils.createElement,
                    renderedOrUserProvided = utils.contentQueryFactory(this, {
                        'section': 'ha-page-modal > div.page-modal-panel > section',
                        'footer': 'ha-page-modal > div.page-modal-panel > footer'
                    }),
                    pageModal = el('ha-page-modal'),
                    section = renderedOrUserProvided('section') || el('section'),
                    footer = renderedOrUserProvided('footer') || el('footer'),
                    pageModalHeader = el('ha-page-modal-header'),
                    usedNewFooterContract = !!this.querySelector('footer > span.footer-left') ||
                                            !!this.querySelector('footer > span.footer-center') ||
                                            !!this.querySelector('footer > span.footer-right');

                _.super(this);
                a11y.addA11yFocus(pageModal);

                // destroy all children
                utils.removeAllChildrenFrom(this);

                pageModal.classList.add('trowser-modal');

                pageModal.header = pageModalHeader;

                pageModal.section = section;

                if (!usedNewFooterContract) {
                    footer = massageFooterData(footer);
                }

                pageModal.footer = footer;

                this._pageModal = pageModal;
                this.appendChild(pageModal);

                if (this.getAttribute('help') !== 'false') {
                    this.help = true;
                }

                if (this.getAttribute('dismissible') !== 'false') {
                    this.dismissible = true;
                }

                eventUtil.on(pageModal, 'show', function(evt) {
                    evt.stopPropagation();
                    if (evt.target === pageModal) {
                        this.emit('show');
                    }
                }.bind(this));

                eventUtil.on(pageModal, 'close', function(evt) {
                    evt.stopPropagation();
                    if (evt.target === pageModal) {
                        this.emit('close');
                    }
                }.bind(this));

                eventUtil.on(pageModal, 'dismiss', function(evt) {
                    evt.stopPropagation();
                    if (evt.target === pageModal || evt.target === pageModalHeader) {
                        this.emit('dismiss');
                    }
                }.bind(this));
            },

            detachedCallback: function() {
                ifSafeChain(this, ['_pageModal'], function(pageModal) {
                    ifSafeChain(pageModal, ['parentNode', 'removeChild'], function(removeChild) {
                        removeChild(pageModal);
                    });
                });
            },

            /**
             * Open the element.
             * @emit ha-page-modal:show
             */
            show: function() {
                if (!this.reactLayering) {
                    ifSafeChain(this, ['_pageModal', 'show'], function(show) {
                        show();
                    });
                }
            },

            /**
             * @deprecated Use the header, section and footerItems properties instead
             * Sets the content of the page modal
             */
            addContent: function(config) {
                var contentPropertyMap = {
                    'section': 'section',
                    'footer': 'footerItems'
                };

                contentNode.addContent(this, config, contentPropertyMap);
                console.warn('DEPRECATION WARNING: addContent method should not be used anymore to add ' +
                'content to the component. This will be removed in the future so please assign content ' +
                'directly to the corresponding component properties instead.');
            },

            /**
             * @deprecated Use close method instead
             * Closes the Trowser.
             */
            hide: function() {
                this.close();
                console.warn('DEPRECATION WARNING: The hide method is deprecated, use "close" method instead');
            },

            /**
             * Closes the Trowser.
             * @emit ha-trowser:close
             */
            close: function() {
                ifSafeChain(this, ['_pageModal', 'close'], function(close) {
                    close();
                });
            }
        });

    return TrowserBase;
});

define('hui/modal',[
    'object-utils/classes',
    'register-component/v2/register',
    'register-component/v2/UIComponent',
    './core/a11y',
    './core/keys',
    './core/contentNode',
    './core/position',
    './core/underlay',
    './core/utils',
    './core/deviceUtils'
], function(classes, register, UIComponent, a11y, keys, contentNode, position, underlay, utils, deviceUtils) {

    function recreateModalTitle(component, size, type) {
        var titleContainer = component.querySelector('.modal-title'),
            modalTitle = titleContainer.querySelector('#modal-title-' + component.componentId),
            iconNode = component.querySelector('.modal-title i.hi');

        if (modalTitle) {
            titleContainer.removeChild(modalTitle);
        }

        if (size === 'small' && type === 'error' || size === 'small' && type === 'alert') {
            modalTitle = component.ownerDocument.createElement('h4');
        } else {
            modalTitle = component.ownerDocument.createElement('h2');
        }

        modalTitle.id = 'modal-title-' + component.componentId;
        modalTitle.textContent = component.titleText;

        titleContainer.insertBefore(modalTitle, titleContainer.firstChild);
        if (iconNode) {
            titleContainer.insertBefore(iconNode, titleContainer.firstChild);
        }
    }

    /**
     * Adds an appropriate class to the component based on number of buttons in
     * its footer.
     * @param {HTMLElement} footerNode The footer node with the buttons
     */
    function setFooterClass(footerNode) {
        var countClassMap = {
                1: 'one-btn',
                2: 'two-btn',
                3: 'three-btn'
            },
            footerBtnsClass,
            btnsLength;

        if (utils.isNode(footerNode)) {
            btnsLength = footerNode.querySelectorAll('button').length;

            footerBtnsClass = countClassMap[btnsLength];

            if (footerBtnsClass) {
                footerNode.classList.add(footerBtnsClass);
            }
        }
    }

    /**
     * A function for determining modal target is popover-menu or not.
     */
    function isPopoverMenu(component) {
        return component.classList.contains('mobile-menu');
    }

    /**
     * A function for determining modal target is type-ahead-popover-menu or not.
     */
    function isTypeAheadPopoverMenu(component) {
        return isPopoverMenu && component.classList.contains('mobile-type-ahead-menu');
    }

    /**
     * A function for determining modal target is ha-menu-button or not.
     */
    function isMenuButton(component) {
        return component.targetSelector.indexOf('ha-menu-button') > -1;
    }

    /**
     * A function for handle mobile orientation viewport.
     * @param {HTMLElement} component The web component need to be handled.
     * @private
     */
    function handleOrientation(component) {
        if (component._visible) {
            if (!document.body.classList.contains('body-lock')) {
                document.body.classList.add('body-lock');
            }
            component.classList.remove('show');
            // this timeout call back make up for iPhone 6+/7+ landscape mode modal show position wrong problem
            setTimeout(function() {
                component.classList.add('show');
                // make up for iPhone 6+/7+ landscape mode miss alignment in type-ahead and menu-button menu when Safari has two or more tabs.
                /* istanbul ignore if */
                if (deviceUtils.getOrientation() === 'landscape' && deviceUtils.isIPhonePlus()) {
                    setTimeout(function() {
                        if (isTypeAheadPopoverMenu(component)) {
                            window.scrollTo(0, 0);
                        }
                        if (deviceUtils.isIPhonePlusWithTabBar() && isMenuButton(component)) {
                            document.body.classList.remove('body-lock');
                        }
                    }, 380);
                }
            }, 0);
        }
    }

    /**
     * A function for re-enable touchmove event on mobile devices, it needs to add to event listeners.
     */
    function reabaleTouchMove(evt) {
        evt.stopPropagation();
        return true;
    }

    /**
     * A function toggle touchmove event on mobile devices, it needs to add to event listeners.
     * @param {HTMLElement} component The web component need to be handled.
     * @param {Boolean}     enable    Determine the web component whether bring touchmove event back or not.
     * @private
     */
    function toggleTouchMoveEvent(component, enable) {
        var element = component;
        if (isPopoverMenu(component)) {
            element = component.section;
        }
        if (enable) {
            element.addEventListener('touchmove', reabaleTouchMove);
        } else {
            element.removeEventListener('touchmove', reabaleTouchMove);
        }
    }

    /**
     * Used to track whether the animation has ended or not
     * @type {String}
     * @private
     */
    var _animationend,

    /**
     * Used for accesibility reasons to set the focus to the last active element
     * before the Modal is shown.
     * @type {HTMLElement}
     * @private
     */
    _lastFocus = null,

    HAModal = classes.createObject(UIComponent, {

        init: function _() {

            _.super(this);

            /**
             * Indicates whether the component is visible after calling show
             * @type {Boolean}
             * @private
             */
            this._visible = false;

            /**
             * Indicates whether the component need to lock HTML body or not. It is used for iOS devices.
             * @type {Boolean}
             * @private
             */
            this._lockBody = true;

            /**
             * Used to store a bind function for adding orientation event listener.
             * @private
             */
            this._handleOrientation = null;

            /**
             * Property to set the text that provides additional details about the reason for the alert.
             * @type {HTMLElement}
             */
            this._message = '';

            /**
             * Property to set the extra sidebar content node for the endflow type.
             * @type {HTMLElement}
             */
            this._extrainfo = null;

            this.setupProperties({

                /**
                 * Property to set if the Modal shows the close button (true / false).
                 * @type {Boolean}
                 */
                dismissible: {
                    default: false,
                    type: Boolean,
                    change: function(newValue) {
                        var closeButton = this.querySelector('header button');

                        if (newValue) {
                            closeButton.classList.remove('hidden');
                            closeButton.classList.add('show');
                        } else {
                            closeButton.classList.add('hidden');
                            closeButton.classList.remove('show');
                        }
                    }
                },

                /**
                 * Indicates whether the component is rendered into the body by react
                 * @type {Boolean}
                 */
                reactLayering: {
                    type: Boolean,
                    default: false
                },

                /**
                 * Property to set the size of the Modal ('small' / 'medium' / 'large').
                 * @type {String}
                 * @default {Small}
                 */
                size: {
                    default: 'small',
                    type: String,
                    change: function(newValue) {
                        var modal = this.querySelector('.modal-dialog'),
                            sizes = ['small', 'medium', 'large', 'fullscreen'],
                            i = 0;

                        for (; i < sizes.length; i++) {
                            if (modal.classList.contains(sizes[i])) {
                                modal.classList.remove(sizes[i]);
                            }
                        }

                        modal.classList.add(newValue);

                        recreateModalTitle(this, newValue, this.type);
                    }
                },

                /**
                 * Property to set the type of the Modal ('confirm' / 'info' / 'error' / 'warn' / 'endflow' / 'alert' (for backward compatibility)).
                 * @type {String}
                 */
                type: {
                    default: '',
                    type: String,
                    change: function(newValue) {
                        var modal = this.querySelector('.modal-dialog'),
                            titleContainer = this.querySelector('.modal-title'),
                            titleIcon = titleContainer.querySelector('i'),
                            types = ['confirm', 'info', 'error', 'warn', 'endflow', 'alert'],
                            i = 0;

                        if (newValue === '') {
                            return;
                        }

                        for (; i < types.length; i++) {
                            if (modal.classList.contains(types[i])) {
                                modal.classList.remove(types[i]);
                            }
                            if (titleContainer.classList.contains('hi-' + types[i])) {
                                titleContainer.classList.remove('hi-' + types[i]);
                            }
                        }

                        if ((newValue === 'error') || (newValue === 'alert') || (newValue === 'endflow')) {
                            modal.classList.add(newValue);

                            if (newValue === 'error' || newValue === 'alert') {
                                if (newValue === 'alert') {
                                    console.warn('DEPRECATION WARNING: Type "alert" is deprecated, take care using this type for futures releases');
                                }
                                this.setAttribute('role', 'alertdialog');
                                modal.classList.remove('message-icon');
                                titleContainer.classList.add('hi-' + newValue);
                            } else if (newValue === 'endflow') {
                                modal.classList.add('message-icon');
                                titleContainer.classList.add('hi-confirm');
                            }
                        } else {
                            modal.classList.add('message-icon');
                            titleContainer.classList.add('hi-' + newValue);
                        }
                        recreateModalTitle(this, this.size, newValue);
                        if (!titleIcon) {
                            titleIcon = this.ownerDocument.createElement('i');
                            if (titleContainer.firstElementChild) {
                                titleContainer.insertBefore(titleIcon, titleContainer.firstElementChild);
                            } else {
                                titleContainer.appendChild(titleIcon);
                            }
                        }
                        titleIcon.className = 'hi';
                        switch (newValue) {
                            case 'confirm':
                            case 'endflow':
                                titleIcon.classList.add('hi-circle-check');
                                break;
                            case 'info':
                                titleIcon.classList.add('hi-circle-info');
                                break;
                            case 'error':
                            case 'warn':
                            case 'alert':
                                titleIcon.classList.add('hi-circle-alert');
                                break;
                            default:
                                break;
                        }
                    }
                },

                /**
                 * Property to set the title of the Modal.
                 * @type {String}
                 */
                titleText: {
                    default: '',
                    type: String,
                    change: function(newValue) {
                        var modalTitle = this.querySelector('.modal-title h2') || this.querySelector('.modal-title h4');

                        if (modalTitle) {
                            modalTitle.textContent = newValue;
                        }
                    }
                },

                subtitle: {
                    default: '',
                    type: String,
                    change: function(newValue) {
                        var modalTitle = this.querySelector('.modal-title h2') || this.querySelector('.modal-title h4'),
                            header = this.querySelector('header');

                        header.classList[newValue ? 'add' : 'remove']('modal-subtitle');
                        if (modalTitle) {
                            var subtitle = document.createElement('div'),
                                previousSubtitle = modalTitle.nextElementSibling;
                            subtitle.classList.add('modal-subtitle');
                            subtitle.textContent = newValue;
                            if (previousSubtitle && previousSubtitle.classList.contains('modal-subtitle')) {
                                previousSubtitle.parentElement.removeChild(previousSubtitle);
                            }
                            modalTitle.parentElement.appendChild(subtitle);

                        }
                    }
                }
            });

            this.tabIndex = '-1';
            this.setAttribute('role', 'dialog');

            _animationend = utils.getAnimationEventNames().animationend;

            /**
             * @emits dismiss.
             */
            this.on('header button:click', function() {
                this.emit('dismiss');
                this.close();
            }.bind(this));
        },

        set buttons(newValue) {
            var modalFooter = this.querySelector('footer');

            utils.removeAllChildrenFrom(modalFooter);
            utils.replaceChildrenOf(modalFooter, newValue);

            setFooterClass(modalFooter);
        },

        get buttons() {
            var footer = this.querySelector('footer');

            return utils.arrayOfChildrenFrom(footer).filter(function(child) {
                return child && child.tagName === 'BUTTON';
            });
        },

        set message(newValue) {
            var body = this.querySelector('section');

            utils.removeAllChildrenFrom(body);

            if (typeof newValue === 'string') {
                body.textContent = newValue;
            } else {
                utils.replaceChildrenOf(body, newValue);
            }
            this._message = newValue;
        },

        get message() {
            return this._message;
        },

        set section(content) {
            this.message = content;
        },

        get section() {
            return this.message;
        },

        set extraInfo(newValue) {
            var endflowContainer = this.querySelector('aside');

            utils.removeAllChildrenFrom(endflowContainer);
            utils.replaceChildrenOf(endflowContainer, newValue);

            this._extrainfo = newValue;
        },

        get extraInfo() {
            return this._extrainfo;
        },

        /**
         * Callback attached after the Component render
         * Creates a modal based on the attributes that were passed.
         */
        postRender: function _() {
            var el = utils.createElement,
                withAttrs = utils.setAttributes,
                renderPath = 'div.modal > div.modal-dialog > div.modal-content',
                renderedOrUserProvided = utils.contentQueryFactory(this, {
                    'main': renderPath,
                    'section': renderPath,
                    'aside': renderPath,
                    'footer': renderPath
                }),
                div, section, aside, footer;

            _.super(this);
            a11y.addA11yFocus(this);

            // cache input
            section = renderedOrUserProvided('main') ||
                      renderedOrUserProvided('section') ||
                      el('section');
            aside = renderedOrUserProvided('aside') || el('aside');
            footer = renderedOrUserProvided('footer') || el('footer');

            // destroy children
            utils.removeAllChildrenFrom(this);

            // render "template"
            div =
                el('div', {
                    'className': 'modal',
                    'attr-tabIndex': '-1',
                    'attr-aria-labelledby': 'modal-title-' + this.componentId,
                    'attr-aria-describedby': 'modal-text-' + this.componentId}, [
                    el('div', {'className': 'modal-dialog'}, [
                        el('div', {'className': 'modal-content'}, [
                            el('header', {}, [
                                el('button', {
                                    'type': 'button',
                                    'className': 'btn btn-link hi hi-close medium pull-right',
                                    'attr-aria-label': 'Close'
                                }),
                                el('div', {'className': 'modal-title'})
                            ]),
                            withAttrs(section, {'id': 'modal-text-' + this.componentId}),
                            footer,
                            aside
                        ])
                    ])
                ]);

            this.appendChild(div);

            if (deviceUtils.isHandheld()) {
                this.classList.add('mobile-modal');
                this.size = 'small';
            }

            setFooterClass(this.querySelector('footer'));
        },

        /**
         * This method must be removed, once the hide method is also removed.
         */
        addEventListener: function _() {
            HTMLElement.prototype.addEventListener.apply(this, arguments);
            if (arguments[0] === 'hide') {
                console.warn('DEPRECATION WARNING: The hide event is going to be deprecated. From now on, please use "close" instead.');
            }
        },

        /**
         * Opens the Modal, and makes the elements inside to be accesible from the keyboard.
         * @emits show.
         */
        show: function() {
            if (!this._visible) {
                if (!this.reactLayering) {
                    underlay.show(this);
                    position.bringToFront(this);
                }
                this._visible = true;
                this._handleOrientation = handleOrientation.bind(null, this);

                this.emit('will-show');

                var modal = this.querySelector('.modal'),
                    header = this.querySelector('.modal-title'),
                    body = this.querySelector('section'),
                    firstFocusable = modal.querySelector('.ha-button-primary') ||
                        header.querySelector('input, button, textarea, select') ||
                        body.querySelector('input, button, textarea, select'),
                    self = this;

                if (this._lockBody && deviceUtils.isIOSDevice()) {
                    deviceUtils.stopTouchMove(this.ownerDocument.querySelector('.ha-underlay'), true);
                    window.addEventListener('orientationchange', this._handleOrientation);
                    // if iPhone 6+/7+ landscape mode not lock body since modal not showing when Safari has two or more tabs.
                    if ((!isTypeAheadPopoverMenu(this) || isMenuButton(this)) && !deviceUtils.isIPhonePlusWithTabBar()) {
                        deviceUtils.bodyLock();
                    }
                }

                this.ownerDocument.body.classList.add('modal-open');
                this.classList.remove('hidden');
                this.classList.add('show');
                this.classList.add('show-delay');

                _lastFocus = this.ownerDocument.activeElement;

                if (firstFocusable) {
                    firstFocusable.focus();
                } else {
                    a11y.setFocusOnAnyFirst(modal);
                }

                this.listenTo(modal, _animationend, function onShow() {
                    self.stopListening(modal, _animationend, onShow);
                    self.classList.add('from-bottom-slide-in');
                    self.classList.remove('show-delay');
                    if (self._lockBody && deviceUtils.isIOSDevice()) {
                        // if iPhone 6+/7+ landscape mode not lock body since popover menu modal not showing when Safari has two or more tabs.
                        if (!deviceUtils.isIPhonePlusWithTabBar()) {
                            if (isTypeAheadPopoverMenu(self) && !isMenuButton(self)) {
                                deviceUtils.bodyLock();
                            }
                            toggleTouchMoveEvent(self, true);
                        }
                    }
                });

                /**
                 * @emits dismiss
                 */
                this.on('keydown', function(evt) {
                    if (evt.keyCode === keys.ESCAPE) {
                        utils.stopEvent(evt);
                        this.emit('dismiss');
                        self.close();
                    }

                    a11y.keepFocusInsideListener(evt, modal);
                });

                this.emit('show');
            }
        },

        /**
         * Closes the Modal, and remove the elements inside from the keyboard access.
         * @emits close.
         */
        close: function() {
            if (this._visible) {
                this._visible = false;

                var modal = this.querySelector('.modal'),
                    self = this;

                this.classList.add('hidden');
                this.classList.remove('from-bottom-slide-in');

                this.off('keydown');

                if (!this.reactLayering) {
                    underlay.hide();
                }

                if (deviceUtils.isIOSDevice()) {
                    window.removeEventListener('orientationchange', this._handleOrientation, false);
                    deviceUtils.bodyUnlock();
                }
                this.emit('will-close');

                this.listenTo(modal, _animationend, function onClose() {
                    self.stopListening(modal, _animationend, onClose);

                    self.classList.remove('show');
                    self.classList.remove('visible');  // polyfill for some Android phones
                    self.ownerDocument.body.classList.remove('modal-open');
                    self.emit('close');
                    self.emit('hide');

                    if (_lastFocus && !self._noAutoFocusLastActiveElementOnClose) {
                        _lastFocus.focus();
                    }
                    _lastFocus = null;
                    if (self._lockBody && deviceUtils.isIOSDevice()) {
                        if (!deviceUtils.isIPhonePlusWithTabBar()) {
                            toggleTouchMoveEvent(self, false);
                        }
                    }
                });
            }
        },

        /**
         * Calls the close method.
         * @deprecated
         */
        hide: function() {
            console.warn('DEPRECATION WARNING: This method is deprecated, take care using this method for futures releases');
            this.close();
        },

        /**
         * Adds content to the component
         * @param       {object} config Mapping between HTML and properties
         * @deprecated                  Properties should be used directly instead
         */
        addContent: function(config) {
            /**
             * Map that says where to insert the content that the consumer sends on the initialization.
             * @type {Object}
             */
            var contentPropertyMap = {
                'main': 'message',
                'section': 'message',
                'aside': 'extraInfo',
                'footer': 'buttons'
            };

            contentNode.addContent(this, config, contentPropertyMap);
        },

        // When modal show called, the detachedCallback might be called depends on the modal's previous parent node whether body or not.
        // Therefore, if the modal behavior flicker and dispear, then need look at and modify this part.
        detachedCallback: function() {
            if (this.parentElement && this.parentElement !== this.ownerDocument.body) {
                this.close();
            }
        }
    });

    return register('ha-modal', HAModal);
});

define('hui/trowser/page-modal-footer',[
    'object-utils/classes',
    'register-component/v2/UIComponent',
    'register-component/v2/register',
    '../core/deviceUtils',
    '../modal'
], function(classes, UIComponent, register, deviceUtils) {
    'use strict';

    /**
     * Assign the position to each footer element
     * @param {Array} items
     * @param {String} position
     * @return {Array}
     */
    function _addPositionAttribute(items, position) {
        for (var i = 0; i < items.length; i++) {
            items[i].setAttribute('position', position);
        }

        return Array.prototype.slice.call(items);
    }

    /**
     * Appends or removes elements from their corresponding container
     * @param  {HTMLElement} component the page-modal-footer
     * @param  {Array} items  array of nodeElements
     * @param  {Function} action appendChild || removeChild
     */
    function _handleFooterItems(component, items, action) {
        var leftSpan = component.querySelector('.footer-left'),
            rightSpan = component.querySelector('.footer-right'),
            centerSpan = component.querySelector('.footer-center'),
            itemCount = items.length,
            i;

        for (i = 0; i < itemCount; i++) {
            switch (items[i].getAttribute('position') || items[i].position) {
                case 'left':
                    action.call(leftSpan, items[i]);
                    break;
                case 'right':
                    action.call(rightSpan, items[i]);
                    break;
                case 'center':
                    action.call(centerSpan, items[i]);
                    break;
            }
        }
    }

    var HAPageModalFooter = classes.createObject(UIComponent, {

        init: function _() {
            _.super(this);

            /**
             * Arrays of footer items.
             * @type {Array}
             */
            this._footerItems = [];
        },

        set footerItems(items) {
            _handleFooterItems(this, this._footerItems, Node.prototype.removeChild);
            _handleFooterItems(this, items, Node.prototype.appendChild);

            this._footerItems = items;
        },

        get footerItems() {
            return this._footerItems;
        },

        postRender: function _() {
            var leftSpan = this.querySelector('.footer-left'),
                rightSpan = this.querySelector('.footer-right'),
                centerSpan = this.querySelector('.footer-center'),
                items = [];

            if (deviceUtils.isHandheld()) {
                this.classList.add('mobile-page-modal-footer');
            }

            _.super(this);
            this.tabIndex = -1;
            if (leftSpan) {
                //we already created the containers
                if (leftSpan && leftSpan.children.length > 0) {
                    items = items.concat(_addPositionAttribute(leftSpan.children, 'left'));
                }
                if (rightSpan && rightSpan.children.length > 0) {
                    items = items.concat(_addPositionAttribute(rightSpan.children, 'right'));
                }
                if (centerSpan && centerSpan.children.length > 0) {
                    items = items.concat(_addPositionAttribute(centerSpan.children, 'center'));
                }
                this.footerItems = items;
            } else {
                //create the containers
                leftSpan = this.ownerDocument.createElement('span');
                rightSpan = this.ownerDocument.createElement('span');
                centerSpan = this.ownerDocument.createElement('span');
                leftSpan.className = 'footer-left';
                rightSpan.className = 'footer-right';
                centerSpan.className = 'footer-center';

                this.appendChild(leftSpan);
                this.appendChild(centerSpan);

                this.appendChild(rightSpan);
            }
        },

        _onClickSave: function() {
            this._mainMenu.show();
        },

        _onClickOverflow: function() {
            this._overflowMenu.show();
        }
    });

    return register('ha-page-modal-footer', HAPageModalFooter);
});

define('hui/trowser/page-modal-header-item',[
    'object-utils/classes',
    'register-component/v2/UIComponent',
    'register-component/v2/register'
], function(classes, UIComponent, register) {
    'use strict';

    var HAPageModalHeaderItem = classes.createObject(UIComponent, {

        init: function _() {
            _.super(this);

            this.setupProperties({

                /**
                 * Property to set the unique identifier for this Page Modal Header Item.
                 * @type {String}
                 */
                type: {
                    type: String,
                    default: '',
                    change: function(newValue) {
                        var button = this.querySelector('.header-button');
                        if (newValue) {
                            button.setAttribute('aria-label', newValue);
                        }
                    }
                },

                /**
                 * Property to set the location of the Page Modal Header Item ('left' / 'center' / 'right').
                 * @type {String}
                 */
                position: {
                    type: String,
                    default: ''
                },

                /**
                 * Property to set the icon class of the Page Modal Header Item.
                 * @type {String}
                 */
                icon: {
                    type: String,
                    default: '',
                    change: function(newValue, oldValue) {
                        var span = this.querySelector('span');

                        if (newValue) {
                            span.classList.remove('hi-' + oldValue);
                            span.classList.add('hi-' + newValue);
                        }
                    }
                }
            });
        },

        createdCallback: function _() {
            var itemButton;

            _.super(this);
            itemButton = this.querySelector('button');

            this.listenTo(itemButton, 'blur', function() {
                this.unselect();
            }.bind(this));
        },

        /**
         * Callback attached after the Component render
         */
        postRender: function _() {
            var buttonElement,
                spanElement;

            _.super(this);

            buttonElement = this.querySelector('.header-button') || this.ownerDocument.createElement('button');
            spanElement = this.querySelector('span') || this.ownerDocument.createElement('span');
            buttonElement.className = 'header-button';
            buttonElement.appendChild(spanElement);
            buttonElement.classList.add('btn');
            buttonElement.classList.add('btn-link');
            spanElement.classList.add('hi');
            this.appendChild(buttonElement);
        },

        /**
         * Emits the 'select' event and set the 'selected' class to the Page Modal Header Item.
         * @emit select
         */
        select: function() {
            this.emit('select', {target: this});
            this.classList.add('selected');
        },

        /**
         * Removes the 'selected' class from the Page Modal Header Item.
         * @emit unselect
         */
        unselect: function() {
            this.emit('unselect', {target: this});
            this.classList.remove('selected');
        }

    });

    return register('ha-page-modal-header-item', HAPageModalHeaderItem);
});
define('hui/trowser/page-modal-header',[
    'object-utils/classes',
    'register-component/v2/UIComponent',
    'register-component/v2/register',
    '../core/utils'
], function(classes, UIComponent, register, utils) {
    'use strict';

    /**
     * Appends or removes elements from their corresponding container
     * @param  {HTMLElement} component the page-modal-footer
     * @param  {Array} items  array of nodeElements
     * @param  {Function} action appendChild || removeChild
     */
    function _handleHeaderItems(component, items, action) {
        var headerLeft = component.querySelector('.header-left'),
            headerCenter = component.querySelector('.header-center'),
            headerRight = component.querySelector('.header-right'),
            // The "name" property of a function, isn't supported on IE.
            // So, we used a regular expression to get the name of the action.
            // This has cross-browser compatibility.
            actionName = (/function\s([^(]{1,})\(/).exec(action.toString())[1],
            closeItem;

        items.forEach(function(item) {
            switch (item.getAttribute('position') || item.position) {
                case 'left':
                    item.classList.add('pull-left');
                    action.call(headerLeft, item);
                    break;
                case 'right':
                    if (actionName === 'removeChild') {
                        action.call(headerRight, item);
                    } else if (actionName === 'appendChild') {
                        closeItem = component.querySelector('[type="close"]');

                        // If the header has a close button,
                        // we need to add the others elements at his left.
                        if (closeItem) {
                            headerRight.insertBefore(item, closeItem);
                        } else {
                            action.call(headerRight, item);
                        }
                    }
                    break;
                case 'center':
                    action.call(headerCenter, item);
                    break;
            }
        }.bind(component));
    }

    function headerItems(component) {
        var cachedItems = Array.prototype.slice.call(component.querySelectorAll('ha-page-modal-header-item'));
        //This is a workaround for an IE issue. It would be simpler to use a :not selector, but IE throws
        //a syntax error when used in conjunction with the above selector.
        cachedItems = cachedItems.filter(function(element) {
            return element.getAttribute('type') !== 'close';
        });
        return cachedItems;
    }

    function titleTextFrom(component) {
        var titleTextEl = component.querySelector('.title-text');

        return (titleTextEl) ? titleTextEl.textContent : '';
    }

    function infoTextFrom(component) {
        var infoTextEl = component.querySelector('.info-text');

        return (infoTextEl) ? infoTextEl.textContent : '';
    }

    var HAPageModalHeader = classes.createObject(UIComponent, {

        init: function _() {
            _.super(this);

            /**
             * Property with the content of the Page Modal Header (ha-page-modal-header-item).
             * @type {Array}
             */
            this._headerItems = [];

            this.setupProperties({

                /**
                 * Property to set the title of the Page Modal Header.
                 * @type {String}
                 */
                titleText: {
                    type: String,
                    default: '',
                    change: function(newValue) {
                        var titleTextEl,
                            headerCenter;
                        if (newValue) {
                            titleTextEl = this.querySelector('.title-text');
                            headerCenter = this.querySelector('.header-center');
                            if (titleTextEl) {
                                titleTextEl.textContent = newValue;
                            } else {
                                titleTextEl = this.ownerDocument.createElement('label');
                                titleTextEl.textContent = this.titleText;
                                titleTextEl.className = 'title-text pull-left';

                                headerCenter.appendChild(titleTextEl);
                            }
                        }
                    }
                },

                /**
                 * Property to set the secondary info message of the Page Modal Header.
                 * @type {String}
                 */
                infoText: {
                    type: String,
                    default: '',
                    change: function(newValue) {
                        var infoTextEl,
                            headerRight;

                        if (newValue) {
                            infoTextEl = this.querySelector('.info-text');
                            headerRight = this.querySelector('.header-right');
                            if (infoTextEl) {
                                infoTextEl.textContent = this.infoText;
                            } else {
                                infoTextEl = this.ownerDocument.createElement('label');
                                infoTextEl.textContent = this.infoText;
                                infoTextEl.className = 'info-text ghost-text pull-left';
                                //infoText and headerItems change handlers add elements to the right part of the
                                //header. Different instantiations may cause elements to be inserted in different order
                                //Inserting the infoText element at the beggining, prevent these possible differences
                                headerRight.insertBefore(infoTextEl, headerRight.firstChild);
                            }
                        }
                    }
                },

                /**
                 * Property to set if the Page Modal Header shows the close button (true / false).
                 * @type {Boolean}
                 */
                dismissible: {
                    type: Boolean,
                    default: true,
                    change: function(newValue) {
                        var closeButtonContainer = this.querySelector('[type="close"]'),
                            closeButton = closeButtonContainer.querySelector('button');
                        if (newValue) {
                            closeButtonContainer.classList.remove('hidden');
                            closeButtonContainer.classList.add('show');
                            if (closeButton) {
                                closeButton.setAttribute('aria-label', 'close');
                            }
                        } else {
                            closeButtonContainer.classList.remove('show');
                            closeButtonContainer.classList.add('hidden');
                        }
                    }
                }

            });

        },

        set headerItems(items) {
            _handleHeaderItems(this, this._headerItems, Node.prototype.removeChild);
            _handleHeaderItems(this, items, Node.prototype.appendChild);

            this._headerItems = items;
        },

        get headerItems() {
            return this._headerItems;
        },

        createdCallback: function _() {
            _.super(this);
            this.on('ha-page-modal-header-item button:click', function(event) {
                var itemSelected = event.target;

                while (itemSelected.localName !== 'ha-page-modal-header-item') {
                    itemSelected = itemSelected.parentNode;
                }

                if (itemSelected.getAttribute('type') === 'close') {
                    this.emit('dismiss');
                } else {
                    this.select(itemSelected);
                }
            }.bind(this));
        },

        postRender: function _() {
            var el = utils.createElement,
                docFragment = document.createDocumentFragment(),
                items,
                titleText,
                infoText;

            _.super();

            // Cache input
            items = headerItems(this);
            titleText = titleTextFrom(this);
            infoText = infoTextFrom(this);

            // Destroy children
            utils.removeAllChildrenFrom(this);

            // Render the "template"
            utils.appendChildren(docFragment, [
                el('span', {'className': 'header-left'}),
                el('span', {'className': 'header-center'}),
                el('span', {'className': 'header-right pull-right'}, [
                    el('ha-page-modal-header-item', {'icon': 'close', 'position': 'right', 'attr-type': 'close'})
                ])
            ]);

            this.appendChild(docFragment);

            // Set properties with cached values
            this.headerItems = items;
            this.titleText = titleText;
            this.infoText = infoText;
        },

        /**
         * If the clicked button isn't the close button,
         * calls the method 'unselect' of this component
         * and then calls the method 'select' of the Page Modal Header Item.
         * @param {HTMLElement} target The item to select.
         */
        select: function(target) {
            var isCloseButton = target.getAttribute('type');

            if (isCloseButton !== 'close') {
                this.unselect();
                target.select();
            }
        },

        /**
         * If there is a selected item, calls the method 'unselect' of the Page Modal Header Item.
         */
        unselect: function() {
            var currentSelected = this.querySelector('.selected');

            if (currentSelected) {
                currentSelected.unselect();
            }
        }

    });

    return register('ha-page-modal-header', HAPageModalHeader);
});

define('hui/trowser/page-modal',[
    'object-utils/classes',
    'register-component/v2/UIComponent',
    'register-component/v2/register',
    '../core/contentNode',
    '../core/a11y',
    '../core/keys',
    '../core/position',
    '../core/underlay',
    '../core/utils',
    '../core/deviceUtils'
], function(classes, UIComponent, register, contentNode, a11y, keys, position, underlay, utils, deviceUtils) {
    'use strict';

    /**
     * Used to track whether the transition has ended or not
     * @type {String}
     * @private
     */
    var _animationend = 'webkitTransitionName' in document.documentElement.style ? 'webkitTransitionEnd' : 'animationend',

        _replaceContent = function(component, selector, content) {
            utils.replaceChildrenOf(component.querySelector(selector), content);
        },

        addPageModalFooterClass = function(element) {
            if (utils.isNode(element)) {
                element.classList.add('page-modal-footer');
            }
            return element;
        },

        HAPageModal = classes.createObject(UIComponent, {

            init: function _() {
                _.super(this);

                /**
                 * Used for accessibility reasons to set the focus to the last active element
                 * before the PageModal appearance.
                 * @type {HTMLElement}
                 */
                this.lastFocus = null;

                this.setupProperties({

                    /**
                     * Indicates whether the component is rendered into the body by react
                     * @type {Boolean}
                     */
                    reactLayering: {
                        type: Boolean,
                        default: false
                    },

                    /**
                     * Indicates whether the component is visible after calling show
                     * @type {Boolean}
                     */
                    visible: {
                        type: Boolean,
                        default: false
                    },

                    /**
                     * Indicates whether the component closes by default when X is clicked
                     * or ESC key is pressed
                     * @type {Boolean}
                     */
                    noCloseOnDismiss: {
                        type: Boolean,
                        default: false
                    }
                });
            },

            get header() {
                return this._header;
            },

            get section() {
                return this._section;
            },

            get footer() {
                return this._footer;
            },

            set header(content) {
                _replaceContent(this, 'header', content);
                this._header = content;
            },

            set section(content) {
                _replaceContent(this, 'section', content);
                this._section = content;
            },

            set footer(content) {
                addPageModalFooterClass(content);
                _replaceContent(this, 'div.page-modal-panel > footer', content);
                this._footer = content;
            },

            get headerNode() {
                return this.querySelector('div.page-modal-panel > header');
            },

            get footerNode() {
                return this.querySelector('div.page-modal-panel > footer');
            },

            createdCallback: function _() {
                _.super(this);
                this.tabIndex = '-1';
                this.role = 'dialog';
            },

            postRender: function _() {
                var el = utils.createElement,
                    renderedOrUserProvided = utils.contentQueryFactory(this, {
                        'header': 'div.page-modal-panel > header',
                        'section': 'div.page-modal-panel > section',
                        'footer': 'div.page-modal-panel > footer'
                    }),
                    self = this,
                    div, header, section, footer;

                _.super(this);

                // cache input
                header = renderedOrUserProvided('header') || el('header');
                section = renderedOrUserProvided('section');
                footer = renderedOrUserProvided('footer');

                addPageModalFooterClass(footer);

                // destroy children
                utils.removeAllChildrenFrom(this);

                // render the "template"
                div =
                    el('div', {
                        'className': 'page-modal-panel',
                        'attr-aria-hidden': 'true'
                    }, [
                        header,
                        el('section', {'attr-tabindex': '-1'}, [
                            section
                        ]),
                        el('footer', {'attr-tabindex': '-1'}, [
                            footer
                        ])
                    ]);

                this.appendChild(div);

                this.on('keydown', function(evt) {
                    if (evt.keyCode === keys.ESCAPE) {
                        evt.stopPropagation();
                        evt.preventDefault();
                        self.emit('dismiss');
                        if (!this.noCloseOnDismiss) {
                            self.close();
                        }
                    }
                    if (keys.TAB === evt.keyCode) {
                        a11y.keepFocusInsideListener(evt, self);
                    }
                });

                // captures dismiss event fired from page-modal-header
                this.on('dismiss', function(evt) {
                    if (evt.target.tagName === 'HA-PAGE-MODAL-HEADER') {
                        evt.stopImmediatePropagation();
                        self.emit('dismiss');
                        if (!this.noCloseOnDismiss) {
                            self.close();
                        }
                    }
                });

                // initial state is hidden, so add the hidden class
                this.classList.add('hidden');
            },

            show: function() {
                var pageModal,
                    self = this;

                if (!this.visible) {
                    this.visible = true;
                    this.classList.remove('hidden');

                    this.on(_animationend, function onShow() {
                        a11y.setFocusOnFirst(self.querySelector('section'));
                        if (!this.reactLayering) {
                            underlay.show(this);
                        }
                        // bringToFront: 2nd call so that modal will display in front of underlay
                        if (!this.reactLayering) {
                            position.bringToFront(this);
                        }
                        self.off(_animationend, onShow);
                        self.emit('did-show');
                    });

                    // bringToFront: 1st call so that modal will display at front while being animated to visible
                    if (!this.reactLayering) {
                        position.bringToFront(this);
                    }
                    this.lastFocus = this.ownerDocument.activeElement;
                    this.classList.remove('slide-out');
                    this.ownerDocument.body.classList.add('modal-open');

                    pageModal = this.querySelector('.page-modal-panel');
                    pageModal.setAttribute('aria-hidden', false);

                    setTimeout(function() {
                        this.classList.add('slide-in');
                    }.bind(this), 0);

                    if (deviceUtils.isIOSDevice()) {
                        if (this.headerNode) {
                            deviceUtils.stopTouchMove(this.headerNode, true);
                        }
                        if (this.footerNode) {
                            deviceUtils.stopTouchMove(this.footerNode, true);
                        }
                    }
                    this.emit('show');
                }
            },

            /**
             * @deprecated Use the header, section and footer properties instead
             * Sets the content of the page modal
             */
            addContent: function(config) {
                /**
                 * Map that says where  to insert the content that
                 * the consumer sends on the initialization.
                 * @type {Object}
                 */
                var contentPropertyMap = {
                    'header': 'header',
                    'section': 'section',
                    'footer': 'footer'
                };

                contentNode.addContent(this, config, contentPropertyMap);
                console.warn('DEPRECATION WARNING: addContent method should not be used anymore to add ' +
                'content to the component. This will be removed in the future so please assign content ' +
                'directly to the corresponding component properties instead.');
            },

            /**
             * @deprecated Use close method instead
             * Hides the Page Modal component
             */
            hide: function() {
                this.close();
                console.warn('DEPRECATION WARNING: The hide method is deprecated, use "close" method instead');
            },

            /**
             *  Hide the Page Modal component.
             *  @emits  ha-page-modal:close
             */
            close: function() {
                var pageModal,
                    pageModalHeader,
                    self = this;

                if (this.visible) {
                    this.visible = false;

                    this.on(_animationend, function onHide() {
                        self.classList.remove('slide-out');
                        self.stopListening(pageModal, _animationend, onHide);
                        if (self.lastFocus) {
                            self.lastFocus.focus();
                        }
                        self.lastFocus = null;
                        self.off(_animationend, onHide);
                        self.classList.add('hidden');
                        self.emit('did-close');
                    });

                    pageModal = this.querySelector('.page-modal-panel');
                    pageModal.setAttribute('aria-hidden', true);

                    pageModalHeader = this.querySelector('ha-page-modal-header');

                    if (pageModalHeader) {
                        pageModalHeader.unselect();
                    }

                    if (!this.reactLayering) {
                        underlay.hide();
                    }

                    this.classList.remove('slide-in');
                    this.classList.add('slide-out');
                    this.ownerDocument.body.classList.remove('modal-open');

                    if (deviceUtils.isIOSDevice()) {
                        if (this.headerNode) {
                            deviceUtils.stopTouchMove(this.headerNode, false);
                        }
                        if (this.footerNode) {
                            deviceUtils.stopTouchMove(this.footerNode, false);
                        }
                    }
                    this.emit('close');
                }
            }
        });

    return register('ha-page-modal', HAPageModal);
});

define('hui/trowser',[
        'object-utils/classes',
        'register-component/v2/register',
        './trowser/trowser-base',
        './trowser/page-modal-footer',
        './trowser/page-modal-header-item',
        './trowser/page-modal-header',
        './trowser/page-modal'
    ],
    function(classes, register, TrowserBase) {
        'use strict';

        var HATrowser = classes.createObject(TrowserBase, {

            init: function _() {
                _.super(this);

                this.contentSelectorMap = {
                    'section': 'section',
                    'footer': 'footer'
                };
            }
        });

        return register('ha-trowser', HATrowser);
    })
;

define('hui/tab',[
    'register-component/v2/register',
    'object-utils/classes',
    'register-component/v2/UIComponent',
    './core/utils',
    './core/a11y'
], function(register, classes, UIComponent, utils, a11y) {
    'use strict';

    function _createContent(component) {
        var content;
        content = component.ownerDocument.createElement('div');
        content.className = 'content';
        component.appendChild(content);

        return content;
    }

    function setBadge(component, newValue) {
        var badgeEl = component.querySelector('i:not(.hi)'),
            content = component.querySelector('.content'),
            className = newValue.className || component.badgeClass,
            textContent = newValue.textContent || component.badgeText;

        if (!content) {
            content = _createContent(component);
        }

        if (className && textContent) {
            if (badgeEl) {
                badgeEl.className = className;
                badgeEl.textContent = textContent;
            } else {
                content.appendChild(utils.createElement('i', {
                    className: className,
                    textContent: textContent
                }));
            }
        } else {
            if (badgeEl) {
                content.removeChild(badgeEl);
            }
        }
    }

    function updateAccessibility(component) {
        if (component) {
            var titleSpan = component.querySelector('.content>span'),
                titleStrong = component.querySelector('.content>strong'),
                isActive = component.classList.contains('active');

            if (titleSpan && titleStrong) {
                if (isActive) {
                    titleSpan.setAttribute('aria-hidden', true);
                    titleStrong.setAttribute('aria-hidden', false);
                    component.setAttribute('aria-selected', true);
                } else {
                    titleSpan.setAttribute('aria-hidden', false);
                    titleStrong.setAttribute('aria-hidden', true);
                    component.setAttribute('aria-selected', false);
                }
            }
        }
    }

    var HATab = classes.createObject(UIComponent, {

        init: function _() {

            _.super(this);

            this._section = null;

            this.setupProperties({
                /**
                 * The icon to be shown.
                 * @type {String}
                 */
                icon: {
                    default: '',
                    change: function(newValue) {
                        var iconEl = this.querySelector('i.hi'),
                            content = this.querySelector('.content'),
                            lastIcon,
                            titleSpan;

                        if (newValue) {
                            this.classList.add('tab-icon');
                            titleSpan = this.querySelector('span');

                            if (!content) {
                                content = _createContent(this);
                            }

                            if (!iconEl) {
                                iconEl = this.ownerDocument.createElement('i');
                                iconEl.classList.add('hi');

                                if (titleSpan) {
                                    content.insertBefore(iconEl, titleSpan);
                                } else {
                                    content.appendChild(iconEl);
                                }
                            }

                            if (iconEl.classList.length > 1) {
                                lastIcon = iconEl.classList[iconEl.classList.length - 1];
                                iconEl.classList.remove(lastIcon);
                            }

                            iconEl.classList.add(newValue);
                        } else {
                            this.classList.remove('tab-icon');
                            if (iconEl) {
                                content.removeChild(iconEl);
                            }
                        }
                    }
                },

                /**
                 * The title that the tab should show.
                 * @type {String}
                 */
                titleText: {
                    default: '',
                    change: function(newValue) {
                        var titleSpan = this.querySelector('.content>span'),
                            titleStrong = this.querySelector('.content>strong'),
                            content = this.querySelector('.content');

                        if (newValue) {
                            if (!content) {
                                content = _createContent(this);
                            }

                            if (!titleSpan && !titleStrong) {

                                titleSpan = this.ownerDocument.createElement('span');
                                titleSpan.textContent = newValue;

                                titleStrong = this.ownerDocument.createElement('strong');
                                titleStrong.textContent = newValue;

                                content.appendChild(titleSpan);
                                content.appendChild(titleStrong);

                            } else {
                                titleSpan.textContent = newValue;
                                titleStrong.textContent = newValue;
                            }

                            updateAccessibility(this);
                        } else if (titleSpan && titleStrong) {
                            titleStrong.innerHTML = '';
                            titleSpan.innerHTML = '';
                        }
                    }
                },
                badgeClass: {
                    default: '',
                    change: function(newValue, oldValue) {
                        if (newValue || !newValue && oldValue) {
                            setBadge(this, {
                                className: newValue
                            });
                        }
                    }
                },
                badgeText: {
                    default: '',
                    change: function(newValue, oldValue) {
                        if (newValue || !newValue && oldValue) {
                            setBadge(this, {
                                textContent: newValue
                            });
                        }
                    }
                }
            });

        },

        /**
         * The content that the consumer passthrough.
         * We need to cached here so then the ha-tabs can move it to the
         * right place.
         * @protected
         * @type {Array}
         * @emits section-property-change
         */
        set section(content) {

            if (!Array.isArray(content)) {
                content = [content];
            }

            this._section = content;

            this.emit('section-property-change');
        },

        get section() {
            return this._section;
        },

        set active(isActive) {
            if (isActive) {
                this.classList.add('active');
            } else {
                this.classList.remove('active');
            }

            updateAccessibility(this);
        },

        get active() {
            return this.classList.contains('active');
        },

        preRender: function _() {
            _.super(this);
        },

        postRender: function _() {
            var elementsArray,
            i,
            component,
            sectionSelector;

            _.super(this);

            this.setAttribute('role', 'tab');

            elementsArray = [];

            for (i = 0; i < this.childNodes.length; i++) {
                if (!this.childNodes[i].classList || !this.childNodes[i].classList.contains('content')) {
                    elementsArray.push(this.childNodes[i]);
                }
            }

            /* This component has a different behavior than the rest. Html elements from 'section'
            property, are moved to the corresponding section on the parent 'ha-tabs'. For that reason,
            we need to search for the elements.
            */
            if (elementsArray.length === 0 && this.id) {
                component = utils.getComponentFromElement(this, 'HA-TABS');
                sectionSelector = '#' + this.getAttribute('aria-controls');

                this.section = [].slice.call(component.querySelector(sectionSelector).childNodes);
            } else {
                this.section = elementsArray;
            }

            a11y.addA11yFocus(this);
        }
    });

    return register('ha-tab', HATab);
});

define('hui/core/ResponsiveBase',[
    'object-utils/classes',
    'register-component/v2/UIComponent',
    './deviceUtils'
], function(classes, UIComponent, deviceUtils) {
    /**
     * This class provides a base for responsive components.
     * It's not necessary for a component to extend this to be responsive,
     * but it provides an API hook which is automatically registered with
     * the deviceUtils module as a callback in response to orientation or
     * viewport size changes.
     * @type {Object}
     */
    var ResponsiveBase = classes.createObject(UIComponent, {

        attachedCallback: function _() {
            this._resizeHandle = deviceUtils.registerCallback('_resize', this);
        },
        detachedCallback: function _() {
            this._resizeHandle.remove();
        },

        /**
         * Override resize to allow this component to respond to
         * notifications when the orientation or viewport size changes
         *
         * Takes two arguments
         * screenParameters: The current parameters of the viewport
         * It has the following properties:
         * deviceType 'pc', 'mobile', or 'tablet'
         * orientation 'landscape' or 'portrait'
         * width viewport width in pixels
         * height viewport height in pixels
         * isDesktop flag indicating whether this is running in a desktop environment
         * oldScreenParameters: The previous parameters of the viewport
         */
        _resize: function() {

        }
    });

    return ResponsiveBase;
});


define('hui/core/menuItemUtils',[],function() {
    function createMenuItem(item, attributes, customRenderer, ownerDocument) {
        var menuItem = ownerDocument.createElement('ha-menu-item');

        menuItem.value = item.value || item.getAttribute('value');
        menuItem.sanitizeInputs = item.sanitizeInputs || false;

        if ((item.hasAttribute('disabled') && item.getAttribute('disabled') !== false) || item.disabled) {
            menuItem.disabled = true;
        }

        if (typeof customRenderer === 'function') {
            menuItem.label = customRenderer(item);
        } else {
            menuItem.label = item.label || item.textContent;
        }

        if (attributes) {
            Object.keys(attributes).forEach(function(key) {
                menuItem.setAttribute(key, attributes[key]);
            });
        }

        return menuItem;
    }

    return {
        createMenuItemLabelWrapper: function(ownerDocument, arrayOfElementsToAppend) {
            var span = ownerDocument.createElement('span');
            span.classList.add('menu-item-label');

            if (Array.isArray(arrayOfElementsToAppend)) {
                arrayOfElementsToAppend.forEach(function(el) {
                    span.appendChild(el);
                });
            }

            return span;
        },

        /**
         * Creates a single ha-menu-item from ha-item. Applies custom renderers
         * @param  {[HTMLElement]} items The array of ha-item
         * @param  {Object} attributes Attributes to be set to ha-menu-item
         * @param  {Function} customRenderer Function to be called when rendering label nodes
         * @param  {Document} ownerDocument ownerDocument used for creating the element
         * @return {HTMLElement} The <ha-menu-item> element.
         */
        createMenuItem: createMenuItem,
        /**
         * Creates an array of ha-menu-items from ha-item. Applies custom renderers
         * @param  {[HTMLElement]} items The array of ha-item
         * @param  {Object} attributes Attributes to be set to ha-menu-item
         * @param  {Function} customRenderer Function to be called when rendering label nodes
         * @param  {Document} ownerDocument ownerDocument used for creating the element
         * @return {[HTMLElement]} Array of <ha-menu-item>
         */
        createMenuItems: function(items, attributes, customRenderer, ownerDocument) {
            return items.map(function(item) {
                return createMenuItem(item, attributes, customRenderer, ownerDocument);
            });
        }
    };
});

define('hui/menu',[
    'object-utils/classes',
    'register-component/v2/register',
    'register-component/v2/UIComponent',
    './core/keys',
    './core/utils',
    './core/deviceUtils'
],
function(classes, register, UIComponent, keys, utils, deviceUtils) {

    /**
     * Searches trought the menu-items for a label with the current search term and set focus on the result (if any)
     * @param  {HTMLElement} component ha-menu where the search is made
     * @private
     */
    function _search(component) {
        var searchTerm = component._searchTerm.toLowerCase(),
            searchTermLength = searchTerm.length,
            activeElement = component.ownerDocument.activeElement,
            currentPos = -1,
            position = 0;

        if (activeElement) {
            currentPos = component.items.indexOf(activeElement);
        }

        if ((currentPos !== -1) && (currentPos !== component.items.length - 1)) {
            position = currentPos + 1;
        }

        while (position !== currentPos)  {
            if (component.items[position].label.toLowerCase().substr(0, searchTermLength) === searchTerm &&
                !component.items[position].disabled) {
                component.items[position].focus();
                currentPos = position;
            } else {
                if (position === component.items.length - 1) {
                    position = 0;
                } else {
                    ++position;
                }
            }
        }

        // Reset to original state
        component._timeOut = null;
        component._searchTerm = null;
    }

    /**
     * Adds/removes current selected item to the selected elements
     * @param  {HTMLElement} component ha-menu to update selected property
     * @param  {HTMLElement} menuItem  ha-menu-item to add/remove to the selected list
     * @emits   HAMenu#select
     * @private
     */
    function _selectItem(component, menuItem) {
        var items = component.items;

        if (!items.length) {
            return;
        }

        // unselect all
        items.forEach(function(item) {
            item.selected = false;
            item.setAttribute('aria-selected', false);
        });

        component._selectedItem = menuItem;

        if (component.selectedIndex !== items.indexOf(menuItem)) {
            component.selectedIndex = items.indexOf(menuItem);
        }

        menuItem.selected = true;
        menuItem.setAttribute('aria-selected', true);
    }

    /**
     * Determinates if the menuItem is a selectable type and is not disabled
     * @param  {HTMLElement}  menuItem ha-menu-item to be selected
     * @return {Boolean}          If the menuItem can be selected
     * @private
     */
    function _isSelectableItem(menuItem) {
        return menuItem.type !== 'separator' && !menuItem.disabled;
    }

    /**
     * Search for next focusable element in the given order and set focus on it
     * @param  {Array} items       List of menu items
     * @param  {String} direction   Direction to search for next menu item. Can be 'up' or 'down'
     * @param  {Number} position    Position where to start search
     * @param  {Number} endPosition Optional. Position where to stop searching
     * @private
     */
    function _focusOnNextSelectable(items, direction, position, endPosition) {
        var length = items.length;

        while (position > -1 && position < length) {
            if (position === endPosition) {
                return;
            }
            if (_isSelectableItem(items[position])) {
                items[position].focus();
                return;
            }
            if (direction === 'down') {
                position++;
            } else {
                position--;
            }
        }
    }

    function _getValidMenuItemTarget(element) {
        return utils.closest(element, 'ha-menu-item');
    }

    var HAMenu,

        // Constant height of ha-menu-items
        MENU_ITEM_HEIGHT = 34;

    HAMenu = classes.createObject(UIComponent, {

        init: function _() {

            _.super(this);

            /**
             * Selected HAMenuItem.
             * @type {HTMLElement}
             */
            this._selectedItem = null;

            /**
             * List of HAMenuItems included in the menu
             * @type {Array}
             */
            this._items = null;

            this.setupProperties({

                /**
                 * Whether or not items should be forcibly sanitized
                 * @type {Boolean}
                 */
                sanitizeInputs: {
                    default: false,
                    type: Boolean,
                    change: function(newValue) {
                        this.setAttribute('sanitizeInputs', newValue);
                        if (this.items) {
                            this.items.forEach(function(it) {
                                it.sanitizeInputs = newValue;
                            });
                        }
                    }
                },

                /**
                 * Position of the HAMenuItems currently selected
                 * @type {Number}
                 */
                selectedIndex: {
                    default: -1,
                    type: Number,
                    change: function(newValue) {
                        if (newValue === -1) {
                            this._selectedItem = null;
                        } else if ((newValue >= 0) && (newValue < this.length)) {
                            var menuItem = this.items[newValue];
                            if (this.selectedItem !== menuItem) {
                                _selectItem(this, menuItem);
                                this.emit('select');
                            }
                        } else {
                            this._selectedIndex = -1;
                        }
                    }
                },

                /**
                 * Amount of items to be visible at once. If smaller than length, a scrollbar is shown.
                 * If size property is bigger than 0, adjusts the height of the ha-menu.
                 * @type {Number}
                 */
                size: {
                    default: 0,
                    type: Number,
                    change: function(newValue) {
                        if (newValue) {
                            if (newValue === 7) {
                                this.style.maxHeight = ((newValue * MENU_ITEM_HEIGHT) + 15) + 'px' ;
                            } else {
                                this.style.maxHeight = (newValue * MENU_ITEM_HEIGHT) + 'px' ;
                            }
                            this.style.overflowY = 'auto';
                        } else {
                            this.style.maxHeight = 'none';
                            this.style.overflowY = 'hidden';
                        }
                    }
                }
            });

            this.tabIndex = -1;
            if (!this.hasAttribute('role')) {
                this.setAttribute('role', 'menu');
            }

            this.on('ha-menu-item:click', function(ev) {
                var menuItem = _getValidMenuItemTarget(ev.target);
                if (!menuItem) {
                    return;
                }
                if (_isSelectableItem(menuItem)) {
                    _selectItem(this, menuItem);
                    this.emit('select', {detail: {selectedByClickOrKeyboard: true}});
                }
            }.bind(this));

            if (deviceUtils.isHandheld()) {
                this.on('ha-menu-item:touchstart', function(evt) {
                    var menuItem = utils.getComponentFromElement(evt.target, 'HA-MENU-ITEM');
                    if (!menuItem && evt.target.classList.contains('menu-item-label')) {
                        menuItem = utils.getComponentFromElement(evt.target.parentElement, 'HA-MENU-ITEM');
                    }
                    if (menuItem && _isSelectableItem(menuItem)) {
                        // Delay this so the click event can add the appropriate styling if it's going to fire.
                        menuItem.focus();
                    }
                }.bind(this));

            }

            this.on('keydown', function(evt) {
                var menuItem = evt.target,
                    items = this.items,
                    position;

                // If a letter or number is entered, we start the search process
                if (keys.isLetter(evt.keyCode) || keys.isNumber(evt.keyCode)) {
                    utils.stopEvent(evt);
                    if (this._timeOut) {
                        clearTimeout(this._timeOut);
                    } else {
                        this._searchTerm = '';
                    }
                    this._searchTerm += String.fromCharCode(evt.keyCode);
                    this._timeOut = setTimeout(function() {
                        _search(this);
                    }.bind(this), 1000);
                    return;
                }

                // If the menu was open by click, thus focus in not on the items
                if (menuItem.tagName !== 'HA-MENU-ITEM' && (evt.keyCode === keys.UP || evt.keyCode === keys.DOWN ||
                    evt.keyCode === keys.END || evt.keyCode === keys.HOME)) {
                    utils.stopEvent(evt);
                    items[0].focus();
                    return;
                }

                switch (evt.keyCode){
                    case keys.UP:
                        utils.stopEvent(evt);
                        position = (items.indexOf(menuItem) === 0 ? items.length - 1 : items.indexOf(menuItem) - 1);
                        _focusOnNextSelectable(items, 'up', position);
                        break;
                    case keys.DOWN:
                        utils.stopEvent(evt);
                        _focusOnNextSelectable(items, 'down', (items.indexOf(menuItem) + 1) % items.length);
                        break;
                    case keys.END:
                        utils.stopEvent(evt);
                        _focusOnNextSelectable(items, 'up', items.length - 1, items.indexOf(menuItem));
                        break;
                    case keys.HOME:
                        utils.stopEvent(evt);
                        _focusOnNextSelectable(items, 'down', 0, items.indexOf(menuItem));
                        break;
                    case keys.ENTER:
                    case keys.SPACEBAR:
                        if (menuItem.tagName === 'HA-MENU-ITEM' && _isSelectableItem(menuItem)) {
                            utils.stopEvent(evt);
                            _selectItem(this, menuItem);
                            this.emit('select', {detail: {selectedByClickOrKeyboard: true}});
                        }
                        break;
                    default:
                        return;
                }
            }.bind(this), true);

            this.on('ha-menu-item:mousemove', function(evt) {
                var popover = evt.target;
                while (popover && popover.tagName !== 'HA-POPOVER') {
                    popover = popover.parentElement;
                }

                if (!popover || !popover.classList.contains('leave')) {
                    evt.target.focus();
                }
            }.bind(this), true);
        },

        /**
         * Sets the items usually from an array of ha-menu-items.
         * If items array contains literal objects instead of ha-menu-item, it creates them. (deprecated)
         * @param {HTMLElement} items Array of ha-menu-item or ha-item
         */
        set items(items) {
            var nodeItem;

            this.tabIndex = -1;
            while (this.firstChild) {
                this.removeChild(this.firstChild);
            }

            if (Array.isArray(items)) {
                items.forEach(function(item) {
                    if (item.nodeType) {
                        nodeItem = item;
                    } else {
                        // deprecated path, we should not accept non ha-menu-items
                        nodeItem = this.ownerDocument.createElement('ha-menu-item');
                        Object.keys(item).forEach(function(key) {
                            nodeItem[key] = item[key];
                        });
                    }
                    nodeItem.sanitizeInputs = this.sanitizeInputs;
                    nodeItem.setAttribute('aria-selected', !!nodeItem.selected);
                    this.appendChild(nodeItem);
                }, this);

                this.length = items.length;
            }

            this._items = items;
        },

        /**
         * @return {Array} Array of ha-menu-item
         */
        get items() {
            return this._items;
        },

        get selected() {
            console.warn('DEPRECATION WARNING: selected property is deprecated. Use selectedItem instead');
            return this._selectedItem;
        },

        get selectedItem() {
            return this._selectedItem;
        },

        /**
         * Dummy method to avoid problems with getter without setters
         * @param {Boolean} newValue Dummy arg
         */
        set selected(newValue) {
            // jshint unused:false
        },

        /**
         * Number of HAMenuItems included in the menu
         */
        get length() {
            return this._items.length;
        },

        /**
        * Dummy method to avoid problems with getter without setters
        */
        set length(newValue) {
            // jshint unused:false
        },

        /**
         * Sets the list of ha-menu-item
         */
        preRender: function() {
            var items = this.querySelectorAll('ha-menu-item');

            this.items = utils.removeNodesSafe(this, items);
        },

        /**
         * Adds a Menu Item to the ha-menu
         * @param {HTMLElement} menuItem ha-menu-Item to add to the ha-menu
         * @param {Number} position (Optional) Sets in which position to add the ha-menu-Item
         */
        add: function(menuItem, position) {
            position = (typeof position !== 'undefined') ? position : this.items.length;
            this.items.splice(position, 0, menuItem);
            // To call setter
            this.items = this.items;
        },

        /**
         * Removes a Menu Item from the ha-menu
         * @param  {Number} position Position of the ha-menu-Item to me removed from the ha-menu
         */
        remove: function(position) {
            if (position >= 0 && position < this.items.length) {
                this.items.splice(position, 1);
                // To call setter
                this.items = this.items;
            }
        }
    });

    return register('ha-menu', HAMenu);
});

define('hui/menu-item',[
    'register-component/v2/register',
    'register-component/v2/UIComponent',
    'object-utils/classes',
    './core/deviceUtils',
    './core/menuItemUtils'
],
function(register, UIComponent, classes, deviceUtils, menuItemUtils) {

    /**
     * Retrieve only the text content of given value, and in case that we have HTML tags, remove it.
     * @param {String} dirtyValue The value that will be cleaned.
     * @return {String} The sanitized value
     * @private
     */
    function _getTextContent(dirtyValue) {
        if (dirtyValue) {
            return dirtyValue.replace(/<\/?[^>]+(>|$)/g, '');
        }
    }

    var HAMenuItem = classes.createObject(UIComponent, {

        init: function _() {

            _.super(this);

            /**
             * The textual portion of the info menu item
             * @type {String|HTMLElement}
             */
            this._label = '';

            this.setupProperties({
                /**
                 * Whether or not items should be forcibly sanitized
                 * @type {Boolean}
                 */
                sanitizeInputs: {
                    default: false,
                    type: Boolean,
                    change: function(newValue) {
                        this.setAttribute('sanitizeInputs', newValue);
                        // force update of label
                        this.label = this.label;
                    }
                },

                /**
                 * This is the value for the menu-item
                 * @type {String}
                 */
                value: {
                    default: ''
                },

                /**
                 * Disabled indicates if the menu button is disabled.
                 * @type {Boolean}
                 */
                disabled: {
                    default: false,
                    type: Boolean,
                    change: function(newValue) {
                        if (newValue) {
                            this.classList.add('disabled');
                            this.setAttribute('disabled', 'disabled');
                            this.setAttribute('aria-disabled', 'true');
                        } else {
                            this.classList.remove('disabled');
                            this.removeAttribute('disabled');
                            this.removeAttribute('aria-disabled');
                        }
                    }
                },

                /**
                 * Defines whether the component is selected by default.
                 * @type {Boolean}
                 */
                selected: {
                    default: false,
                    type: Boolean
                },

                /**
                 * Type of the component. Possible values are: 'default', 'separator'
                 * @type {String}
                 */
                type: {
                    default: 'default',
                    change: function(newValue) {
                        if (newValue === 'separator') {
                            this.classList.add('separator');
                            this.textContent = '';
                        } else {
                            this.classList.remove('separator');
                        }
                    }
                }
            });

        },

        /**
         * The textual portion of the info menu item
         * @param {String|HTMLElement} newValue The label param to process.
         */
        set label(newValue) {

            if (this.type === 'default') {
                var sanValue;
                if (typeof newValue === 'string') {
                    this.setAttribute('aria-label', _getTextContent(newValue));
                    sanValue = this.sanitizeInputs ? _getTextContent(newValue) : newValue;
                    this.setUpTextLabel(sanValue);

                } else if (newValue) {
                    if (this.sanitizeInputs) {
                        // we have been given a node, but we want to sanitize it down to text
                        sanValue = _getTextContent(newValue.textContent);
                        this.setAttribute('aria-label', sanValue);
                        this.setAttribute('label', sanValue);
                        this.setUpTextLabel(sanValue);
                    } else {
                        // allow user to bypass sanitization.
                        // not recommended, but allowed.
                        this.removeAttribute('label');
                        this.removeAttribute('aria-label');
                        if (newValue.nodeType) {
                            this.appendChild(newValue);
                        }
                    }
                }
                if (sanValue) {
                    this._label = sanValue;
                } else {
                    this._label = newValue;
                }
            }
        },

        get label() {
            return this._label;
        },

        /**
         * Set up the textual portion of the label
         */
        setUpTextLabel: function(newValue) {
            this.setAttribute('label', newValue);
            var labelNode;
            // create menu-item-label wrapper if not an empty string
            if (newValue) {
                labelNode = this.querySelector('span.menu-item-label');

                if (!labelNode) {
                    while (this.firstChild) {
                        this.removeChild(this.firstChild);
                    }
                    labelNode = menuItemUtils.createMenuItemLabelWrapper(this.ownerDocument);
                    this.appendChild(labelNode);
                }

                while (labelNode.firstChild) {
                    labelNode.removeChild(labelNode.firstChild);
                }
            }

            if (labelNode) {
                labelNode.innerHTML = newValue;
            }
        },

        postRender: function _() {
            _.super(this);

            this.tabIndex = -1;
            this.label = this.textContent;
            this.value = this.getAttribute('value') || this.label;
            this.setAttribute('role', 'button');
            if (deviceUtils.isHandheld()) {
                this.classList.add('mobile-menu-item');
            }
        }
    });

    return register('ha-menu-item', HAMenuItem);
});

define('hui/item',[
    'register-component/v2/UIComponent',
    'register-component/v2/register',
        'object-utils/classes',
        './core/domObserver'
],
function(UIComponent, register, classes, domObserver) {
    'use strict';

    /**
     * Retrieve only the text content of given value, and in case that we have HTML tags, remove it.
     * @param {String} dirtyValue The value that will be cleaned.
     * @return {String} The sanitized value
     * @private
     */
    function _getTextContent(dirtyValue) {
        if (dirtyValue) {
            return dirtyValue.replace(/<\/?[^>]+(>|$)/g, '');
        }
    }

    var HASItem;

    HASItem = classes.createObject(UIComponent, {

        init: function _() {

            _.super(this);

            this._label = '';

            this._sanitizeInputs = false;

            this.setupProperties({

                /**
                 * Whether or not items should be forcibly sanitized
                 * @type {Boolean}
                 */
                sanitizeInputs: {
                    default: false,
                    type: Boolean,
                    change: function(newValue) {
                        this.setAttribute('sanitizeInputs', newValue);
                        // force update of the label
                        this.label = this.label;
                        this._sanitizeInputs = newValue;
                    }
                },

                /**
                * Value of the component.
                * @type {String}
                */
                value: {
                    default: '',
                    type: String
                },

                /**
                 * Label of the component.
                 * @type {String}
                 */
                label: {
                    default: '',
                    type: String,
                    change: function(newValue) {
                        if (this._labelBinding) {
                            this._labelBinding.pause();
                        }
                        if (this.sanitizeInputs) {
                            // sanitize the inputs
                            var sanValue = _getTextContent(newValue);
                            this.textContent = sanValue;
                            this._label = sanValue;
                        } else {
                            // allow our consumers to do potentially dangerous things
                            this.innerHTML = newValue;
                            this._label = newValue;
                        }

                        if (this._labelBinding) {
                            this._labelBinding.resume();
                        }
                    }
                }
            });

        },

        postRender: function _() {
            _.super(this);

            this.label = this.sanitizeInputs ? _getTextContent(this.textContent) : this.innerHTML;
            this.value = this.getAttribute('value') || this.label;
        },

        attachedCallback: function() {
            this._labelBinding = domObserver.bindContentChanges(this, this, 'label', function() {
                return this.sanitizeInputs ? _getTextContent(this.textContent) : this.innerHTML;
            }.bind(this));
        },

        detachedCallback: function() {
            if (this._labelBinding) {
                this._labelBinding.remove();
                this._labelBinding = null;
            }
        }
    });

    return register('ha-item', HASItem);
});

define('hui/menu/menu-based-buttons',[
    'object-utils/classes',
    '../core/ResponsiveBase',
    '../core/popup',
    '../core/utils',
    '../core/deviceUtils',
    '../core/keys',
    '../core/menuItemUtils',
        '../core/domObserver',
    '../popover',
    '../modal',
    '../menu',
    '../menu-item',
    '../item'
],
    function(classes, ResponsiveBase, popup, utils, deviceUtils, keys, menuItemUtils, domObserver) {
    'use strict';

    /**
     * Helper to show the popover based on positionTarget
     * @param {HTMLElement} popover The popover with menu items to show.
     * @param {HTMLElement} positionTarget The element that should be used to position the popover when it is opened.
     * @private
     */
    function _showPopover(popover, positionTarget) {
        if (popover) {
            if (_isOpen(popover)) {
                popup.setPosition(popover, positionTarget, ['bottom', 'top'], ['left', 'right']);
            } else {
                popup.show(popover, positionTarget, ['bottom', 'top'], ['left', 'right']);
            }
        }
    }

    /**
     * Helper to hide the popover
     * @param {ha-popover | ha-modal} popover the popover to hide
     * @private
     */
    function _hidePopover(popover) {
        if (popover) {
            if (popover.nodeName === 'HA-MODAL') {
                popover.close();
            } else {
                popup.hide(popover);
            }
        }
    }

    /**
     * Checks whether the popover
     * @param {ha-popover | ha-modal} popover
     * @returns {*|boolean}
     * @private
     */
    function _isOpen(popover) {
        return popover && (
                (popover.nodeName === 'HA-POPOVER' && popover.open) ||
                (popover.nodeName === 'HA-MODAL' && popover.classList.contains('show'))
            );
    }

    /**
     * Displays the popover or modal
     * @param {HAPopover | HAModal} popover
     * @param {HTMLElement} positionTarget - The element to display the popover relative to
     * @param {HTMLElement} triggerElement - The triggering element of the component
     * @private
     */
    function _showPopoverMenu(popover, positionTarget, triggerElement) {
        triggerElement.setAttribute('aria-expanded', 'true');
        triggerElement.classList.add('active');

        // logically if you think about it, the setting of properties in popoverMenu should be in postRender
        // but due to cloneNode issues, it sets first to true, then the popover.postRender gets called which sets it again to false
        // setting it here guarantees it is always true

        // do not focus on popoverMenu child element on show
        popover._noAutoFocusFirstTabbableElementOnShow = true;
        // when have a popoverMenu open and we click outside it should not focus back to the component
        popover._noAutoFocusLastActiveElementOnClose = true;

        // the positionTarget is the triggerElement in this case
        _showPopover(popover, positionTarget);
    }

    /**
     * Update the class and aria-expanded attribute of the component and then delegate to `_hidePopover` to
     * handle actually closing the dropdown menu
     * @param {HAModal | HAPopover} popover - the popover to hide
     * @param {HTMLElement} triggerElement - The trigger element of the component
     * @param {Number} delay - An optional amount of time to delay hiding the popover. It needs to be hidden at
     * least on the next turn for reasons related to style/focus updates.
     * @private
     */
    function _hidePopoverMenu(popover, triggerElement, delay) {
        if (!_isOpen(popover)) {
            return;
        }

        triggerElement.setAttribute('aria-expanded', 'false');
        setTimeout(function() {
            _hidePopover(popover);
        }, delay || 0);
    }

    var menuBasedButtons = classes.createObject(ResponsiveBase, {

        init: function _() {
            _.super(this);

            /**
             * Element that is contained inside the ha-popover
             * @type {HTMLElement}
             * @deprecated
             */
            this._popover = null;

            /**
             * List of HAMenuItems
             * @type {Array}
             */
            this._items = null;

            this.setupProperties({

                /**
                 * This is the text for the button.
                 * @type {String}
                 */
                label: {
                    default: '',
                    type: String,
                    change: function(newValue) {
                        var label = this.querySelector('.label'),
                            menu = this.dropdownElement.querySelector('ha-menu');

                        label.innerHTML = newValue;
                        menu.setAttribute('aria-label', newValue);
                    }
                },

                /**
                 * Selected item index.
                 * @type {Number}
                 */
                selectedIndex: {
                    default: -1,
                    type: Number,
                    change: function(newValue) {
                        var menu = this.dropdownElement.querySelector('ha-menu');

                        if (Array.isArray(this.items) && newValue > -1 && newValue < this.items.length) {
                            menu.selectedIndex = this.selectedIndex;
                        } else if (newValue !== -1) {
                            this.selectedIndex = -1;
                        }
                    }
                },

                /**
                 * Flag indicating that focus should be restored after an item is selected.
                 * Defaults to false
                 *
                 * @type {Boolean}
                 */
                noFocusBackOnSelect: {
                    default: false,
                    type: Boolean
                }
            });
        },

        /**
         * Creates the necessary HTML elements
         */
        postRender: function _() {
            _.super(this);

            this._setupComponent();
        },

        _setupComponent: function() {
            var existingPopover = this.dropdownElement,
                triggerElement = this._getTriggerElement();

            if (deviceUtils.isHandheld()) {
                this.classList.add('mobile-menu-based-button');
            }
            // if button portion is already existing, don't render again
            if (!triggerElement) {
                triggerElement = this._renderTriggerElement();
            } else {
                triggerElement.id = this._getTargetSelectorId();
            }

            if (existingPopover && existingPopover.parentNode) {
                existingPopover.parentNode.removeChild(existingPopover);
            }
            // create popoverMenu
            this._initPopover(triggerElement);

            this.listenTo(triggerElement, 'click', function(evt) {
                var popoverMenu = this.dropdownElement;
                if (this.disabled) {
                    return;
                }

                // should not emit click events
                evt.stopPropagation();

                // FF and Safari looses focus on the triggerElement when clicked
                // use workaround below to focus again
                triggerElement.focus();

                if (_isOpen(popoverMenu)) {
                    _hidePopoverMenu(popoverMenu, triggerElement);
                } else {
                    _showPopoverMenu(popoverMenu, this, triggerElement);
                }
            }.bind(this));

            this.listenTo(triggerElement, 'blur', function(evt) {
                var safeTarget = utils.getSafeTargetFromEvent(evt),
                    popoverMenu = this.dropdownElement;

                if (!this.contains(safeTarget) && !popoverMenu.contains(safeTarget)) {
                    _hidePopoverMenu(popoverMenu, triggerElement);
                    this.emit('blur');
                }
            }.bind(this), true);

            this.listenTo(triggerElement, 'keydown', function(evt) {
                var popoverMenu = this.dropdownElement,
                    menu = popoverMenu.querySelector('ha-menu');
                if (this.disabled) {
                    return;
                }

                switch (evt.keyCode) {
                    case keys.SPACEBAR:
                    case keys.ENTER:
                        utils.stopEvent(evt);
                        if (!_isOpen(popoverMenu)) {
                            _showPopoverMenu(popoverMenu, this, triggerElement);
                        }
                        break;
                    case keys.DOWN:
                        utils.stopEvent(evt);
                        this._showWithAlignment(popoverMenu, menu, triggerElement, 'position-bottom');
                        break;
                    case keys.UP:
                        utils.stopEvent(evt);
                        this._showWithAlignment(popoverMenu, menu, triggerElement, 'position-top');
                        break;
                }
            }.bind(this), true);

            this.on('keydown', function(evt) {
                var popoverMenu = this.dropdownElement;
                if (this.disabled) {
                    return;
                }

                if (evt.keyCode === keys.TAB || evt.keyCode === keys.ESCAPE) {
                    if (_isOpen(popoverMenu)) {
                        utils.stopEvent(evt);
                        _hidePopoverMenu(popoverMenu, triggerElement);
                        // focuses back to the triggerElement so that pressing SPACE opens the popoverMenu again
                        triggerElement.focus();
                    }
                }
            }.bind(this));

            // Fix for FF triggering click when pressing spacebar
            this.listenTo(triggerElement, 'keyup', function(evt) {
                /* istanbul ignore if */
                if (evt.keyCode === keys.SPACEBAR) {
                    evt.preventDefault();
                }
            }, true);
        },

        /**
         * Initializes the dropdown element, handling the logic to create either an ha-modal or ha-popover
         * @param {HTMLElement} triggerElement
         * @returns {Element}
         * @private
         */
        _initPopover: function(triggerElement) {
            this._dropdownElement = null;
            var popoverMenu = this.ownerDocument.createElement(this.modal ? 'ha-modal' : 'ha-popover'),
                menu;

            popoverMenu.classList.add('popover-menu-items');

            popoverMenu.targetSelector = '#' + this._getTargetSelectorId();
            // create menu and assign to popover section
            menu = this.ownerDocument.createElement('ha-menu');

            popoverMenu.section = menu;
            if (this.label) {
                menu.setAttribute('aria-label', this.label);
            }
            this.appendChild(popoverMenu);
            this.items = Array.prototype.slice.apply(this.querySelectorAll('ha-item'));

            if (deviceUtils.isHandheld()) {
                popoverMenu.classList.add('mobile-menu');
                popoverMenu.classList.add('from-bottom');
                if (this.modal) {
                    popoverMenu.on('click', function(event) {
                        if (event.target === this.querySelector('.modal')) {
                            popoverMenu.emit('dismiss');
                            popoverMenu.close();
                        }
                    });
                }
            }

            this.listenTo(popoverMenu, 'show', function(evt) {
                evt.stopPropagation();
                this.emit('items-show');
            }.bind(this));

            this.listenTo(popoverMenu, 'close', function(evt) {
                evt.stopPropagation();
                this.emit('items-close');
                if (this._focusOnNextClose) {
                    triggerElement.focus();
                    this._focusOnNextClose = false;
                }
                triggerElement.classList.remove('active');
            }.bind(this));

            // backward-compatibility popover hide event, stop bubbling
            this.listenTo(popoverMenu, 'hide', function(evt) {
                evt.stopPropagation();
            });

            // menu items should not emit click events
            this.listenTo(menu, 'click', function(evt) {
                evt.stopPropagation();
            }.bind(this));

            this.listenTo(menu, 'select', function(evt) {
                this._handleSelect(evt, triggerElement, popoverMenu);
            }.bind(this));

            this.listenTo(triggerElement, 'blur', function(evt) {
                var safeTarget = utils.getSafeTargetFromEvent(evt);
                if (!popoverMenu.contains(safeTarget)) {
                    triggerElement.classList.remove('active');
                }
            }.bind(this));

            // on an opened popover when user passes his mouse over the popover and clicks
            // on another component, this makes sure to hide the popover
            this.listenTo(popoverMenu, 'blur', function(evt) {
                var safeTarget = utils.getSafeTargetFromEvent(evt);
                if (!this.contains(safeTarget) && !popoverMenu.contains(safeTarget)) {
                    triggerElement.classList.remove('active');
                    _hidePopoverMenu(popoverMenu, triggerElement);
                    this.emit('blur');
                }
            }.bind(this), true);

            this.listenTo(popoverMenu, 'keydown', function(evt) {
                if (evt.keyCode === keys.TAB) {
                    triggerElement.focus();
                    utils.stopEvent(evt);
                }
            }.bind(this));

            return popoverMenu;
        },

        _getPopover: function() {
            if (this._dropdownElement) {
                return this._dropdownElement;
            } else {
                this._dropdownElement = this.querySelector(this.modal ? 'ha-modal' : 'ha-popover');
                return this._dropdownElement;
            }
        },

        /**
         * Handles updating styles, hiding the dropdown menu, and emitting a select event after an element has
         * been selected
         * @param {Event} evt
         * @param {HTMLElement} triggerElement
         * @param {HAModal | HAPopover} popoverMenu
         * @param {Boolean} dontSelect
         * @private
         */
        _handleSelect: function _(evt, triggerElement, popoverMenu, dontSelect) {
            evt.stopPropagation();
            // set the selectedIndex from the menu
            if (!dontSelect) {
                this.selectedIndex = evt.target.selectedIndex;
            }
            if (this.noFocusBackOnSelect) {
                triggerElement.classList.remove('active');
            } else {
                this._focusOnNextClose = true;
            }
            _hidePopoverMenu(popoverMenu, triggerElement, deviceUtils.isHandheld() ?  300 : 0);

            if (!dontSelect) {
                // re-emit select events from ha-menu to host component
                this.emit('select');
            }
        },

        /**
         * Opens the dropdown element with the specified alignment. Alignment will be ignored if it's a modal
         * @param {HAPopover | HAModal} popoverMenu
         * @param {HAMenu} menu
         * @param {HTMLElement} triggerElement
         * @param {String} alignment
         * @private
         */
        _showWithAlignment: function(popoverMenu, menu, triggerElement, alignment) {
            if (_isOpen(popoverMenu)) {
                // if popover is already open and positioned
                if (popoverMenu.classList.contains(alignment)) {
                    var index,
                        newFocus;
                    if (alignment === 'position-top') {
                        index = menu.items.length - 1;
                    } else if (alignment === 'position-bottom') {
                        index = 0;
                    }
                    newFocus = (menu.items && menu.items.length > 0) ? menu.items[index] : menu;
                    newFocus.focus();
                }
            } else {
                // open popover if not yet opened
                _showPopoverMenu(popoverMenu, this, triggerElement);
            }
        },

        attachedCallback: function _() {
            this._itemHandle = domObserver.bindChildrenChanges(this, 'ha-item', this, 'items');
        },

        detachedCallback: function() {
            var popover = this.dropdownElement;
            if (popover && popover.parentElement) {
                popover.parentElement.removeChild(popover);
            }

            if (this._itemHandle) {
                this._itemHandle.remove();
                this._itemHandle = null;
            }
        },

        set popover(newPopover) {
            console.warn('DEPRECATION WARNING: "popover" property is going to be deprecated, please from now on don\'t use it.');

            var targetSelectorId;

            /* istanbul ignore if */
            if (this.popover && this.popover !== newPopover) {
                this.removeChild(this.popover);
            }

            this._popover = newPopover;

            if (newPopover) {
                targetSelectorId = this._getTargetSelectorId();
                newPopover.classList.add('popover-menu-items');
                newPopover.targetSelector = '#' + targetSelectorId;
                // when have a popover open and we click outside it should not focus back to the component
                newPopover._noAutoFocusLastActiveElementOnClose = true;

                if (newPopover.parentNode !== this) {
                    this.appendChild(newPopover);
                }
            }
        },

        get popover() {
            console.warn('DEPRECATION WARNING: "popover" property is going to be deprecated, please from now on don\'t use it.');
            return this._popover;
        },

        /**
         * Sets the items to be displayed for this menu button.
         * @param {HAItem[]} newValue
         */
        set items(newValue) {
            if (newValue) {
                if (this._itemHandle) {
                    this._itemHandle.pause();
                }

                var menu = this.dropdownElement.querySelector('ha-menu'),
                    items,
                    newItems = [];

                // Remove all ha-items.
                // Should enter here only if we are replacing items with javascript
                items = Array.prototype.slice.call(this.querySelectorAll('ha-item'));
                items.forEach(function(item) {
                    this.removeChild(item);
                }.bind(this));

                if (Array.isArray(newValue)) {
                    newValue.forEach(function(item) {
                        newItems.push(item);

                        this.insertBefore(item, this._getFirstNonItemChild());
                    }, this);
                }

                // guarding against falsy menu (IE 11 fix)
                if (menu) {
                    if (menu.render) {
                        // deprecate this.renderItem
                        menu.items = menuItemUtils.createMenuItems(newItems, {role: 'menuitem'}, this.itemRenderer || this.renderItem, this.ownerDocument);
                    } else {
                        menu.innerHTML = '';
                        newItems.forEach(function(item) {
                            menu.appendChild(item);
                        });
                    }
                }

                this._items = newValue;

                if (this._itemHandle) {
                    this._itemHandle.resume();
                }
            }
        },

        /**
         * Gets the items
         */
        get items() {
            return this._items;
        },

        /**
        * Dummy method to avoid problems with getter without setters
        */
        set selectedItem(newValue) {
            // jshint unused:false
        },

        /**
         * Gets the selected item from the menu
         */
        get selectedItem() {
            return Array.isArray(this.items) && this.selectedIndex > -1 ? this.items[this.selectedIndex] : null;
        },

        /**
         * Gets the popover or modal element that contains the menu
         */
        get dropdownElement() {
            return this._getPopover();
        },

        /**
         * The id used for the local button id which also matches the targetSelector of the popover
         * @private
         * return {String} id
         */
        _getTargetSelectorId: function() {
            return this.localName + '-target-' + this.componentId;
        },

        /**
         * Returns the first child of this component that is not an HAItem
         * @returns {HTMLElement}
         * @private
         */
        _getFirstNonItemChild: function() {
            return Array.prototype.slice.call(this.children).filter(function(element) {
                return element.tagName !== 'HA-ITEM';
            })[0];
        },

        /**
         * Returns whether this is a modal menu based button
         */
        get modal() {
            return this.tagName === 'HA-MENU-BUTTON' &&
                (deviceUtils.getScreenParameters().deviceType === deviceUtils.deviceTypes.mobile);
        }
    });

    return menuBasedButtons;
});

define('hui/menu-button',[
    'object-utils/classes',
    'register-component/v2/register',
    './menu/menu-based-buttons',
    './core/deviceUtils',
    './item'
],
function(classes, register, MenuBasedButtons, deviceUtils) {
    'use strict';

    var buttonClasses = ['ha-button-default', 'ha-button-primary', 'ha-button-dark'],
        HAMenuButton,
        cancelValue = Date.now() + '-menu-button-cancel-item-value';

    HAMenuButton = classes.createObject(MenuBasedButtons, {
        init: function _() {
            _.super(this);

            this.setupProperties({
                /**
                 * Disabled indicates if the menu button is disabled.
                 * @type {Boolean}
                 */
                disabled: {
                    default: false,
                    type: Boolean,
                    change: function(newValue) {
                        var button = this.querySelector('button'),
                            // Handle combo button case so this can be the super class
                            actionButton = this.querySelector('.combo-button-action'),
                            dropdownButton = this.querySelector('.combo-button-dropdown');

                        if (actionButton && dropdownButton) {
                            if (newValue) {
                                actionButton.disabled = true;
                                dropdownButton.disabled = true;
                            } else {
                                actionButton.disabled = false;
                                dropdownButton.disabled = false;
                            }
                        } else {
                            button.disabled = newValue;
                        }
                    }
                },

                /**
                 * If true, the menu will have a cancel option on mobile
                 *
                 * @type {Boolean}
                 */
                addMobileCancelOption: {
                    default: false,
                    type: Boolean,
                    change: function(newValue, oldValue) {
                        if (deviceUtils.getScreenParameters().deviceType === deviceUtils.deviceTypes.mobile) {
                            if (newValue !== oldValue) {
                                if (newValue && this.mobileCancelText) {
                                    this._addCancelItem(this.mobileCancelText);
                                } else {
                                    this._removeCancelItem(true);
                                }
                            }
                        }
                    }
                },

                /**
                 * The content of the cancel option on mobile, if it is used
                 *
                 * @type {String}
                 */
                mobileCancelText: {
                    default: 'Cancel',
                    type: String,
                    change: function(newValue, oldValue) {
                        if (deviceUtils.getScreenParameters().deviceType === deviceUtils.deviceTypes.mobile) {
                            if (newValue !== oldValue || newValue !== 'Cancel') {
                                this.addMobileCancelOption = true;
                            }
                        }
                    }
                },

                /**
                 * Used to specify the icon class that should be used instead of a label
                 *
                 * @type {String}
                 */
                icon: {
                    default: '',
                    type: String,
                    change: function(newValue) {
                        var triggerElement = this._getTriggerElement(),
                            span = triggerElement.querySelector('.icon-span'),
                            label = triggerElement.querySelector('.label');

                        if (span) {
                            if (newValue) {
                                triggerElement.classList.add('with-icon');
                                span.className = 'icon-span hi large ' + newValue;
                                if (label) {
                                    label.classList.add('sr-only');
                                }
                            } else {
                                triggerElement.classList.remove('with-icon');
                                span.classList.add('hidden');
                                if (label) {
                                    label.classList.remove('sr-only');
                                }
                            }
                        }

                        // Trigger caret update
                        this.showCaret = !this.showCaret;
                        this.showCaret = !this.showCaret;
                    }
                },

                showCaret: {
                    default: false,
                    type: Boolean,
                    change: function(newValue) {
                        var triggerElement = this._getTriggerElement(),
                            caret;

                        if (triggerElement) {
                            caret = triggerElement.querySelector('.caret');
                        }
                        if (!newValue && caret) {
                            caret.parentElement.removeChild(caret);
                        } else if (newValue && !caret) {
                            if (triggerElement) {
                                caret = this.ownerDocument.createElement('span');
                                caret.className = 'caret';
                                triggerElement.appendChild(caret);
                            }
                        }
                    }
                },

                /**
                 * Property to ease with Automation Effort. When set with a value, the value
                 * would get as attribute for ha-popover as well.
                 * @type {String}
                 */
                automationId: {
                    default: '',
                    type: String,
                    change: function(newValue, oldValue) {
                        if (newValue !== oldValue) {
                            if (deviceUtils.isDesktop) {
                                var menuPopover = this.querySelector('ha-menu-button ha-popover');
                                if (menuPopover && newValue) {
                                    menuPopover.setAttribute('automationId', newValue + '_popover');
                                } else if (menuPopover && !newValue) {
                                    menuPopover.removeAttribute('automationId');
                                }
                            }

                            if (deviceUtils.isHandheld) {
                                var adaptiveModalMenu = this.querySelector('ha-menu-button ha-modal');
                                if (adaptiveModalMenu && newValue) {
                                    adaptiveModalMenu.setAttribute('automationId', newValue + '_modal');
                                } else if (adaptiveModalMenu && !newValue) {
                                    adaptiveModalMenu.removeAttribute('automationId');
                                }
                            }

                            // Do the same for combo button as the component uses the MenuButton prototype.
                            var cmbtnMenuPopover = this.querySelector('ha-combo-button ha-popover');
                            if (cmbtnMenuPopover && newValue) {
                                cmbtnMenuPopover.setAttribute('automationId', newValue + '_popover');
                            } else if (cmbtnMenuPopover && !newValue) {
                                cmbtnMenuPopover.removeAttribute('automationId');
                            }
                        }
                    }
                }
            });
        },

        _handleSelect: function _(evt, triggerElement, popoverMenu) {
            _.super(
                this,
                evt,
                triggerElement,
                popoverMenu,
                evt &&  evt.target && evt.target.selectedItem && evt.target.selectedItem.value === cancelValue
            );
        },

        /**
         * Applies button classes to the trigger element. This method exists because combo and menu buttons have
         * different buttons but need to apply the same classes to both.
         * @private
         */
        _transferButtonClasses: function _() {
            var button = this._getTriggerElement();
            buttonClasses.forEach(function(currentClass) {
                if (this.classList.contains(currentClass)) {
                    button.classList.add(currentClass);
                    this.classList.remove(currentClass);
                }
            }, this);
        },

        /**
         * Renders the trigger element. This functionality has been moved to a private method so that combo and menu
         * button can implement their own versions.
         * @returns {Element|*}
         * @private
         */
        _renderTriggerElement: function _() {
            var triggerElement, label, iconLabel;

            // create trigger button
            triggerElement = this.ownerDocument.createElement('button');
            triggerElement.type = 'type';
            triggerElement.className = 'ha-button no-connector';

            triggerElement.id = this._getTargetSelectorId();
            triggerElement.setAttribute('aria-expanded', 'false');
            triggerElement.setAttribute('aria-haspopup', 'true');

            label = this.ownerDocument.createElement('span');
            label.className = 'label';
            triggerElement.appendChild(label);

            iconLabel = this.ownerDocument.createElement('span');
            iconLabel.className = 'icon-span';
            triggerElement.appendChild(iconLabel);

            // caret always shows in desktop, hides in mobile
            if (deviceUtils.isDesktop()) {
                this.showCaret = true;
            }

            this.appendChild(triggerElement);

            return triggerElement;
        },

        /**
         * Remove the cancel item from the menu
         * @param {Boolean} reRender - This flag is used to indicate whether the menu needs to be rerendered at this
         * time. `_addCancelItem` will call this method internally when changing cancel items, but will not rerender
         * until the new item is added.
         *
         * @private
         */
        _removeCancelItem: function(reRender) {
            if (!this._hasCancelItem) {
                return;
            }
            this._items.splice(-1);
            this._hasCancelItem = false;
            if (reRender) {
                this.items = this._items;
            }
        },

        /**
         * Add a cancel item to the menu so that the user can click it to leave the menu without selecting an item
         * on mobile.
         * @param {String} cancelText
         * @private
         */
        _addCancelItem: function(cancelText) {
            if (this._items.some(function(item) {
                return item.value === cancelValue || item.getAttribute('value') === cancelValue;
            })) {
                this._hasCancelItem = true;
                this._removeCancelItem();
            }
            var cancelItem = document.createElement('ha-item');
            cancelItem.value = cancelValue;
            cancelItem.textContent = cancelText;
            this.items = this._items.concat(cancelItem);
            this._hasCancelItem = true;
        },

        _getTriggerElement: function _() {
            return this.querySelector('button.ha-button.no-connector');
        },

        attachedCallback: function _() {
            _.super(this);
            this._transferButtonClasses();
        }
    });

    return register('ha-menu-button', HAMenuButton);
});

/**
 * @module
 * @class Tabs
 * Tabs component which creates a tabbed interface from a set of provided children
 */
define('hui/tabs',[
    'register-component/v2/register',
    'object-utils/classes',
    'register-component/v2/UIComponent',
    './core/a11y',
    './core/keys',
    './core/utils',
    './core/deviceUtils',
    './tab',
    './popover',
    './menu-button',
    './item'
], function(register, classes, UIComponent, a11y, keys, utils, deviceUtils) {
    'use strict';

    /**
     * Update jumpers (tab-navigable content inside tabs)
     * @param {Number} indexTab
     * @param {HTMLElement} component
     */
    function _updateJumpers(indexTab, component) {
        var sectionContainerId = _getTabContentId(indexTab, component),
            tabContentEl = component.querySelector('#' + sectionContainerId);

        _findFocusableJumpers(component, indexTab, tabContentEl);
    }

    /**
     * Create contents and inserts into the ha-tabs HTML
     * the content for the given tab.
     * @param {HTMLElement} tabInput ha-tab element.
     * @param {Number} indexTab The index of current tab.
     * @param {HTMLElement} component The ha-tabs component.
     * @private
     */
    function _createContent(tabInput, indexTab, component) {
        var contentSectionEl = component.querySelector('section'),
            isActive = _isActive(indexTab, component),
            tabContentEl,
            sectionContainerID,
            i;

        sectionContainerID = _getTabContentId(indexTab, component);
        tabContentEl = component.querySelector('#' + sectionContainerID);

        if (!tabContentEl) {
            tabContentEl = component.ownerDocument.createElement('div');
            contentSectionEl.appendChild(tabContentEl);
            tabContentEl.id = sectionContainerID;

            tabContentEl.setAttribute('aria-labelledby', _getTabId(indexTab, component));
            tabContentEl.setAttribute('role', 'tabpanel');
        }

        tabContentEl.setAttribute('aria-hidden', !isActive);

        if (isActive) {
            tabContentEl.classList.add('active');
        } else {
            tabContentEl.classList.remove('active');
        }

        if (tabInput.section) {
            tabContentEl.innerHTML = '';
            for (i = 0; i < tabInput.section.length; i++) {
                tabContentEl.appendChild(tabInput.section[i]);
            }

            _findFocusableJumpers(component, indexTab, tabContentEl);

            _jumpersOnKeydown(component, indexTab);
        }
    }

    /**
     * Given an index retrieves a safe one.
     * @param  {Number} index The index to check.
     * @param  {HTMLElement} component The component to inspect on.
     * @return {Number} The safe index.
     * @private
     */
    function _getSafeIndex(index, component) {
        return index === 0 ? 0 : (!index || !component.tabs || index > component.tabs.length) ? -1 : index;
    }

    /**
     * Select the new tab on the component and deselect the previous one.
     * @param {Object} activeTab The tab that will replace the previous selected.
     * @param {HTMLElement} component The ha-tabs component.
     * @private
     */
    function _selectTab(activeTab, component) {
        if (!activeTab) {
            return;
        }

        activeTab = activeTab && activeTab.nodeName === 'HA-ITEM' ? activeTab :
            utils.getComponentFromElement(activeTab, 'HA-TAB');

        var previousActiveTab;

        if (deviceUtils.isHandheld() && component.useTabButton) {
            previousActiveTab = component.querySelector('.ha-tabs-header ha-item.active');
        } else {
            previousActiveTab = component.querySelector('.ha-tabs-header .active');
        }

        _toggleNodeSelected(previousActiveTab, component);
        _toggleNodeSelected(activeTab, component);
        component.selectedIndex = component.tabs.indexOf(activeTab);
        activeTab.focus();
    }

    /**
     * Given an index tab return if is active by two basic rules:
     * 1) If the selectedIndex is greater than 0, means that was defined and then will
     * be validated by the given indexTab.
     * 2) If selectedIndex is not defined or is just the default, the active tab would
     * be the first.
     * @param {Number} indexTab The current index tab.
     * @param {HTMLElement} component The ha-tabs component.
     * @returns {boolean} Returns whether the indexTab should be active or not.
     * @private
     */
    function _isActive(indexTab, component) {
        if (component.selectedIndex > 0) {
            return component.selectedIndex === indexTab;
        } else {
            return indexTab === 0;
        }
    }

    /**
     * Return the tab index from the for attribute from the given tag.
     * @param {Object} tab The html element that is used to subtract the tab index id.
     * @returns {Number} the index of tab.
     * @private
     */
    function _retrieveIndexTab(tab) {
        return parseInt(tab.forHTML.slice(-1), 10);
    }

    /**
     * Return the proper format of tab content id.
     * @param {Number} indexTab The current index tab.
     * @param {Object} component The object that contain the component id.
     * @returns {String} The tab content id.
     * @private
     */
    function _getTabContentId(indexTab, component) {
        if (component.tabs[indexTab] && component.tabs[indexTab].hasAttribute('aria-controls')) {
            return component.tabs[indexTab].getAttribute('aria-controls');
        } else {
            return 'ha-tab-content-' + component.componentId + '-' + indexTab;
        }
    }

    /**
     * Return the proper format of tab id.
     * @param {Number} indexTab The current index tab.
     * @param {Object} component The object that contain the component id.
     * @returns {String} The tab id.
     * @private
     */
    function _getTabId(indexTab, component) {
        if (component.tabs[indexTab] && component.tabs[indexTab].id) {
            return component.tabs[indexTab].id;
        } else {
            return 'ha-tab-' + component.componentId + '-' + indexTab;
        }
    }

    /**
     * Invert the status of the defined component.
     * @param {Object} node The object that contain the style that will be toggled.
     * @param {Object} component The ha-tabs object.
     * @private
     */
    function _toggleNodeSelected(node, component) {
        if (node) {
            var contentId = node.forHTML,
                content = contentId ? component.querySelector('#' + contentId) : node,
                isNodeActive = node.classList && node.classList.contains('active');

            if (!content) {
                return;
            }
            if (isNodeActive) {
                if (node.tagName === 'HA-TAB') {
                    node.active = false;
                } else {
                    node.classList.remove('active');
                }

                node.setAttribute('aria-expanded', false);
                node.setAttribute('tabindex', -1);
                content.classList.remove('active');
                content.setAttribute('aria-hidden', true);
            } else {
                if (node.tagName === 'HA-TAB') {
                    node.active = true;
                } else {
                    node.classList.add('active');
                }

                node.setAttribute('aria-expanded', true);
                node.setAttribute('tabindex', 0);
                content.classList.add('active');
                content.setAttribute('aria-hidden', false);
            }
        }
    }

    /**
     * Goes over all the tabs finding the last focusable element on each of them.
     * @param {HTMLElement} component The component to be inspected.
     * @param {Number} tabIndex Index of the tab to search for tabbable elements
     * @return {Object} The array of last focusable element on each contentNode.
     * @private
     */
    function _findFocusableJumpers(component, tabIndex, content) {
        var elements;

        elements = a11y.getBoundariesTabableElement(content, true);
        component.jumpers[tabIndex] = elements.last || elements.first;
    }

    /**
     * Given a list of jumper elements we attach the evt to jump to the next tab
     * when the key tab is pressed over them.
     * @param {HTMLElement} component The ha-tabs component.
     * @param {Number} tabIndex Optional. Index of tab to update jumpers
     * @private
     */
    function _jumpersOnKeydown(component, tabIndex) {

        function moveFocusCallback(evt) {
            var component = utils.getComponentFromElement(evt.target, 'HA-TABS');

            if (evt.keyCode === keys.TAB && !evt.shiftKey) {
                _moveFocus(evt.target.jumpTo, component, evt);
            }
        }

        function setListener(component, tabNumber) {
            element = component.jumpers[tabNumber];
            nextTab = component.querySelector('#' + _getTabId(parseInt(tabNumber, 10) + 1, component));

            // if there isn't next tab we just let the focus go away
            if (nextTab) {
                // if there is a focusable element in this panel we attach the evt
                // if not, the event will be added later to the tab itself
                if (element) {
                    element.jumpTo = nextTab;
                    component.stopListening(element, 'keydown', moveFocusCallback);
                    component.listenTo(element, 'keydown', moveFocusCallback);
                }
            }
        }

        var element, tabNumber, nextTab;

        if (tabIndex) {
            setListener(component, tabIndex);
        } else {
            for (tabNumber in component.jumpers) {
                setListener(component, tabNumber);
            }
        }
    }

    /**
     * Either there is a jumper or not, it moves the focus to the correct place.
     * The jumper if there is one, or the next tab.
     * @param {HTMLElement} nextTab   The next tab to be highlighted.
     * @param {HTMLElement} component The ha-tabs component.
     * @param {Event} evt The event to be stopped.
     * @param {HTMLElement} jumper (optional) The jumper to place the focus on.
     * @private
     */
    function _moveFocus(nextTab, component, evt, jumper) {
        if (nextTab) {
            utils.stopEvent(evt);
            _selectTab(nextTab, component);

            if (jumper) {
                jumper.focus();
            } else {
                nextTab.focus();
            }
        }
    }

    function updateTab(evt) {
        var HATab = evt.target,
            index = -1,
            i,
            component;

        component = utils.getComponentFromElement(HATab, 'HA-TABS');

        for (i = 0; i < component.tabs.length; i++) {
            if (component.tabs[i] === HATab) {
                index = i;
                break;
            }
        }

        _createContent(HATab, index, component);
    }

    function updateHATab(component, indexTab) {
        var isActive,
            tabInput;

        tabInput = component._tabs[indexTab];

        tabInput.id = _getTabId(indexTab, component);

        tabInput.forHTML = _getTabContentId(indexTab, component);

        tabInput.setAttribute('aria-controls', _getTabContentId(indexTab, component));

        isActive = _isActive(indexTab, component);

        tabInput.setAttribute('aria-selected', isActive);
        tabInput.setAttribute('aria-expanded', isActive);

        if (isActive) {
            tabInput.classList.add('active');
        } else {
            tabInput.classList.remove('active');
        }

        component.querySelector('header').appendChild(tabInput);

        _createContent(tabInput, indexTab, component);
    }

    /* jshint ignore:start */
    function _renderTrigerElement(component) {
        var triggerElement, label, buttonCaret;

        triggerElement = component.ownerDocument.createElement('button');
        triggerElement.classList.add('ha-button');
        triggerElement.classList.add('no-connector');
    }
    /* jshint ignore:end */

    // Convert items to tabs after cloning
    function itemsToTabs(items, component) {
        return items.map(function(item, index) {
            var tab  = component.ownerDocument.createElement('ha-tab'),
                titleText = item.titleText || item.getAttribute('label'),
                isActive = _isActive(index, component);

            tab.section = Array.prototype.slice.call(component.querySelector('#' + item.getAttribute('aria-controls')).children);
            tab.titleText = titleText;
            tab.classList[isActive ? 'add' : 'remove']('active');
            return tab;
        });
    }

    function updateMenuTabs(component, tabs) {
        var items = [],
            menuButton = component.ownerDocument.createElement('ha-menu-button'),
            caret = component.ownerDocument.createElement('span');
        // menuButton.modal = true;
        caret.className = 'caret';
        menuButton.querySelector('button').appendChild(caret);

        tabs.forEach(function(tab, index) {
            var item = component.ownerDocument.createElement('ha-item'),
                titleText = tab.titleText || tab.getAttribute('titleText'),
                contentId = _getTabContentId(index, component),
                isActive = _isActive(index, component);

            if (isActive) {
                menuButton.label = titleText;
            }
            item.forHTML = _getTabContentId(index, component);
            item.section = tab.section;

            item.label = item.textContent = item.titleText = titleText;
            item.value = contentId;
            items.push(item);

            item.id = _getTabId(index, component);
            item.forHTML = contentId;
            item.setAttribute('aria-controls', contentId);
            item.setAttribute('aria-selected', isActive);
            item.classList[isActive ? 'add' : 'remove']('active');
            _createContent(item, index, component);
        });

        if (!component._oldTabs) {
            component._oldTabs = component._tabs;
        }
        component._tabs = items;
        menuButton.items = items;

        menuButton.on('select', function(evt) {
            var menuButton = evt.target,
                selectedItem = menuButton.items[menuButton.selectedIndex];
            menuButton.label = selectedItem.textContent;
            component.selectedIndex = menuButton.selectedIndex;
        });

        component.querySelector('header').appendChild(menuButton);

        menuButton._getPopover().classList.remove('from-bottom');
    }

    var HATabs = classes.createObject(UIComponent, {

        init: function _() {

            _.super(this);

            this.jumpers = {};

            this._tabs = null;

            this.setupProperties({
                /**
                 * The current index of the component.
                 * @type {Number}
                 */
                selectedIndex: {
                    default: 0,
                    type: {
                        parse: function(value) {
                            return Number(value);
                        },

                        stringify: function(value) {
                            return String(value);
                        }
                    },
                    change: function(newValue) {
                        var safeIndex = _getSafeIndex(newValue, this),
                            tab;

                        if (this.tabs && safeIndex !== -1) {
                            tab = this.tabs[newValue];
                            if (tab && !tab.classList.contains('active')) {
                                _selectTab(tab, this);
                            }
                        }
                    }
                },

                /**
                 * Whether the tabs on mobile should be a button or tabs
                 * @type {Boolean}
                 */
                useTabButton: {
                    default: deviceUtils.isHandheld(),
                    type: utils.YesNoType,
                    change: function(newValue) {
                        if (!newValue && this._oldTabs) {
                            this.tabs = this._oldTabs;
                        } else if (this.tabs) {
                            this.tabs = this.tabs;
                        }
                    }
                }
            });
        },

        postRender: function _() {
            _.super(this);
            a11y.addA11yFocus(this);
        },

        /**
         * The models of each tabs.
         * @type {Array}
         */
        set tabs(newValue) {
            var self = this;
            function setTabs() {
                var indexTab;

                self.querySelector('header').innerHTML = '';
                self.querySelector('section').innerHTML = '';

                self._tabs = newValue || [];

                if (deviceUtils.isHandheld() && self.useTabButton) {
                    updateMenuTabs(self, self._tabs);
                } else {
                    self._oldTabs = self._tabs;
                    for (indexTab = 0; indexTab < self._tabs.length; indexTab++) {
                        updateHATab(self, indexTab);

                        self.listenTo(self._tabs[indexTab], 'section-property-change', updateTab);
                    }
                    _jumpersOnKeydown(self);
                }
            }
            setTabs(newValue);
        },

        get tabs() {
            return this._tabs;
        },

        /**
         * The current tab selected.
         * NOTE: by default is null
         */
        get selectedItem() {
            return this._tabs[this.selectedIndex];
        },

        /**
         * Empty method to avoid problems with getter without setters
         */
        set selectedItem(newValue) {
            // jshint unused:false
        },

        ready: function _() {
            _.super(this);

            var headerEl = this.querySelector('header'),
                sectionEl = this.querySelector('section'),
                isAlreadyRendered = this.querySelector('.ha-tabs-content') !== null,
                indexTab,
                tabs = Array.prototype.slice.call(this.querySelectorAll('ha-tab')).concat(Array.prototype.slice.call(this.querySelectorAll('ha-item')));

            if (isAlreadyRendered) {
                if (this.useTabButton && deviceUtils.isHandheld()) {
                    this._tabs = itemsToTabs(tabs, this);
                    this.querySelector('header').innerHTML = '';
                    updateMenuTabs(this, this._tabs);
                } else {
                    this._tabs = tabs;
                    for (indexTab = 0; indexTab < this._tabs.length; indexTab++) {
                        updateHATab(this, indexTab);

                        this.listenTo(this._tabs[indexTab], 'section-property-change', updateTab);
                    }
                }
                _jumpersOnKeydown(this);
            } else {
                headerEl = this.ownerDocument.createElement('header');
                headerEl.classList.add('ha-tabs-header');
                headerEl.setAttribute('role', 'tablist');

                sectionEl = this.ownerDocument.createElement('section');
                sectionEl.classList.add('ha-tabs-content');

                this.appendChild(headerEl);
                this.appendChild(sectionEl);

                this.tabs = utils.removeNodesSafe(this, tabs);

                this.tabIndex = '-1';
            }
        },

        /**
         * Add a new tab at the end of the list of existing tabs. You can optionaly
         * define the position index of the new tag.
         * @param {Object} tab The new tab that will be add to the component.
         * @param {Number} index (optional) the index position of the new tab.
         */
        add: function(tab, index) {
            var safeIndex,
                tabsLength = this.tabs.length,
                newTabs;

            if (tab && tab.tagName === 'HA-TAB') {
                safeIndex = (index === 0) ? 0 : (!index) ? tabsLength : index;
                newTabs = this.tabs;
                newTabs.splice(safeIndex, 0, tab);
                this.tabs = newTabs;
            }
        },

        /**
         * Remove the tab by index.
         * @param {Number} index The index of tab that will be removed.
         */
        remove: function(index) {
            var safeIndex = _getSafeIndex(index, this),
                newTabs;

            if (safeIndex !== -1) {
                newTabs = this.tabs;
                newTabs.splice(safeIndex, 1);
                this.tabs = newTabs;
            }
        },

        attachedCallback: function() {
            // allow the first tab to be focusable on creation
            var firstTab = this.querySelector('ha-tab');
            if (firstTab) {
                firstTab.tabIndex = 0;
            }
        },

        /**
         * Once the Horizontal Tab has been attached to the DOM, click
         * evt handlers are bound.
         * @override
         */
        createdCallback: function _() {
            _.super(this);

            this.on('header ha-tab:click', function(evt) {
                _selectTab(evt.target, this);
                this.emit('select');
            }.bind(this));

            this.on('header ha-tab:keydown', function(evt) {
                var currentTab = evt.target,
                    nextTab, tabOrder,
                    prevTabOrder, nextTabOrder;

                if (evt.keyCode === keys.TAB) {
                    tabOrder = _retrieveIndexTab(currentTab);
                    _updateJumpers(tabOrder, this);

                    if (evt.shiftKey) {
                        prevTabOrder = tabOrder - 1;

                        // Should set the focus to the previus jumper if there is one.
                        // If not, the focus just goes away naturally.
                        if (prevTabOrder >= 0) {
                            nextTab = this.querySelector('#' + _getTabId(prevTabOrder, this));

                            if (this.jumpers.hasOwnProperty(prevTabOrder) && this.jumpers[prevTabOrder]) {
                                _moveFocus(nextTab, this, evt, this.jumpers[prevTabOrder]);
                            } else {
                                _moveFocus(nextTab, this, evt);
                            }
                        }
                    } else {
                        nextTabOrder = tabOrder + 1;
                        // The following case, just happen when there is not a jumper within the tab content.
                        // Then we need to jump to the next tab from the current one.
                        if (nextTabOrder < Object.keys(this.tabs).length) {
                            nextTab = this.querySelector('#' + _getTabId(nextTabOrder, this));
                            // if the current tab doesn't have a jumper we should move the focus to next tab
                            if (Object.keys(this.jumpers).length === 0 ||
                                (this.jumpers.hasOwnProperty(tabOrder) && !this.jumpers[tabOrder])) {
                                _moveFocus(nextTab, this, evt);
                            }
                        }
                    }

                } else if (evt.keyCode === keys.LEFT && currentTab.previousElementSibling) {
                    nextTab = currentTab.previousElementSibling;
                    _moveFocus(nextTab, this, evt);
                } else if (evt.keyCode === keys.RIGHT && currentTab.nextElementSibling) {
                    nextTab = currentTab.nextElementSibling;
                    _moveFocus(nextTab, this, evt);
                }

            }.bind(this));
        }
    });

    return register('ha-tabs', HATabs);
});

define('hui/inline-message',[
    'register-component/v2/UIComponent',
    'register-component/v2/register',
    'object-utils/classes',
    './core/popup',
    './core/tooltip',
    './core/utils',
    './core/a11y'
], function(UIComponent, register, classes, popup, coreTooltip, utils, a11y) {
    'use strict';

    /**
     * Event handler for 'animationend'
     * @param {AnimationEvent} event
     */
    function _handleAnimationEnd(event) {
        var eventName = event.animationName,
            target = event.target;

        switch (eventName) {
            case 'ha-fade-in':
                target.classList.remove('enter');
                target.emit('show');
                break;

            case 'ha-fade-out':
                target.classList.remove('visible');
                target.classList.remove('leave');
                target.emit('close');
                break;
        }
    }

    /**
     * Adds/removes connector element inside component
     * @param  {HTMLElement} component Where to add the element
     */
    function updateConnector(component) {
        var connectorNode = component.querySelector('.connector'),
            targetNode = component._listenersTargets[0],
            restOfSelector;

        if (component.targetSelector.indexOf('_previousSibling') > -1) {
            restOfSelector = component.targetSelector.split('_previousSibling')[1];
            if (restOfSelector) {
                targetNode = component.previousElementSibling.querySelector(restOfSelector.trim());
            } else {
                targetNode = component.previousElementSibling;
            }
        } else if (component.targetSelector !== '') {
            targetNode = component.ownerDocument.querySelector(component.targetSelector);
        }

        if (!targetNode) {
            if (connectorNode) {
                component.removeChild(connectorNode);
            }

            return;
        }

        if (!connectorNode) {
            connectorNode = component.ownerDocument.createElement('div');
            connectorNode.classList.add('connector');
            component.insertBefore(connectorNode, component.firstChild);
        }
    }

    var HAInlineMessage;

    HAInlineMessage = classes.createObject(UIComponent, /** @lends HAInlineMessage# */ {

        /** @constructs */
        init: function _() {
            _.super(this);

            var anim = utils.getAnimationEventNames();

            this.on(anim.animationend, _handleAnimationEnd);
            this._listenersTargets = [];
            this._message = null;

            // Keep bound references to these callbacks for core/tooltip methods to use
            this._hideCallback = this.close.bind(this);
            this._showCallback = this.show.bind(this);

            /**
             * Flag so that this component will not reset listeners when it's attached to the body
             * @type {Boolean}
             */
            this._attached = false;

            this.setupProperties({
                /**
                 * If the element has a target, this property specifies whether it should auto-close on the condition
                 * specified in the 'trigger' property.
                 * @type {boolean}
                 * @default false
                 */
                autoClose: {
                    type: Boolean,
                    default: false,
                    change: function(newValue) {
                        this._dismissible = !newValue;
                    }
                },

                /**
                 * Position of the element relative to its target (when in tooltip mode).
                 * top, bottom, left, right
                 * Multiple values can be separated by a space; they will be tried in the order specified.
                 * @type {string}
                 * @default 'right bottom'
                 */
                position: {
                    type: String,
                    default: 'right bottom',
                    change: function(newValue) {
                        var alignmentMap = {
                            bottom: 'left',
                            top: 'left',
                            left: 'middle',
                            right: 'middle'
                        };

                        this._alignment = newValue.split(' ').map(function(position) {
                            return alignmentMap[position];
                        }).join(' ');
                    }
                },

                /**
                 * The CSS selector for the target element to display the message next to
                 * Defaults to empty, which means the element must be manually placed.
                 * The special value '_previousSibling' can be used to indicate the 'previousElementSibling' in the DOM
                 * should be used.
                 * @type {string}
                 * @default ''
                 */
                targetSelector: {
                    type: String,
                    default: '',
                    change: function(newValue) {
                        coreTooltip.removeOldListeners(this);

                        if (newValue) {
                            this.classList.remove('visible');
                            this.classList.remove('static');
                            coreTooltip.setTooltipTargets(this, newValue);

                            if (this._listenersTargets[0] && this._listenersTargets[0]._inputElement) {
                                // Fix for read-only NodeList in Firefox - you can't assign new values to
                                // a NodeList in Firefox, and _listenersTargets is sometimes set to a NodeList by
                                // core/tooltip.setTooltipTargets
                                // original:
                                // this._listenersTargets[0] = this._listenersTargets[0]._inputElement;
                                this._listenersTargets = [this._listenersTargets[0]._inputElement];
                            }

                            coreTooltip.resetListeners(this, this.trigger);

                            if (this._listenersTargets[0]) {
                                this.setAttribute('id', 'ha-inline-message-' + this.componentId);
                                this._listenersTargets[0].setAttribute('aria-describedby', this.getAttribute('id'));
                            }
                        } else {
                            this.classList.add('static');
                            this.classList.add('visible');
                            this._listenersTargets = [];
                        }
                    }
                },

                /**
                 * Name of event to listen for on target to show/close the element.
                 * Supported values: focus, hover
                 * The value 'custom' indicates that the developer will control showing and closing the element.
                 * @type {string}
                 * @default custom
                 */
                trigger: {
                    type: String,
                    default: 'custom',
                    change: function(newValue) {
                        coreTooltip.resetListeners(this, newValue);
                    }
                }
            });
        },

        /**
         * Sets tooltip initial configs and resets event listeners.
         */
        attachedCallback: function() {
            if (this.targetSelector && !this._attached) {
                this._attached = true;
                coreTooltip.setTooltipTargets(this, this.targetSelector);
                coreTooltip.resetListeners(this, this.trigger);
            }
        },

        postRender: function _() {
            var contentNode,
                iconNode,
                messageContent;

            _.super(this);
            a11y.addA11yFocus(this);

            iconNode = this.querySelector('.hi');
            contentNode = this.querySelector('.message-content');

            if (contentNode) {
                messageContent = contentNode.innerHTML;
            } else {
                messageContent = this.innerHTML;
                this.innerHTML = '';
            }

            if (!iconNode) {
                iconNode = this.ownerDocument.createElement('i');
                iconNode.classList.add('hi');
                iconNode.classList.add('hi-circle-check');
                iconNode.setAttribute('aria-hidden', true);
                this.appendChild(iconNode);
            }

            if (!contentNode) {
                contentNode = this.ownerDocument.createElement('div');
                contentNode.classList.add('message-content');

                this.appendChild(contentNode);
            }

            // Set 'minWidth' to avoid popup default behaviour of setting 'minWidth' to
            // target's width
            this.style.minWidth = '1px';

            this.setAttribute('role', 'tooltip');
            this.setAttribute('aria-live', 'polite');
            this.message = messageContent;
            this.tabIndex = -1;
        },

        // Necessary for core/popup methods
        get alignment() {
            return this._alignment;
        },

        // Necessary for core/tooltip methods
        get dismissible() {
            return this._dismissible;
        },

        // Necessary for core/tooltip methods
        get duration() {
            return 0;
        },

        /**
         * The 'message' property contains the content displayed in the component
         * @param {string|HTMLElement} newValue Text (can be HTML string) of content to display, or HTMLElement
         */
        set message(newValue) {
            var contentNode = this.querySelector('.message-content');

            if (typeof newValue === 'string') {
                contentNode.innerHTML = newValue;
                this._message = newValue;
            } else if (newValue.nodeType) {
                contentNode.innerHTML = '';
                contentNode.appendChild(newValue);
                this._message = newValue;
            }
        },

        /**
         * The 'message' property contains the content displayed in the component
         * @returns {string} Text or HTML string of the currently displayed content
         */
        get message() {
            return this._message;
        },

        /**
         * Close the element
         * @emits InlineMessage#close
         */
        close: function(event) {
            this.classList.add('leave');
            if ((!event || event.type !== 'blur') && this._target && this._target.focus) {
                this._target.focus();
            }
            this._target = null;
        },

        /**
         * Show the element
         * @emits InlineMessage#show
         */
        show: function() {
            if (this.classList.contains('visible')) {
                return;
            }

            if (this.targetSelector) {
                updateConnector(this);

                if (this.querySelector('.connector')) {
                    this._target = this._listenersTargets[0];
                    if (this._target) {
                        if (this._target._inputElement) {
                            this._target = this._target._inputElement;
                        }

                        popup.setPosition(this, this._target, this.position.split(' '), this.alignment.split(' '));
                    }
                }
            }

            this.classList.remove('leave');
            this.classList.add('enter');
            this.classList.add('visible');
        }
    });

    return register('ha-inline-message', HAInlineMessage);
});

define('hui/label',[
    'object-utils/classes',
    'register-component/v2/register',
    'register-component/v2/UIComponent'
], function(classes, register, UIComponent) {
    'use strict';

    var HaLabel = classes.createObject(UIComponent, { });

    return register('ha-label', HaLabel);
});

define('text!hui/page-message/page-message.html',[],function () { return '<template>\n    <span class="hi-icon-{{type}}"></span>\n    <button class="btn hi hi-close" aria-label="Close"></button>\n    <header>\n        <h4>{{titleText}}</h4>\n    </header>\n    <div class="message-content">{{message}}</div>\n</template>\n';});


define('hui/page-message',[
    'register-component/v2/UIComponent',
    'register-component/v2/register',
    'object-utils/classes',
    './core/a11y',
    'register-component/template!./page-message/page-message.html'
], function(UIComponent, register, classes, a11y) {
    'use strict';

    var HAPageMessage;

    /**
     * When a message is closed, finds a new target to give focus to
     * @param  {HTMLElement} component The page message component
     */
    function _handleFocusOnClose(component) {
        var destinationFocus;

        destinationFocus = component.previousElementSibling || component.parentElement.previousElementSibling;
        if (destinationFocus) {
            destinationFocus.focus();
        }
    }

    HAPageMessage = classes.createObject(UIComponent, {

        /**
         * Executed on show message.
         * @emits PageMessage#show
         */
        show: function() {
            this.classList.remove('hidden');
            this.emit('show');
        },

        init: function _() {
            _.super(this);

            /**
             * Content of the message
             */
            this._message = null;

            /**
             * Show a close button.
             * @type {Boolean}
             */
            this._dismissible = true;

            this.setupProperties({
                /**
                 * Title of the message.
                 * @type {String}
                 */
                titleText: {
                    default: '',
                    type: String,
                    change: function(newValue) {
                        var headerNode = this.querySelector('header'),
                            textContainer = this.querySelector('h4');

                        if (newValue) {
                            if (!headerNode) {
                                headerNode = this.ownerDocument.createElement('header');
                                textContainer = this.ownerDocument.createElement('h4');

                                headerNode.appendChild(textContainer);
                                this.insertBefore(headerNode, this.querySelector('.message-content'));
                            }
                            textContainer.textContent = newValue;
                            this.setAttribute('aria-label', newValue);
                        } else {
                            if (headerNode) {
                                this.removeChild(headerNode);
                            }
                            this.removeAttribute('aria-label');
                        }
                    }
                },

                /**
                 * Type of the message:
                 *  - info
                 *  - warn
                 *  - alert for backward compatibility
                 *  - error
                 * @type {String}
                 * @default: info
                 */
                type: {
                    default: 'info',
                    type: String,
                    change: function(newValue) {
                        var iconEl = this.querySelector('span.message-icon');

                        if (newValue === 'alert' || newValue === 'warn' || newValue === 'error') {
                            iconEl.className = 'message-icon hi hi-circle-alert';
                        } else if (newValue === 'discovery') {
                            iconEl.className = 'message-icon hi hi-lightbulb-o';
                        } else {
                            iconEl.className = 'message-icon hi hi-circle-info';
                        }
                        if (newValue === 'alert') {
                            console.warn('DEPRECATION WARNING: The "alert" type is going to be deprecated. From now on, please use "error" type instead.');
                        }
                    }
                }
            });

            /**
             * Executed when the user click on close button.
             * @emits PageMessage#dismiss
             */
            this.on('button.btn.hi-close:click', function() {
                this.emit('dismiss');
                this.close();
            }.bind(this));
        },

        set message(newValue) {
            var content = this.querySelector('.message-content');
            if (typeof newValue === 'string') {
                content.innerHTML = newValue;
                this._message = newValue;
            } else if (newValue && newValue.nodeType) {
                content.innerHTML = '';
                content.appendChild(newValue);
                this._message = newValue;
            }
        },

        get message() {
            return this._message;
        },

        /**
         * Show a close button.
         * @type {Boolean}
         */
        set dismissible(newValue) {
            var closeButton = this.querySelector('button');
            if (newValue) {
                closeButton.classList.add('show');
                closeButton.removeAttribute('aria-hidden');
            } else {
                closeButton.classList.remove('show');
                closeButton.setAttribute('aria-hidden', true);
            }
            this._dismissible = newValue;
        },

        get dismissible() {
            return this._dismissible;
        },

        /**
         * Callback attached after the Component render
         * Set the attributes for the component.
         */
        postRender: function _() {
            var contentEl = this.querySelector('.message-content'),
                typeIconEl = this.querySelector('span.message-icon'),
                titleEl = this.querySelector('h4'),
                closeButtonEl = this.querySelector('button'),
                headerEl,
                messageContent;

            _.super(this);
            a11y.addA11yFocus(this);
            if (contentEl) {
                messageContent = contentEl.innerHTML;
            } else {
                messageContent = this.innerHTML;

                this.innerHTML = '';

                closeButtonEl = this.ownerDocument.createElement('button');
                closeButtonEl.className = 'btn hi hi-close';
                closeButtonEl.setAttribute('aria-hidden', true);
                closeButtonEl.setAttribute('aria-label', 'close');

                contentEl = this.ownerDocument.createElement('div');
                contentEl.className = 'message-content';
                headerEl = this.ownerDocument.createElement('header');

                if (!typeIconEl) {
                    typeIconEl = this.ownerDocument.createElement('span');
                    typeIconEl.classList.add('message-icon');
                }

                typeIconEl.setAttribute('aria-hidden', true);

                titleEl = this.ownerDocument.createElement('h4');

                headerEl.appendChild(titleEl);

                this.appendChild(typeIconEl);
                this.appendChild(closeButtonEl);
                this.appendChild(headerEl);
                this.appendChild(contentEl);
            }

            this.setAttribute('role', 'alert');
            this.dismissible = this.getAttribute('dismissible') !== 'false';
            this.message = messageContent;
            this.tabIndex = -1;
        },

        /**
         * Hides the element.
         * @emits PageMessage#hide
         * @deprecated Should be use PageMessage#close instead of PageMessage#hide.
         */
        hide: function() {
            console.warn('DEPRECATION WARNING: The "hide" event is going to be deprecated. From now on, please use "close" method instead.');
            this.emit('hide');
            this.close();
        },

        /**
         * Closes the element.
         * @emits PageMessage#close
         */
        close: function() {
            _handleFocusOnClose(this);
            this.classList.add('hidden');
            this.emit('close');
        },

        /**
         * This method must be removed, once the hide method is also removed.
         */
        addEventListener: function _() {
            HTMLElement.prototype.addEventListener.apply(this, arguments);
            if (arguments[0] === 'hide') {
                console.warn('DEPRECATION WARNING: The hide event is going to be deprecated. From now on, please use "close" instead.');
            }
        }
    });

    return register('ha-page-message', HAPageMessage);
});

define('hui/stacked-page-messages',[
    'register-component/v2/UIComponent',
    'register-component/v2/register',
    'object-utils/classes',
    './core/utils'
], function(UIComponent, register, classes, utils) {
    'use strict';

    var HAStackedPageMessages,
        ALERT_TYPE = 'alert', //for backward compatibility
        ERROR_TYPE = 'error',
        WARN_TYPE = 'warn';

    /**
     * Order the messages against its type.
     * @param {HAPageMessage} messageA
     * @param {HAPageMessage} messageB
     * @return {Number}
     */
    function _prioritize(messageA, messageB) {
        if (messageA.type !== messageB.type) {
            if (messageA.type === ALERT_TYPE || messageA.type === ERROR_TYPE) {
                return -1;
            } else if (messageB.type === ALERT_TYPE || messageB.type === ERROR_TYPE) {
                return 1;
            }

            if (messageA.type === WARN_TYPE) {
                return -1;
            } else if (messageB.type === WARN_TYPE) {
                return 1;
            }
        }
        return 0;
    }

    /**
     * Handles the focusing after closing the stacked-page-messages component
     * @param  {HTMLElement} component the stacked-page-messages component
     */
    function _handleFocusOnClose(component) {
        var parent = component.parentElement,
            previousSibling = component.previousElementSibling;

        if (previousSibling) {
            previousSibling.focus();
        } else if (parent) {
            previousSibling = parent.previousElementSibling;
            if (previousSibling) {
                previousSibling.focus();
            }
        }
    }

    function _findObsoleteMessages(oldMessages, newMessages) {
        return utils.getArrayDiff(oldMessages, newMessages);
    }

    function _findMessagesToAdd(oldMessages, newMessages) {
        return utils.getArrayDiff(newMessages, oldMessages);
    }

    HAStackedPageMessages = classes.createObject(UIComponent, {

        init: function _() {
            _.super(this);

            /**
             * Collection of messages to show.
             * @type {Array<HAPageMessage>}
             */
            this._messages = [];

            /**
             * Indicate if need sort the messages or not.
             */
            this._sortMessages = true;

            this.on('ha-page-message:close', function(event) {
                this.remove(this.messages.indexOf(event.target));
            }.bind(this));
        },

        /**
         * Adds a new message to the list.
         * @param {Object} message is the text of the message.
         * @param {Number} index of the message (optional)
         */
        add: function(message, index) {
            var newMessages = this.messages ? this.messages.slice() : [];
            if (message !== null) {
                if (index !== undefined) {
                    newMessages.splice(index, 0, message);
                    this._sortMessages = false;
                } else {
                    newMessages.push(message);
                }
            }
            this.messages = newMessages;
        },

        /**
         * Removes a message from the list.
         * @param {Number} index of the element to remove.
         */
        remove: function(index) {
            var messages;

            if (null !== this.messages && this.messages.length && index < this.messages.length) {
                messages = this.messages.slice();
                messages.splice(index, 1);
                this.messages = messages;
            }
        },

        /**
         * Add new messages into the component.
         * @param {Array} newMessages is the list of new page messages.
         */
        set messages(newMessages) {
            var toBeRemoved = _findObsoleteMessages(this._messages, newMessages),
                toBeAdded = _findMessagesToAdd(this._messages, newMessages);

            utils.removeNodesSafe(this, toBeRemoved);
            utils.appendChildCollection(this, toBeAdded);
            this._messages = newMessages;
            if (null !== newMessages && newMessages.length > 0) {
                //we will always sort the messages, except the last change on the set of messages
                //was an addition with an specific index. In that case, "_sortMessages" will be false
                //After doing that kind of addition, we set again the flag to true, to continue with
                //the normal behaviour
                if (this._sortMessages) {
                    newMessages.sort(_prioritize);
                }
                this._sortMessages = true;
                this.show();
            } else {
                this.close();
                _handleFocusOnClose(this);
            }
        },

        get messages() {
            return this._messages;
        },

        /**
         * Sort the messages.
         * Append the messages.
         * Select the last message.
         */
        postRender: function() {
            var oldMessages = utils.removeNodesSafe(this, this.querySelectorAll('ha-page-message'));

            this.innerHTML = '';
            this.messages = oldMessages;
        },

        /**
         * Hide the component.
         * @deprecated Should be use StackedPageMessages#close
         * @emits StackedPageMessages#hide for backward compatibility
         * @emits StackedPageMessages#close
         */
        hide: function() {
            this.close();
            console.warn('DEPRECATION WARNING: The "hide" method is going to be deprecated. From now please use "close" instead.');
            this.emit('hide');
        },

        /**
         * Close the component.
         * @emits StackedPageMessages#close
         */
        close: function() {
            this.classList.add('hidden');
            this.emit('close');
        },

        /**
         * Show the component.
         * @emits StackedPageMessages#show
         */
        show: function() {
            this.classList.remove('hidden');
            this.emit('show');
        },

        /**
         * This method must be removed, once the hide method is also removed.
         */
        addEventListener: function _() {
            HTMLElement.prototype.addEventListener.apply(this, arguments);
            if (arguments[0] === 'hide') {
                console.warn('DEPRECATION WARNING: The hide event is going to be deprecated. From now on, please use "close" instead.');
            }
        }
    });

    return register('ha-stacked-page-messages', HAStackedPageMessages);
});
define('hui/paginated-message',[
    'register-component/v2/register',
    'register-component/v2/UIComponent',
    'object-utils/classes'
], function(register, UIComponent, classes) {

    var HAPaginatedMessage;

    HAPaginatedMessage = classes.createObject(UIComponent, {

        init: function _() {
            _.super(this);

            /**
             * Content of the message
             */
            this._message = null;

            this.setupProperties({
                /**
                 * Title of the message.
                 * @type {String}
                 */
                titleText: {
                    default: '',
                    type: String,
                    change: function(newValue) {
                        this.querySelector('.message-title').textContent = newValue;
                        if (newValue) {
                            this.setAttribute('aria-label', newValue);
                        } else {
                            this.removeAttribute('aria-label');
                        }
                    }
                },

                /**
                 * Type of the message:
                 *  - info
                 *  - warn
                 *  - alert for backward compatibility
                 *  - error
                 * @type {String}
                 * @default: error
                 */
                type: {
                    default: 'error',
                    type: String,
                    change: function(newValue) {
                        if (newValue === 'alert') {
                            console.warn('DEPRECATION WARNING: The message type \'alert\' is deprecated. Please use \'error\' instead.');
                        }
                        if (newValue === 'alert' || newValue === 'error' || newValue === 'warn') {
                            this.querySelector('i').className = 'hi hi-circle-alert';
                        } else {
                            this.querySelector('i').className = 'hi hi-circle-info';
                        }
                    }
                }
            });
        },

        /**
         * Executed on show message.
         * @emits PaginatedMessage#show
         */
        show: function() {
            this.classList.remove('hidden');
            this.emit('show');
        },

        /**
         * Executed on hide message.
         * @emits PaginatedMessage#hide for backward compatibility
         * @emits PaginatedMessage#close
         * @deprecated should be use PaginatedMessage#close instead of PaginatedMessage#hide.
         */
        hide: function() {
            this.close();
            this.emit('hide');
            console.warn('DEPRECATION WARNING: The hide method is going to be deprecated. From now on, please use "close" instead.');
        },

        /**
         * Executed on close message.
         * @emits PaginatedMessage#close
         */
        close: function() {
            this.classList.add('hidden');
            this.emit('close');
        },

        set message(newValue) {
            if (typeof newValue === 'string') {
                this.querySelector('.message-content').innerHTML = newValue;
            } else {
                this.querySelector('.message-content').appendChild(newValue);
            }
            this._message = newValue;
        },

        get message() {
            return this._message;
        },

        /**
         * If it was rendered adds content, add/removes dismissible class, add corresponding type
         */
        postRender: function() {
            var contentEl = this.querySelector('.message-content'),
                titleEl = this.querySelector('.message-title'),
                iconEl = this.querySelector('i'),
                containerEl,
                messageContent;

            if (contentEl) {
                messageContent = contentEl.innerHTML;
            } else {
                messageContent = this.innerHTML;
            }

            if (!contentEl) {
                this.innerHTML = '';

                if (!iconEl) {
                    iconEl = this.ownerDocument.createElement('i');
                }
                iconEl.setAttribute('aria-hidden', true);

                containerEl = this.ownerDocument.createElement('div');
                containerEl.className = 'message-container';

                titleEl = this.ownerDocument.createElement('span');
                titleEl.className = 'message-title';
                titleEl.setAttribute('role', 'heading');
                titleEl.setAttribute('aria-level', '1');

                contentEl = this.ownerDocument.createElement('span');
                contentEl.className = 'message-content';

                containerEl.appendChild(titleEl);
                containerEl.appendChild(contentEl);

                this.appendChild(iconEl);
                this.appendChild(containerEl);

                this.setAttribute('role', 'alert');
            }

            this.message = messageContent;
            this.type = this.getAttribute('type') || 'error';
        },

        /**
         * This method must be removed, once the hide method is also removed.
         */
        addEventListener: function _() {
            HTMLElement.prototype.addEventListener.apply(this, arguments);
            if (arguments[0] === 'hide') {
                console.warn('DEPRECATION WARNING: The hide event is going to be deprecated. From now on, please use "close" instead.');
            }
        }
    });

    return register('ha-paginated-message', HAPaginatedMessage);
});

define('text!hui/paginated-messages/paginated-messages.html',[],function () { return '<template>\n    <div class="messages"></div>\n    <div class="pagination-control">\n        <button aria-label="Previous alert" class="navigate-previous"><i class="hi hi-chevron-left"></i></button>\n        <div class="pagination-control-text">\n        </div>\n        <button aria-label="Next alert" class="navigate-next"><i class="hi hi-chevron-right"></i></button>\n        <span class="arrow-border"></span>\n    </div>\n    <button aria-label="Close" class="btn hi hi-close"></button>\n</template>\n';});


define('hui/helpers/string.helper',[
], function() {
    var Helper = {
        replaceKeys: function(message, replaceData) {
            return message.replace(/{{([^{}]*)}}/g,
                function(a, b) {
                    var r = replaceData[b];
                    return typeof r === 'string' || typeof r === 'number' ? r : a;
                }
            );
        }
    };

    return Helper;
});

define('hui/paginated-messages',[
    'register-component/v2/register',
    'register-component/v2/UIComponent',
    'object-utils/classes',
    'register-component/template!./paginated-messages/paginated-messages.html',
    './core/keys',
    './helpers/string.helper',
    './core/utils',
    './core/a11y'
], function(register, UIComponent, classes, template, keys, stringHelper, utils, a11y) {

    /**
     * Updates visibility for next / previous message button and counters
     * @param {HAPaginatedMessages} component
     */
    function _updatePagination(component) {
        _paginationArrowsVisibility(component);
        _updateCounter(component);
    }

    /**
     * Updates visibility for next / previous message button
     * @param {HAPaginatedMessages} component
     */
    function _paginationArrowsVisibility(component) {
        var nextArrow = component.querySelector('.navigate-next'),
            previousArrow = component.querySelector('.navigate-previous'),
            focusOnNext = false,
            messagesCount = component._messages.length,
            doc = component.ownerDocument;

        if (component._displayedIndex === 1) {
            if (previousArrow === doc.activeElement) {
                focusOnNext = true;
            }
            previousArrow.classList.remove('visible');
        } else {
            previousArrow.classList.add('visible');
        }

        if (component._displayedIndex === messagesCount) {
            if (nextArrow === doc.activeElement) {
                previousArrow.focus();
            }
            nextArrow.classList.remove('visible');
        } else {
            nextArrow.classList.add('visible');

            if (focusOnNext) {
                nextArrow.focus();
            }
        }
    }

    /**
     * Updates counters for current message and total messages
     * @param {HTMLElement} component The component to be inspected
     */
    function _updateCounter(component) {
        var paginationContainer = component.querySelector('.pagination-control'),
            messagesCount = component._messages.length;

        if (messagesCount > 1) {
            paginationContainer.style.display = 'block';
        } else {
            paginationContainer.style.display = 'none';
        }

        paginationContainer.querySelector('.current-message').innerHTML = component._displayedIndex;
        paginationContainer.querySelector('.total-messages').innerHTML = messagesCount;
    }

    /**
     * Set the component on the specified message
     * @param {HTMLElement} component The component to be inspected
     * @param {Number} position The position of the message to be shown
     */

    function _goToMessage(component, position) {

        var messagesCount = component._messages.length,
            currentMessage;

        if (position > 0 && position <= messagesCount) {
            component._displayedIndex = position;
            currentMessage = component.querySelector('.paginated-message-displayed');
            if (currentMessage) {
                currentMessage.classList.remove('paginated-message-displayed');
            }

            component._messages[position - 1].classList.add('paginated-message-displayed');
            _updatePagination(component);
        }
    }

    var HAPaginatedMessages;

    HAPaginatedMessages = classes.createObject(UIComponent, {

        init: function _() {
            _.super(this);

            /**
             * Template of the element.
             * @type {String}
             */
            this.template = template;

            /**
             * Array of ha-paginated-message objects
             * @type {Array}
             * @private
             */
            this._messages = '';

            /**
             * Position of currently visible message
             * @type {Number}
             * @private
             */
            this._displayedIndex = 0;

            /**
             * Messages can be closed
             * @type {Boolean}
             */
            this._dismissible = true;

            this.setupProperties({
                /**
                 * Structure of the pagination messages
                 * @type {String}
                 */
                paginationLabel: {
                    default: '{{current}} of {{total}}',
                    type: String,
                    change: function(newValue) {
                        var template = stringHelper.replaceKeys(
                            newValue,
                            {
                                current: '<span class="current-message"></span>',
                                total: '<span class="total-messages"></span>'
                            }
                        );
                        this.querySelector('.pagination-control-text').innerHTML = template;
                        _updatePagination(this);
                    }
                }
            });

            this.on('.hi-close:click', function() {
                var messagesContainerEl = this.querySelector('.messages'),
                    messagesCount = this._messages.length,
                    currentMessage;
                if (this._dismissible && messagesCount > 0) {
                    currentMessage = messagesContainerEl.children[this._displayedIndex - 1];
                    currentMessage.close();
                    this._messages.splice(this._displayedIndex - 1, 1);
                    messagesContainerEl.removeChild(currentMessage);
                    messagesCount--;

                    this.emit('dismiss');

                    if (messagesCount === 0) {
                        this.close();
                    } else {
                        this._displayedIndex = Math.max(this._displayedIndex - 1, 1);
                        _goToMessage(this, this._displayedIndex);
                    }
                }

            }.bind(this));

            this.on('.navigate-next:click', function() {
                this.showNext();
            }.bind(this));
            this.on('.navigate-previous:click', function() {
                this.showPrevious();
            }.bind(this));
            this.on('keydown', function(evt) {
                if (evt.keyCode === keys.LEFT) {
                    this.showPrevious();
                } else if (evt.keyCode === keys.RIGHT) {
                    this.showNext();
                }
            }.bind(this), true);
        },

        /**
         * Return the display index that is a read only property.
         * @returns {Number}
         */
        get displayedIndex() {
            return this._displayedIndex;
        },

        get messages() {
            return this._messages;
        },

        get dismissible() {
            return this._dismissible;
        },

        set dismissible(newValue) {
            if (newValue) {
                this.classList.add('dismissible');
            } else {
                this.classList.remove('dismissible');
            }
            this._dismissible = newValue;
        },

        set messages(newValue) {
            this._messages = [];

            newValue = [].slice.call(newValue);

            var messagesContainerEl = this.querySelector('.messages'),
                firstMessage;

            messagesContainerEl.innerHTML = '';
            newValue.forEach(function(element) {
                messagesContainerEl.appendChild(element);
                this._messages.push(element);
            }.bind(this));

            firstMessage = messagesContainerEl.querySelector('ha-paginated-message:not(.hidden)');
            if (firstMessage) {
                firstMessage.classList.add('paginated-message-displayed');
            }

            _updatePagination(this);
        },

        /**
         * Shows next message
         * @emits PaginatedMessages#show-next
         */
        showNext: function() {
            _goToMessage(this, this._displayedIndex + 1);
            this.emit('show-next');
        },

        /**
         * Shows previous message
         * @emits PaginatedMessages#show-previous
         */
        showPrevious: function() {
            _goToMessage(this, this._displayedIndex - 1);
            this.emit('show-previous');
        },

        /**
         * Executed on show message.
         * @emits PaginatedMessages#show
         */
        show: function() {
            this.classList.remove('hidden');
            this.emit('show');
        },

        /**
         * Executed on hide message.
         * @deprecated Should be use PaginationMessages#close instead of PaginationMessages#hide.
         * @emits PaginatedMessages#hide for backward compatibility
         * @emits PaginatedMessages#close
         */
        hide: function() {
            this.close();
            this.emit('hide');
            console.warn('DEPRECATION WARNING: The hide method is going to be deprecated. From now on, please use "close" instead.');
        },

        /**
         * Executed on close message.
         * @emits PaginatedMessages#close
         */
        close: function() {
            a11y.setFocusOnPreviousElement(this);
            this.classList.add('hidden');
            this.emit('close');
        },

        /**
         * Transform list of messages from nodeArray to array
         */
        preRender: function() {
            var messages,
                messagesContainerEl = this.querySelector('.messages');

            // assign messages from ha-paginated-message nodes
            if (!this._messages) {
                messages = this.querySelectorAll('ha-paginated-message');
                if (messagesContainerEl) {
                    // but if we have rendered it already, don't attempt to remove the node
                    // make it an array
                    this._messages = Array.prototype.map.call(messages, function(element) {
                        return element;
                    });
                } else {
                    this._messages = utils.removeNodesSafe(this, messages);
                }
            }
        },

        /**
         * If it was rendered, empty the component and add the messages to it.
         */
        postRender: function() {
            var messagesContainerEl = this.querySelector('.messages'),
                firstMessage;

            this.setAttribute('tabindex', -1);

            messagesContainerEl.innerHTML = '';
            this._messages.forEach(function(element) {
                messagesContainerEl.appendChild(element);
            });

            if (this.getAttribute('dismissible') !== 'false') {
                this.dismissible = true;
            } else {
                this.dismissible = false;
            }

            this._displayedIndex = 1;

            firstMessage = messagesContainerEl.querySelector('ha-paginated-message:not(.hidden)');
            if (firstMessage) {
                firstMessage.classList.add('paginated-message-displayed');
            }
            a11y.addA11yFocus(this);
        },

        /**
         * This method must be removed, once the hide method is also removed.
         */
        addEventListener: function _() {
            HTMLElement.prototype.addEventListener.apply(this, arguments);
            if (arguments[0] === 'hide') {
                console.warn('DEPRECATION WARNING: The hide event is going to be deprecated. From now on, please use "close" instead.');
            }
        }
    });

    return register('ha-paginated-messages', HAPaginatedMessages);
});

define('hui/add-new-helper',[
    './core/popup',
    './core/menuItemUtils'
], function(popup, menuItemUtils) {

    /**
     * Hide given popover with the popup helper.
     * @param {HA-POPOVER|HA-POPOVER-FORM} popover
     * @private
     */
    function _hidePopover(popover) {
        if (popover && popover.open) {
            popup.hide(popover);
        }
    }

    /**
     * Show given popover with the popup helper.
     * @param {HTMLElement} select
     * @param {HTMLElement} popover
     * @private
     */
    function _showPopover(select, popover) {
        var content;

        if (popover) {
            if (select.tagName === 'HA-SELECT') {
                content = select;
            } else {
                content = select.querySelector('.search-container');
            }
            if (!popover.open) {
                popup.show(popover, content, ['bottom', 'top'], ['left', 'right']);
            }
        }
    }

    /**
     * Creates a new Add New menu item.
     * @param  {String} addNewText The text for add new
     * @param  {String} addNewValue The text after the add new text
     * @param  {Document} ownerDocument The ownerDocument
     * @return {HTMLElement} Created ha-menu-item
     */
    function _createAddNewMenuItem(addNewText, addNewValue, ownerDocument) {
        var labelWrapper,
            plusIcon,
            menuItem;

        plusIcon = ownerDocument.createElement('span');
        plusIcon.className = 'hi hi-create-lg';

        labelWrapper = menuItemUtils.createMenuItemLabelWrapper(ownerDocument, [plusIcon, ownerDocument.createTextNode([addNewText, addNewValue].join(' '))]);

        menuItem = ownerDocument.createElement('ha-menu-item');
        menuItem.label = labelWrapper;
        menuItem.value = '';
        menuItem.classList.add('add-new-menu-item');
        menuItem.setAttribute('role', 'option');
        menuItem.setAttribute('aria-label', addNewText);

        return menuItem;
    }

    /**
     * Creates new ha-menu-item and adds it to ha-menu
     * @param {ha-menu} menu           Where to insert the new menu item
     * @param {String}  addNewText     The text of add new value
     * @param {String}  addNewValue    The value of add new value
     * @private
     */
    function _addNewMenuItem(menu, addNewText, addNewValue) {
        var menuItem,
            items;

        items = menu.items;
        if (!items || items.length === 0 || !items[0].classList.contains('add-new-menu-item')) {
            menuItem = _createAddNewMenuItem(addNewText, addNewValue, menu.ownerDocument);
            menu.add(menuItem, 0);
        }
    }

    /**
     * Positions the cursor at the end of the value, if pre-populated
     * @param {HTMLElement} input The input element
     * @private
     */
    function _positionCursor(input) {
        var eol = input.value.length,
            range;

        // we set a timeout because this allows the element to be visible prior to setting the cursor
        setTimeout(function() {
            // IE
            /* istanbul ignore if */
            if (input.createTextRange) {
                range = input.createTextRange();
                range.move('character', eol);
                range.select();
            } else {
                // FF
                input.setSelectionRange(eol, eol);
            }

            input.focus();
        }, 0);
    }

    var Helper = {

        /**
         * Show the popover form of the component.
         * @param {HTMLElement} select  Component that contains the menu items popover
         * @param {HTMLElement} popover A popover component
         */
        showPopoverForm: function(select, popover) {
            var popoverMenu = select.dropdownElement,
                input,
                addNewNameSelector;

            _hidePopover(popoverMenu);
            if (select.tagName !== 'HA-SELECT') {
                addNewNameSelector = select.addNewPopover.querySelector('ha-popover-form').addNewNameSelector;
                if (addNewNameSelector) {
                    input = select.addNewPopover.querySelector(addNewNameSelector);
                    input.value = select.typedText;

                    _positionCursor(input.querySelector('input'));
                }
            }
            _showPopover(select, popover);
        },

        /**
         * Add the Add new menu item of given component.
         * @param {HTMLElement} select Component that contains the menu items popover
         */
        addMenuItem: function(select) {
            var popover = select.dropdownElement,
                addNewValue = '',
                menu = popover.querySelector('ha-menu');

            if (select.tagName !== 'HA-SELECT') {
                addNewValue = select.querySelector('input').value;
            }
            if (menu && menu.tagName === 'HA-MENU') {
                _addNewMenuItem(menu, select.addNewText, addNewValue);
            }
        }
    };

    return Helper;
});

define('hui/typeahead-base',[
        './validatable/validatable',
        'object-utils/classes',
        './core/popup',
        './core/event',
        './add-new-helper',
        './core/keys',
        './core/utils',
        './core/menuItemUtils',
        './core/deviceUtils',
        './modal',
        './popover',
        './popover-form',
        './menu',
        './menu-item',
        './text-field'
    ],
    function(validatable, classes, popup, eventUtil, AddNewHelper, keys, utils, menuItemUtils, deviceUtils) {
        'use strict';
        var HATypeAheadBase,
            STORE_MAX_RESULT = 7,
            // we use a closure var to save the current opened popover menu so that it can be closed if
            // a user clicks another select or text field type ahead. Blur alone didn't work for FF/Safari
            currentOpenedPopoverMenu = null;

        /**
         * Helper to get the ha-text-field used for searching
         * @param {HTMLElement} select Component to get the text field.
         * @return {HTMLElement} The ha-text-field.
         * @private
         */
        function _getTextField(select) {
            return select.querySelector('.search-container ha-text-field.search');
        }

        /**
         * Helper to get the owner host component (Text Field Type Ahead or Select Type Ahead) given a node
         * @param {HTMLElement} node The element used for searching
         * @return {HTMLElement} Text Field Type Ahead or Select Type Ahead
         * @private
         */
        function _getComponentFromElement(node) {
            return utils.getComponentFromElement(node, 'HA-TEXTFIELD-TYPE-AHEAD') ||
                    utils.getComponentFromElement(node, 'HA-SELECT-TYPE-AHEAD');
        }

        /**
         * Call the popop helper to show the popover menu of the component.
         * @param {HTMLElement} popover The popover with menu items to show.
         * @param {HTMLElement} positionTarget The element that should be used to position the popover when it is opened.
         * @private
         */
        function _showPopover(popover, positionTarget) {
            if (popover) {

                // logically if you think about it, the setting of properties in menuPopover should be in postRender
                // but due to cloneNode issues, it sets first to true, then the popover.postRender gets called which sets it again to false
                // setting it here guarantees it is always true

                // do not focus on menuPopover child element on show
                popover._noAutoFocusFirstTabbableElementOnShow = true;
                // when have a menuPopover open and we click outside it should not focus back to the component
                popover._noAutoFocusLastActiveElementOnClose = true;

                if (popover.open) {
                    popup.setPosition(popover, positionTarget, ['bottom', 'top'], ['left', 'right']);
                } else {
                    popup.show(popover, positionTarget, ['bottom', 'top'], ['left', 'right']);
                    utils.showPopoverOrModal(popover, positionTarget, popup);
                    currentOpenedPopoverMenu = popover;
                }
            }
        }

        /**
         * Call the popup helper to close the popover menu of the component.
         * @param {HTMLElement} popover The popover to close.
         * @private
         */
        function _hidePopover(popover) {
            utils.hidePopoverOrModal(popover, popup);
        }

        /**
         * Update the class and aria-expanded attribute of the component and then delegate to `_hidePopover` to
         * handle actually closing the dropdown menu
         * @param {HATypeAheadBase} select - The typeahead component to hide the dropdown menu of
         * @private
         */
        function _hidePopoverMenu(select) {
            var popover = select.dropdownElement;
            select.classList.remove('menu-expanded');
            select._getTriggerElement().setAttribute('aria-expanded', 'false');
            _hidePopover(popover);
        }
        /**
         * Add the select item to the items list
         * @param  {HTMLElement}    select  Where to insert the new select item
         * @param  {String}         label   Text and value for the select item
         */
        function _addCreatedItem(select, label) {
            var item,
                storeLabel = select.storeLabelProperty,
                storeValue;

            if (select.tagName === 'HA-TEXTFIELD-TYPE-AHEAD') {
                storeValue = select.storeLabelProperty;
            } else {
                storeValue = select.storeValueProperty;
            }

            if (select.store) {
                item = {};
                item[storeLabel] = label;
                item[storeValue] = label;
                select._cachedItems.push(item);
            } else {
                //TODO: show error message
                console.error('No store defined. Please add a store where items can be retrieved');
            }
        }

        /**
         * Finds selected item on popover form, and updated the corresponding values on the component
         * @param {HTMLElement} select Component to update values
         * @emits HASelect#change
         * @private
         */
        function _setNewElementAsSelected(select) {
            var newItem,
                popoverForm;

            popoverForm = select.addNewPopover.querySelector('ha-popover-form');

            // If there's no addNewNameSelector, we don't know where to get the
            // new item name from
            if (!popoverForm.addNewNameSelector) {
                utils.hidePopoverOrModal(select.addNewPopover, popup);
                return;
            }

            newItem = popoverForm.querySelector(popoverForm.addNewNameSelector);

            if (!newItem || !newItem.value) {
                utils.hidePopoverOrModal(select.addNewPopover, popup);
                return;
            }

            // New item is added to the dropdown list
            utils.hidePopoverOrModal(select.addNewPopover, popup);
            _addCreatedItem(select, newItem.value);

            select.value = newItem.value;
            select.classList.add('element-selected');
            select.dropdownElement.classList.add('element-was-selected');

            newItem.value = '';

            select.emit('change');
        }

        /**
         * Creates a new menu item
         * @param  {HTMLElement}            select  Where to insert the new menu item
         * @param  {String|HTMLElement}     label   Text for the item
         * @param  {String}                 value   Value for the item
         * @param  {Object}                 data    The item data that is associated with the selectedItem
         * @param  {String}                 textLabel   The text of the label attribute without HTML elements
         * @param  {String}                 searchValue The search string
         * @param  {Object}                 matchingItems The filtered item list
         * @return {HTMLElement}            Created ha-menu-item
         */
        function _createMenuItem(select, label, value, data, textLabel, searchValue, matchingItems) {
            var menuItem = select.ownerDocument.createElement('ha-menu-item'),
                customRenderer = select.itemRenderer || select.renderItem;
            if (typeof customRenderer === 'function') {
                menuItem.label = customRenderer(menuItem, data, label, select, eventUtil, searchValue, matchingItems);
                menuItem.setAttribute('aria-label', data.label);
                menuItem.disabled = menuItem.label.disabled;
                menuItem.value = data.label;
            }else {
                menuItem.label = label;
                menuItem.value = value || label;
                menuItem.data = data;
            }
            // a11y
            menuItem.setAttribute('role', 'option');
            if (textLabel) {
                // override aria-label attribute value in order to be sure that we set only text label.
                setTimeout(function() {
                    menuItem.setAttribute('aria-label', textLabel);
                }, 0);
            }

            return menuItem;
        }

        /**
         * Sorts items on alphabetical order
         * @param  {Array}  itemsArray      List of items to add to the select
         * @param  {String} compareField    Internal property to use for comparison
         * @private
         */
        function _sortItems(itemsArray, compareField) {
            itemsArray.sort(function(a, b) {
                if (a[compareField] < b[compareField]) {
                    return -1;
                }
                if (a[compareField] > b[compareField]) {
                    return 1;
                }
                return 0;
            });
        }

        /**
         * Filters items using specified filterMode, sorts them alphabetically, adds them to the menu and shows the popover.
         * Items can be of type ha-select-item (if not using store), or literal objects that matches the defined storeLabelProperty and
         *
         * @param  {HTMLElement}    select Component to show
         * @param  {Array}          items  List of items to filter.
         * @param  {Boolean}        noSearch  Boolean flag to determine do filter or not.
         * @private
         */
        function _filterAndShowPopover(select, items, noSearch) {
            var matchingItems = [],
                currentItem,
                itemsCount,
                currentItemLabel,
                modifiedCurrentItemLabel,
                menu = select.dropdownElement.querySelector('ha-menu'),
                localLabel,
                localValue,
                re,
                searchValue,
                i,
                popover,
                positionTarget,
                labelWrapper;

            if (items.length === 0) {
                menu.items = [];
                if (deviceUtils.isDesktop() && !select.addNew) {
                    return;
                }
            }

            searchValue = (noSearch) ? '' : _getTextField(select).value.toString();

            localLabel = select.storeLabelProperty;
            if (select.tagName === 'HA-TEXTFIELD-TYPE-AHEAD') {
                localValue = select.storeLabelProperty;
            } else {
                localValue = select.storeValueProperty;
            }

            if (searchValue === '') {
                if (select.tagName === 'HA-SELECT-TYPE-AHEAD' || deviceUtils.isDesktop()) {
                    items.forEach(function(item) {
                        matchingItems.push(_createMenuItem(select, item[localLabel], item[localValue], item, null, searchValue, matchingItems));
                    });
                }
            } else {
                if (select.filterMode === 'contains') {
                    itemsCount = items.length;
                    re = new RegExp(searchValue, 'gi');
                    for (i = 0; i < itemsCount; i++) {
                        currentItem = items[i];
                        currentItemLabel = currentItem[localLabel];
                        if (re.test(currentItemLabel)) {
                            modifiedCurrentItemLabel = currentItemLabel.replace(re, function replacer(match) {
                                return utils.createElement('span', {
                                            className: 'type-ahead-strong',
                                            innerHTML: match
                                        }).outerHTML;
                            });
                            modifiedCurrentItemLabel = utils.createElement('span', {
                                innerHTML: modifiedCurrentItemLabel
                            });
                            labelWrapper = menuItemUtils.createMenuItemLabelWrapper(select.ownerDocument, [modifiedCurrentItemLabel]);
                            matchingItems.push(_createMenuItem(select, labelWrapper, currentItem[localValue], currentItem, currentItemLabel, searchValue, matchingItems));
                        }
                    }
                }
            }

            if (!select._alreadySortedItems && select._sortList) {
                _sortItems(matchingItems, 'textContent');
            }

            if (matchingItems.length > STORE_MAX_RESULT && searchValue && select.tagName === 'HA-TEXTFIELD-TYPE-AHEAD') {
                matchingItems = Array.prototype.slice.call(matchingItems, 0, STORE_MAX_RESULT);
            }

            menu.items = matchingItems;

            if (select.tagName === 'HA-SELECT-TYPE-AHEAD' && select.value) {
                for (i = 0; i < matchingItems.length; i++) {
                    currentItem = matchingItems[i];

                    if (currentItem[localValue] === select.value) {
                        currentItem.setAttribute('selected', 'selected');
                    } else {
                        currentItem.removeAttribute('selected');
                    }
                }
            }

            if (deviceUtils.isHandheld() || matchingItems.length > 0 || (matchingItems.length === 0 && select.addNew)) {
                popover = select.dropdownElement;

                if (!select.disabled) {
                    // before showing the popover, add the "Add New" menu item
                    if (select.addNew) {
                        AddNewHelper.addMenuItem(select);
                    }

                    positionTarget = select.querySelector('.search-container');
                    select.classList.add('menu-expanded');
                    select._getTriggerElement().setAttribute('aria-expanded', 'true');
                    _showPopover(popover, positionTarget);
                }
            } else if (deviceUtils.isDesktop()) {
                // Don't hide on mobile. We're filtering within the dialog so we don't want to close it
                _hidePopoverMenu(select);
            }
        }

        /**
         * Listener for key presses
         * @emits HASelect#keypress
         * @param  {event} event Event
         * @private
         */
        function _keyPressListener(event) {
            var component;

            // These keys should not open the popover
            if (event.keyCode === keys.TAB || event.keyCode === keys.ENTER || event.keyCode === keys.ESCAPE || event.keyCode === keys.SPACEBAR) {
                return;
            }

            component = _getComponentFromElement(event.target);
            component._openedByKeyboard = true;
            component._searchOnTimeout();
        }

        /**
         * Update the menu items of the component.
         * @param {HTMLElement} component   The component that will be updated.
         * @private
         */
        function _updateItems(component) {
            var match = '';

            if (!component.staticItems) {
                match = component.typedText;
            }

            component._fetchItems(match, function() {
                component.emit('items-update');
            });
        }

        /**
         * Clear up the value of the component.
         * @param {HTMLElement} component   The component that will be clear its value.
         * @private
         */
        function _clearValue(component) {
            component.value = '';
            _getTextField(component).value = '';
            component._selectedItem = null;
            component.classList.remove('element-selected');
        }

        /**
         * Post Keydown Handler.
         * This function is extended from popover component to handle keydown event.
         * @param {HTMLElement} component   The component will be a popover.
         */
        function _postHandleKeydown(component) {
            var targetSelect;

            if (component && component.target) {
                targetSelect = component.target.parentElement;
            }
            if (targetSelect && (targetSelect.tagName === 'HA-SELECT-TYPE-AHEAD' || targetSelect.tagName === 'HA-TEXTFIELD-TYPE-AHEAD')) {
                targetSelect._textField.focus();
            }
        }

        HATypeAheadBase = classes.createObject(validatable, {

            init: function _() {

                _.super(this);

                this._openedByKeyboard = false;

                this._alreadySortedItems = false;

                // This variable is for knowing this.value is set by app programmatically or by user's action
                this._isValueSetByProgram = true;

                /**
                 * Items retrieved from the store. Used only if a store is defined
                 * @type {Array}
                 */
                this._cachedItems = null;

                /**
                 * Repository for items to show on the component
                 * @type {Object}
                 */
                this._store = null;

                /**
                 * Custom renderer for the select items
                 * @type {Function}
                 * @deprecated
                 */
                this._renderItem = null;

                /**
                 * Custom renderer for the select items
                 * @type {Function}
                 */
                this._itemRenderer = null;

                /**
                 * Sort list property. Default value is true.
                 */
                this._sortList = true;

                /**
                 * Selected item.
                 * @type {Object}
                 */
                this._selectedItem = null;

                /**
                 * Popover that contains a form to submit a new item for the select
                 * @type {HTMLElement}
                 */
                this._addNewPopover = null;

                /**
                 * Fetches item from the store, and stores them in cache
                 * Finally executes the callback if it's defined
                 * @param  {String}         match       String to match against store
                 * @param  {Function}       callback    Optional. Callback to call after successful query
                 * @private
                 */
                this._fetchItems = function(match, callback) {
                    match = match || '';
                    var queryStore = {'contains': match};
                    this._alreadySortedItems = false;

                    if (this.store && this.store.query) {
                        this.store.query(queryStore).then(function(itemsList) {
                            if (this.staticItems && this._sortList) {
                                // If items are static, we can preorder them
                                _sortItems(itemsList, this.storeLabelProperty);
                                this._alreadySortedItems = true;
                            }

                            this._cachedItems = itemsList;
                            if (callback) {
                                callback(this, itemsList);
                            }
                        }.bind(this));
                    } else {
                        console.error('No store defined or \'query\' method does not exist on the store. Please set a correct store');
                    }

                };

                /**
                 * Find the match value from cachedItems
                 * @param {String}    inputValue   The string value from ha-text-field.
                 * @param {Boolean}   isLabel   The boolean value indicates the inputValue is a label or not.
                 * @return {String}   The match value from cachedItems, if no matches it will be empty string.
                 */
                this._getMatchItemValue = function(inputValue, isLabel) {
                    var textfield = _getTextField(this),
                        storeValue = isLabel ? this.storeLabelProperty : this.storeValueProperty,
                        currentItem,
                        i,
                        labelValue;

                    if (!this.store || !this._cachedItems) {
                        // This will be evaluated before the possibility to add a store
                        // so this is not an error situation
                        return '';
                    }

                    for (i = 0; i < this._cachedItems.length; i++) {
                        currentItem = this._cachedItems[i];

                        if (currentItem[storeValue] === inputValue) {
                            this._selectedItem = currentItem;
                            labelValue = this._selectedItem[this.storeLabelProperty];
                            textfield.value = labelValue;
                            this.typedText = labelValue;
                            this.classList.add('element-selected');
                            if (this.tagName === 'HA-TEXTFIELD-TYPE-AHEAD') {
                                return labelValue;
                            } else {
                                return this._selectedItem[this.storeValueProperty];
                            }
                        }
                    }
                    return '';
                };

                /**
                 * Checks input text value is valid or not before set it to component's value.
                 */
                this._checkAndSetValue = function() {
                    var matchValue = this._getMatchItemValue(this.typedText, true);

                    if (!this.value || this.value !== this.typedText) {
                        this._isValueSetByProgram = false;
                        this.value = matchValue;
                        if (!this.value) {
                            this.value = '';
                            this.typedText = '';
                        }
                    }
                };

                /**
                 * Gets the items from the corresponding location based on component settings:
                 *  - If no store is defined, throws an error
                 *  - If store is defined, but items are static, uses the cached items
                 *  - Otherwise, fetch the items from the store
                 *  After getting items, they are filtered and results are shown
                 *  @param  {HTMLElement}  showAll  The argument 'showAll' is for determine to show all popover items or not
                 */
                this._matchAndShowResults = function(showAll) {
                    if (this.store) {
                        if (showAll) {
                            if (!this.staticItems || !this._cachedItems) {
                                this._fetchItems(null, function() {
                                    _filterAndShowPopover(this, this._cachedItems, true);
                                }.bind(this));
                            } else {
                                _filterAndShowPopover(this, this._cachedItems, true);
                            }
                        } else if (this.staticItems && this._cachedItems) {
                            _filterAndShowPopover(this, this._cachedItems);
                        } else {
                            this._fetchItems(_getTextField(this).value, _filterAndShowPopover);
                        }
                    } else {
                        console.error('No store defined. Please add a store where items can be retrieved');
                    }
                };

                /**
                 * Encapsulates the logic for handling a click on a trigger element
                 * @private
                 */
                this._triggerElementClickListener  = function() {
                    var menuPopover = this.dropdownElement;

                    this.querySelector('ha-text-field').classList.add('mobile-focused');
                    if (this.addNewPopover && this.addNewPopover.open) {
                        popup.hide(this.addNewPopover);
                    } else if (utils.isOpen(menuPopover)) {
                        utils.hidePopoverOrModal(menuPopover, popup);
                    } else {
                        this._openedByKeyboard = false;
                        this._matchAndShowResults(true);
                    }
                    setTimeout(function() {
                        this.querySelector('ha-text-field').classList.remove('mobile-focused');
                    }.bind(this), 500);

                    this.emit('click');
                };

                /**
                 * Sets a timeout to search for a match
                 */
                /* istanbul ignore next */
                this._searchOnTimeout = function() {
                    var keyWaitTime = 250;
                    if (this._timeOut) {
                        clearTimeout(this._timeOut);
                    }
                    this._timeOut = setTimeout(function() {
                        this._matchAndShowResults();
                    }.bind(this), keyWaitTime);
                };

                this.setupProperties({
                    /**
                     * The label for this select.
                     * @property label
                     * @type {String}
                     */
                    label: {
                        default: '',
                        type: String,
                        change: function(newValue) {
                            var label = this.querySelector('label'),
                                button = this.querySelector('.action-button'),
                                textField = this.querySelector('.search-container ha-text-field'),
                            // FIXME: we reached the local ha-text-field local input just to set attributes
                                textFieldLocalInput = textField && textField.querySelector('input'),
                                labelId;

                            if (newValue) {
                                if (!label) {
                                    label = this.ownerDocument.createElement('label');
                                    this.insertBefore(label, this.firstElementChild);

                                    labelId = this.localName + '-label-' + this.componentId;
                                    label.setAttribute('id', labelId);
                                    label.setAttribute('for', textFieldLocalInput.id);
                                    if (button) {
                                        button.setAttribute('aria-describedby', labelId);
                                    }
                                } else {
                                    // label exists already, use it's id to set
                                    textFieldLocalInput.id = label.getAttribute('for');
                                }

                                label.textContent = utils.toggleSuffixText(newValue, ' *', this.required && !this.noRequiredIndicator);
                                if (deviceUtils.isDesktop()) {
                                    textFieldLocalInput.removeAttribute('aria-label');
                                } else {
                                    var menu = this.querySelector('ha-modal.popover-menu-items');
                                    menu.titleText = newValue;
                                }
                                this.classList.remove('no-label');
                            } else {
                                if (label && label.parentNode === this) {
                                    this.removeChild(label);
                                    if (button) {
                                        button.removeAttribute('aria-describedby');
                                    }
                                }
                                textFieldLocalInput.setAttribute('aria-label', this.placeholder || this.typeaheadAriaLabel);
                                this.classList.add('no-label');
                            }

                        }
                    },

                    /**
                     * The filtering mode or algorithm to be used on the candidate items.
                     * @type {String}
                     */
                    filterMode: {
                        default: 'contains'
                    },

                    /**
                     * The property name of a provided store data element that maps to the "label" of the item.
                     * @type {String}
                     */
                    storeLabelProperty: {
                        default: 'label'
                    },

                    /**
                     * Determines whether or not the items provided by the store will be static
                     * @type {Boolean}
                     */
                    staticItems: {
                        default: false,
                        type: Boolean,
                        change: function(newValue) {
                            if (newValue && this.store) {
                                this._fetchItems();
                            } else {
                                this._cachedItems = null;
                            }
                        }
                    },

                    /**
                     * Name of the component.
                     * @type {String}
                     */
                    name: {
                        default: '',
                        type: String,
                        change: function(newValue) {
                            _getTextField(this).name = newValue;
                        }
                    },

                    /**
                     * Add New capability.
                     * @type {Boolean}
                     */
                    addNew: {
                        default: false,
                        type: Boolean
                    },

                    /**
                     * Add New Text.
                     * @type {String}
                     */
                    addNewText: {
                        default: 'Add New',
                        type: String
                    },

                    /**
                     * Value of the selected item.
                     * @type {String}
                     */
                    value: {
                        default: '',
                        type: String,
                        change: function(newValue, oldValue) {
                            var textfield = _getTextField(this),
                                isTextTypeAhead = false,
                                matchLabel;

                            if (this.tagName === 'HA-TEXTFIELD-TYPE-AHEAD') {
                                isTextTypeAhead = true;
                            }
                            if (newValue === oldValue) {
                                if (newValue) {
                                    this.typedText = this._selectedItem[this.storeLabelProperty];
                                }
                            } else {
                                if (!this.store || !this._cachedItems) {
                                    // This will be evaluated before the possibility to add a store
                                    // so this is not an error situation
                                    return;
                                }
                                // If we fail to find the value on the list, we empty the value
                                if (!newValue) {
                                    _clearValue(this);
                                } else {
                                    if (this._isValueSetByProgram) {
                                        if (isTextTypeAhead) {
                                            this._getMatchItemValue(newValue, true);
                                        } else {
                                            matchLabel = this._getMatchItemValue(newValue, false);
                                            if (!matchLabel) {
                                                _clearValue(this);
                                            }
                                        }
                                    }
                                    if (isTextTypeAhead && !this.addNew) {
                                        textfield.value = newValue;
                                    }
                                }
                            }
                            this._isValueSetByProgram = true;
                        }
                    },

                    /**
                     * This is the placeholder for the textfield.
                     * @type {String}
                     */
                    placeholder: {
                        default: '',
                        change: function(newValue) {

                            if (deviceUtils.isHandheld()) {
                                var menu = this.querySelector('ha-modal.popover-menu-items');
                                menu.querySelector('ha-text-field').placeholder = newValue;
                            }
                            _getTextField(this).placeholder = newValue;

                            if (!newValue) {
                                if (this.hasAttribute('placeholder')) {
                                    this.removeAttribute('placeholder');
                                }
                            }
                        }
                    },

                    /**
                     * This is a custom class to be added to the modal on mobile.
                     * @type {String|Array}
                     */
                    mobileMenuClass: {
                        default: '',
                        change: function(newValue) {
                            if (!newValue && this.hasAttribute('mobileMenuClass')) {
                                this.removeAttribute('mobileMenuClass');
                            }

                            if (newValue && deviceUtils.isHandheld() && this.dropdownElement) {
                                if (Array.isArray(newValue)) {
                                    for (var className in newValue) {
                                        this.dropdownElement.classList.add(className);
                                    }
                                } else if (typeof newValue === 'string') {
                                    this.dropdownElement.classList.add(newValue);
                                }
                            }
                        }
                    },

                    /**
                     * noRequiredIndicator indicates whether '*' should be
                     * appended to the label when the field is required
                     * @type {Boolean}
                     */
                    noRequiredIndicator: {
                        default: false,
                        type: Boolean,
                        change: function(newValue, oldValue) {
                            if (newValue !== oldValue) {
                                var label = this.querySelector('label');
                                if (label && this.required) {
                                    label.textContent = utils.toggleSuffixText(label.textContent, ' *', !newValue);
                                }
                            }
                        }
                    },

                    required: {
                        default: false,
                        type: Boolean,
                        change: function(newValue, oldValue) {
                            var label = this.querySelector('label'),
                                input = this.querySelector('input');

                            if (newValue !== oldValue) {
                                if (label) {
                                    label.textContent = utils.toggleSuffixText(label.textContent, ' *', newValue && !this.noRequiredIndicator);
                                }
                                if (!this._validateIgnoreEvent) {
                                    this._validateIgnoreEvent = function() {
                                        this.reportValidity();
                                    }.bind(this);
                                }
                                if (!this._validateUseEvent) {
                                    this._validateUseEvent = function(evt) {
                                        this.reportValidity(evt);
                                    }.bind(this);
                                }

                                /* istanbul ignore next */
                                if (newValue) {
                                    eventUtil.on(this._menuPopover, 'close', this._validateIgnoreEvent);
                                    this.on('input:focusout', this._validateUseEvent);

                                    input.setAttribute('required', true);
                                    input.setAttribute('aria-required', 'true');
                                } else {
                                    eventUtil.off(this._menuPopover, 'close', this._validateIgnoreEvent);
                                    this.off('input:focusout', this._validateUseEvent);

                                    input.setAttribute('required', false);
                                    input.removeAttribute('aria-required');
                                }
                                this.handleTooltipBinding(newValue);
                            }
                        }
                    },

                    // Show menu items on focus for suggestions.
                    openItemsOnFocus: {
                        default: false,
                        type: Boolean
                    },

                    /**
                     * The aria-label for the select button
                     */
                    typeaheadAriaLabel: {
                        default: 'View Choices',
                        type: String,
                        change: function(newValue) {
                            var selectButton = this.querySelector('.search-container input'),
                                actionButtonAccessibilityLabel = this.querySelector('button.action-button span.sr-only');
                            if (selectButton.type === 'button' || !this.label) {
                                selectButton.setAttribute('aria-label', this.placeholder || newValue);
                            } else if (actionButtonAccessibilityLabel) {
                                actionButtonAccessibilityLabel.textContent =  this.placeholder || newValue;
                            }
                        }
                    }

                });

                /**
                 * Handle key presses
                 * @emits HASelect#add-new
                 */
                this.on('keydown', function(evt) {
                    var target = evt.target,
                        menuPopover = this.dropdownElement,
                        menu = menuPopover.querySelector('ha-menu'),
                        newFocus,
                        typedText,
                        matchValue;

                    switch (evt.keyCode) {
                        case keys.TAB:
                            // If TAB is pressed on the input
                            if (target.tagName === 'INPUT' && target.parentElement.classList.contains('search')) {
                                if (utils.isOpen(menuPopover)) {
                                    _hidePopoverMenu(this);
                                }

                                matchValue = this._getMatchItemValue(this.typedText, true);

                                if (this.addNew) {
                                    this._openedByKeyboard = true;
                                    typedText = this.typedText;

                                    if (evt.shiftKey) {
                                        this._checkAndSetValue();
                                        break;
                                    }

                                    if (this.value !== this.typedText) {
                                        this._isValueSetByProgram = false;
                                        this.value = matchValue;
                                        if (!this.value) {
                                            utils.stopEvent(evt);
                                            this.typedText = typedText;
                                            this.addNewPopover._closeOnBlur = true;
                                            AddNewHelper.showPopoverForm(this, this.addNewPopover);
                                        }
                                    }
                                } else {
                                    this._isValueSetByProgram = false;
                                    this.value = (this.tagName === 'HA-TEXTFIELD-TYPE-AHEAD') ? (matchValue) ? matchValue : this.typedText : matchValue;

                                    // If shift-tab, we are leaving the component
                                    if (evt.shiftKey) {
                                        break;
                                    }
                                }
                            } else if (target === this.querySelector('button.action-button')) {
                                if (utils.isOpen(menuPopover)) {
                                    utils.stopEvent(evt);
                                    _hidePopoverMenu(this);
                                }
                            }
                            break;
                        case keys.ESCAPE:
                            // Needed when focus is on input
                            if (utils.isOpen(menuPopover)) {
                                utils.stopEvent(evt);
                                _hidePopoverMenu(this);
                            }
                            _getTextField(this).focus();
                            break;
                        case keys.DOWN:
                            utils.stopEvent(evt);
                            if (utils.isOpen(menuPopover)) {
                                // if popover is already open and position is bottom
                                if (menuPopover.classList.contains('position-bottom')) {
                                    newFocus = (menu.items && menu.items.length > 0) ? menu.items[0] : menu;
                                    newFocus.focus();
                                }
                            } else {
                                // open popover if not yet opened
                                this._openedByKeyboard = true;
                                this._matchAndShowResults(this);
                            }
                            break;
                        case keys.UP:
                            utils.stopEvent(evt);
                            if (utils.isOpen(menuPopover)) {
                                // if popover is already open and position is top
                                if (menuPopover.classList.contains('position-top')) {
                                    newFocus = (menu.items && menu.items.length > 0) ? menu.items[menu.items.length - 1] : menu;
                                    newFocus.focus();
                                }
                            } else {
                                // open popover if not yet opened
                                this._openedByKeyboard = true;
                                this._matchAndShowResults(this);
                            }
                            break;
                        case keys.BACKSPACE:
                        case keys.DELETE:
                            if (target.tagName === 'INPUT' && target.parentElement.classList.contains('search')) {
                                this._openedByKeyboard = true;
                                this._searchOnTimeout();
                            }
                    }
                }.bind(this));
            },

            postRender: function _() {
                _.super(this);

                var div = this.querySelector('div.search-container'),
                    textField = _getTextField(this),
                    handheld = deviceUtils.isHandheld(),
                    menu = this.querySelector('ha-menu'),
                    menuPopover = this.querySelector((handheld ? 'ha-modal' : 'ha-popover') + '.popover-menu-items'),
                    popoverForm = this.querySelector('ha-popover-form'),
                    containerId = this.localName + '-' + this.componentId + '-search-container',
                    input = this.querySelector('.search-container ha-text-field input');

                // If we are using declarative/programatic instantiation (not cloning)
                if (!div) {
                    div = this.ownerDocument.createElement('div');
                    div.classList.add('search-container');

                    textField = this.ownerDocument.createElement('ha-text-field');
                    textField.classList.add('search');
                    div.appendChild(textField);
                    input = textField.querySelector('input');

                    this.appendChild(div);

                    // create menu
                    menu = this.ownerDocument.createElement('ha-menu');
                    menu.classList.add('typeahead-menu');
                    menu.setAttribute('role', 'listbox');

                    // create popover and append menu
                    menuPopover = this.ownerDocument.createElement(handheld ? 'ha-modal' : 'ha-popover');
                    menuPopover.targetSelector = '#' + containerId;
                    menuPopover.classList.add('popover-menu-items');
                    menuPopover.section = menu;

                    if (handheld) {
                        this._createPopoverFilterTextField(menuPopover);
                    }

                    this.appendChild(menuPopover);
                }

                this.dropdownElement = menuPopover;

                div.id = containerId;
                menuPopover.targetSelector = '#' + containerId;

                menuPopover.postHandleCloseOnBlur = function(popover, target) {
                    var targetSelect,
                        activeElement;

                    if (popover && target) {
                        activeElement = popover.ownerDocument.activeElement;

                        if (popover.target) {
                            targetSelect = popover.target.parentElement;
                        }
                        if (targetSelect && targetSelect.tagName === 'HA-SELECT-TYPE-AHEAD') {
                            if (!target.classList.contains('add-new-menu-item') && !popover.querySelector('ha-popover-form') && !targetSelect.contains(activeElement)) {
                                targetSelect._checkAndSetValue();
                            }
                        }
                    }
                };

                menuPopover.postHandleKeydown = _postHandleKeydown;

                this.listenTo(textField, 'focus', function(evt) {
                    evt.stopPropagation();
                    // Required to be able to style the component when children get focus or hover
                    this.querySelector('.search-container').classList.add('focused');

                    if (this._menuPopover && this._menuPopover.open) {
                        this._menuPopover.close();
                    }
                    if (this.openItemsOnFocus && deviceUtils.isDesktop()) {
                        this._matchAndShowResults();
                    }
                    this.emit('focus');
                }.bind(this), true);

                this.listenTo(textField, 'click', function(evt) {
                    evt.stopPropagation();
                    if (!this.disabled) {
                        if (deviceUtils.isDesktop()) {
                            evt.target.select();
                            // Required to be able to style the component when children get focus or hover
                            this.querySelector('.search-container').classList.add('focused');
                        } else {
                            this._triggerElementClickListener();
                        }
                    }
                }.bind(this), true);

                this.listenTo(textField, 'keypress', _keyPressListener, true);

                // This can't be updated on keypress
                this.listenTo(textField, 'keyup', function(evt) {
                    if (evt.keyCode !== keys.ESCAPE) {
                        this.typedText = textField.value;
                    }
                }.bind(this), true);

                this.listenTo(this, 'blur', function(evt) {
                    var target = evt.target;

                    if (target === textField.querySelector('input')) {
                        // if target is this._menuPopover when user passes his mouse over the popover and clicks
                        // on another component, this makes sure to hide the popover
                        this._blurCheck(evt);
                    }
                }.bind(this), true);

                if (popoverForm && popoverForm.parentNode) {
                    this.addNewPopover = popoverForm.parentNode;
                }

                this.listenTo(this._menuPopover, 'show', function(evt) {
                    // HUI-4255: let HASelectTypeahead consumers know popover's shown
                    this.emit('items-show');
                    evt.stopPropagation();
                }.bind(this));

                this.listenTo(this._menuPopover, 'close', function(evt) {
                    // HUI-4255: let HASelectTypeahead consumers know popover's closed
                    this.emit('items-close');
                    evt.stopPropagation();

                    if (this.addNew) {
                        // remove Add New menu item
                        this.dropdownElement.querySelector('ha-menu').remove(0);
                    }
                    // make sure to remove always
                    this._getTriggerElement().setAttribute('aria-expanded', 'false');
                    this.classList.remove('menu-expanded');
                    this.reportValidity();
                }.bind(this));

                // backward-compatibility popover hide event, we should stop bubbling
                this.listenTo(this._menuPopover, 'hide', function(evt) {
                    evt.stopPropagation();
                }.bind(this));

                /**
                 * Handle changes of selected elements on menu
                 * @emits HASelect#change
                 */
                eventUtil.on(this._menuPopover, 'select', function(evt) {
                    var selectedElem,
                        menu = this.dropdownElement.querySelector('ha-menu');

                    if (evt.target !== menu) {
                        return;
                    }

                    _hidePopoverMenu(this);
                    selectedElem = menu.selectedItem;
                    this._itemSelected = true;

                    /* If the first item 'addNew' and the add new property is true and
                     the addNewPopover is set the, show the last */
                    if (this.addNew && selectedElem.classList.contains('add-new-menu-item')) {
                        this.addNewPopover._closeOnBlur = true;
                        AddNewHelper.showPopoverForm(this, this.addNewPopover);
                        this.emit('add-new');
                    } else {
                        if (this.tagName === 'HA-TEXTFIELD-TYPE-AHEAD') {
                            this.typedText = selectedElem.value;
                        } else if (typeof this.renderItem === 'function' || typeof this.itemRenderer === 'function') {
                            this.typedText = selectedElem.value;
                        } else {
                            this.typedText = selectedElem.getAttribute('aria-label');
                        }
                        if (this.value !== selectedElem.value) {
                            this._isValueSetByProgram = false;
                            // this allows the change event to have the right evt.target.value and evt.target.selectedItem
                            this.value = selectedElem.value;
                            // we get the <ha-menu-item>.data that was assigned when we were creating the data
                            this._selectedItem = selectedElem.data;
                        }
                        this.classList.add('element-selected');
                        this.dropdownElement.classList.add('element-was-selected');
                        // focus on the text field
                        if (deviceUtils.isDesktop()) {
                            _getTextField(this).focus();
                        }
                        this.emit('change');
                    }
                }.bind(this));

                this.listenTo(this._menuPopover, 'keydown', function(evt) {
                    if (evt.keyCode === keys.TAB && deviceUtils.isDesktop()) {
                        textField.focus();
                        utils.stopEvent(evt);
                    }
                }.bind(this));

                if (handheld) {
                    menuPopover.titleText = this.label;
                    menuPopover.dismissible = true;
                    menuPopover.classList.add('mobile-menu');
                    menuPopover.classList.add('mobile-type-ahead-menu');
                    menuPopover.size = 'fullscreen';

                    // for mobile we want a button because we don't the input to be editable
                    input.type = 'button';
                    input.setAttribute('aria-label', this.placeholder || this.typeaheadAriaLabel);

                    this.listenTo(menuPopover, 'will-show', function() {
                        this._savedBodyScrollTop = document.body.scrollTop;
                    }.bind(this));

                    this.listenTo(menuPopover, 'will-close', function() {
                        if (document.activeElement) {
                            document.activeElement.blur();
                        }

                        if (this._savedBodyScrollTop) {
                            document.body.scrollTop = this._savedBodyScrollTop;
                            this._savedBodyScrollTop = null;
                        }
                    }.bind(this));

                    this.listenTo(menuPopover, 'close', function() {
                        if (this.addNewPopover && this.addNewPopover.open) {
                            return;
                        }

                        input.focus();

                        /*
                         we need to set focus, then later blur and re-add focus, if we
                         don't, VoiceOver on iOS will not properly restore focus.
                         */
                        setTimeout(function() {
                            if (document.activeElement === input) {
                                input.blur();
                                input.focus();
                            }
                        }, 100);
                    }.bind(this));

                    this.listenTo(input, 'blur', function(evt) {
                        this._blurCheck(evt);
                    }.bind(this));
                }
            },

            /**
             * Creates an HATextfield for the dropdown menu. This textfield is used to filter the items in the dropdown
             * menu on mobile. It's also wrapped in a form so that the value can be selected on form submission.
             * @param {HAModal | HAPopover} menuPopover
             * @private
             */
            _createPopoverFilterTextField: function(menuPopover) {
                var textfield = document.createElement('ha-text-field'),
                    form = document.createElement('form'),
                    submit = document.createElement('input'),
                    menu = menuPopover.querySelector('ha-menu'),
                    focusOnmenu = function() {
                        menu.focus();
                    };

                submit.type = 'submit';
                submit.value = '';
                form.action = '#';
                form.classList.add('typeahead-mobile-form');
                form.addEventListener('submit', function(event) {
                    event.stopPropagation();
                    event.preventDefault();

                    this._saveNewValue = true;
                    menuPopover.close();
                }.bind(this));

                textfield.setAttribute('autocomplete', 'off');
                textfield.classList.add('active');
                this.listenTo(textfield, 'keyup', function(event) {
                    if (event.keyCode === keys.ESCAPE || event.keyCode === keys.ENTER) {
                        return;
                    }
                    this._matchAndShow = true;
                    this.typedText = textfield.value;
                }.bind(this));

                if (deviceUtils.getOSName() === 'iOS') {
                    menuPopover._lockBody = true;
                }

                this.listenTo(menuPopover, 'show', function() {
                    this._tempValue = this.typedText;
                    if (this.tagName === 'HA-SELECT-TYPE-AHEAD') {
                        this._matchAndShow = true;
                        textfield.value = this.typedText = _getTextField(this).value || '';
                    } else {
                        textfield.value = this.typedText || '';
                    }
                    if (deviceUtils.getOSName() === 'iOS') {
                        this.listenTo(textfield, 'blur', focusOnmenu);
                    }
                }.bind(this));

                // Restore value typed before opening modal if
                // none was selected
                this.listenTo(menuPopover, 'close', function() {
                    if (!this._itemSelected && !this._saveNewValue) {
                        this.typedText = this._tempValue;
                    }
                    this._itemSelected = false;
                    this._saveNewValue = false;
                    if (deviceUtils.getOSName() === 'iOS') {
                        this.stopListening(textfield, 'blur', focusOnmenu);
                    }
                }.bind(this));

                if (this.tagName === 'HA-TEXTFIELD-TYPE-AHEAD') {
                    form.appendChild(textfield);
                    form.appendChild(submit);
                    menu.parentNode.insertBefore(form, menu);

                    //This change event listener are created for mobile-text-field-type-ahead .
                    this.listenTo(textfield, 'change', function(evt) {
                        evt.stopPropagation();
                        this.emit('change');
                    }.bind(this));
                } else {
                    menu.parentNode.insertBefore(textfield, menu);
                }
            },

            detachedCallback: function() {
                [this._addNewPopover, this._menuPopover].forEach(function(popover) {
                    if (popover && popover.parentElement) {
                        popover.parentElement.removeChild(popover);
                    }
                });
            },

            /**
             * Gets the store object
             */
            get store() {
                return this._store;
            },

            /**
             * Sets new store object.
             * Empties items, cached items, and current value
             * @param  {Object} newValue Store that contains the items
             */
            set store(newValue) {
                this._store = newValue;

                this._cachedItems = [];
                this.value = '';

                if (this.staticItems) {
                    this._fetchItems();
                }

                if (this._store && this._store.on) {
                    this._store.on('add', function() {
                        _updateItems(this);
                    }.bind(this));

                    this._store.on('delete', function() {
                        _updateItems(this);
                    }.bind(this));
                }
            },

            /**
             * Gets the custom renderer if any
             * @deprecated
             */
            get renderItem() {
                return this._renderItem;
            },

            /**
             * Sets the new function for custom rendering of select items
             * @param {Function} newValue Custom render function.
             * @deprecated
             */
            set renderItem(newValue) {
                this._renderItem = newValue;
            },

            /**
             * Gets the custom renderer if any
             */
            get itemRenderer() {
                return this._itemRenderer;
            },

            /**
             * Sets the new function for custom rendering of select items
             * @param {Function} newValue Custom render function.
             */
            set itemRenderer(newValue) {
                this._itemRenderer = newValue;
            },

            /**
             * Gets the sort property
             */
            get sortList() {
                return this._sortList;
            },

            /**
             * Sets the sort list property. If false list will not be sorted by default.
             */
            set sortList(newValue) {
                this._sortList = newValue;
            },
            /**
             * Gets the ha-popover element that will host the ha-popover-form for adding a new item
             */
            get addNewPopover() {
                return this._addNewPopover;
            },

            /**
             * Sets the ha-popover element that will host the ha-popover-form for adding a new item
             * @param  {HTMLElement} newPopover Popover to store
             */
            set addNewPopover(newPopover) {
                var targetSelectorId;

                if (this.addNewPopover && this.addNewPopover !== newPopover) {
                    this.removeChild(this.addNewPopover);
                }

                this._addNewPopover = newPopover;

                if (newPopover) {
                    this._addNewPopover.postHandleKeydown = _postHandleKeydown;
                    targetSelectorId = this.querySelector('.search-container').id;

                    // make sure we add the targetSelector via id or attribute
                    if (newPopover.targetSelector) {
                        newPopover.targetSelector = '#' + targetSelectorId;
                    } else {
                        newPopover.setAttribute('targetSelector', '#' + targetSelectorId);
                    }

                    newPopover.classList.add('popover-add-items');
                    newPopover.setAttribute('automationId', 'addNewItem_popover');
                    this.appendChild(newPopover);

                    var popoverForm = newPopover.querySelector('ha-popover-form');
                    if (popoverForm) {
                        /**
                         * Handle save add item button
                         * @emits HASelect#add-new
                         */
                        eventUtil.on(popoverForm, 'save', function(evt) {
                            utils.stopEvent(evt);
                            _setNewElementAsSelected(this);
                            this.emit('add-new');
                        }.bind(this));

                        /* Handle cancel add item button */
                        eventUtil.on(popoverForm, 'cancel', function(evt) {
                            utils.stopEvent(evt);
                            _hidePopover(this.addNewPopover);
                        }.bind(this));
                    }
                }

            },

            /**
             * Gets the ha-popover element that will contain the list of selectable items
             */
            _getMenuPopover: function() {
                if (!this._menuPopover) {
                    this._menuPopover = this.querySelector((deviceUtils.isHandheld() ? 'ha-modal' : 'ha-popover') + '.popover-menu-items');
                }

                return this._menuPopover;
            },

            /**
             * Helper to get the ha-text-field used for searching
             * @return {HTMLElement} The ha-text-field.
             */
            get _textField() {
                return _getTextField(this);
            },

            /**
             * Gets the typedText
             */
            get typedText() {
                var textField = _getTextField(this);
                return textField.value;
            },

            /**
             * value that currently appears in the editable text field.
             * @type {String}
             */
            set typedText(newValue) {
                var textfield = _getTextField(this);
                if (textfield.value !== newValue) {
                    textfield.value = newValue;
                }
                if (this.tagName === 'HA-TEXTFIELD-TYPE-AHEAD' && !this.addNew) {
                    this.value = this.typedText;
                }

                if (this._matchAndShow) {
                    this._matchAndShow = false;
                    this._matchAndShowResults();
                }
            },

            /**
             * Checks if focus has left the component, in which case hides the popover
             * @param {event} event Event that triggered the blur
             */
            _blurCheck: function(event) {
                var component = _getComponentFromElement(event.target),
                    safeTarget = utils.getSafeTargetFromEvent(event);

                component.querySelector('.search-container').classList.remove('focused');

                if (!(component.contains(safeTarget) || component.dropdownElement.contains(safeTarget))) {
                    _hidePopoverMenu(component);
                    if (component.tagName === 'HA-SELECT-TYPE-AHEAD' && !(component.addNew && safeTarget.parentElement.id === 'addNewName')) {
                        component._checkAndSetValue();
                    }
                    component.emit('blur');
                }
            },

            get _inputElement() {
                return _getTextField(this)._inputElement;
            },

            get dropdownElement() {
                if (!this._menuPopover) {
                    this._menuPopover = this.querySelector((deviceUtils.isHandheld() ? 'ha-modal' : 'ha-popover') + '.popover-menu-items');
                }
                return this._menuPopover;
            },

            set dropdownElement(dropdownElement) {
                this._menuPopover = dropdownElement;
            },

            /**
             * Validates the component. If the event is a blur event we need to
             * execute asynchronously to verify that focus hasn't shifted to the
             * dropdown menu.
             *
             * @param {Event} evt - Optional event parameter
             * @returns {*|{value}}
             */
            reportValidity: function _(evt) {
                // this block for not doing reportValidity when focus jump to menuPopover, so need check menuPopover open state
                if (evt && evt.type === 'blur' && this._menuPopover.open) {
                    setTimeout(function() {
                        if (!this._menuPopover ||
                            !(this._menuPopover.contains(document.activeElement) || this.contains(document.activeElement))) {
                            _.super(this, evt);
                        }
                    }.bind(this), 0);
                }  else {
                    if (deviceUtils.isHandheld()) {
                        var errorMessage = this.querySelector('.input-error-message'),
                            input = this.querySelector('input');
                        if (errorMessage) {
                            errorMessage.setAttribute('id', 'input-error-message-' + this.componentId);
                            input.setAttribute('aria-describedby', 'input-error-message-' + this.componentId);
                        } else {
                            input.removeAttribute('aria-describedby');
                        }
                        if (!evt || (evt.type !== 'blur' && evt.type !== 'hide')) {
                            _.super(this, evt);
                        }
                    } else {
                        _.super(this, evt);
                    }
                }
            },

            /**
             * Reset validation for the component. If the popover opens, need close it first and reset validation.
             */
            resetValidation: function _() {
                // need to make sure close the popover first then rest validation
                // since after validation listening to popover close
                if (this.dropdownElement.open) {
                    this.dropdownElement.close(true);
                }
                _.super(this);
            }
        });

        return HATypeAheadBase;
    });

define('hui/select-type-ahead',[
    'register-component/v2/register',
    'object-utils/classes',
    './typeahead-base',
    './core/icon',
    './core/popup',
    './core/keys',
    './core/utils',
    './core/deviceUtils',
    './popover',
    './popover-form',
    './menu',
    './menu-item',
    './text-field'
],
function(register, classes, typeaheadBase, icon, popup, keys, utils, deviceUtils) {
    'use strict';
    var HASelectTypeAhead;

    function _triggerElementClickListener(component) {
        var popoverMenu = component.dropdownElement;

        if (component.addNewPopover && component.addNewPopover.open) {
            popup.hide(component.addNewPopover);
        } else if (popoverMenu.open) {
            popup.hide(popoverMenu);
            component.querySelector('.search-container ha-text-field input').focus();
        } else {
            component._openedByKeyboard = false;
            component._matchAndShowResults(component);
        }
        component.emit('click');
    }

    HASelectTypeAhead = classes.createObject(typeaheadBase, {

        init: function _() {

            _.super(this);

            /**
             * The element that the validator will use to get the values to validate
             * @type {HTMLElement}
             */
            this.validationTarget = this;

            /**
             * The selector for the elements to highlight if an error is detected
             * @type {String}
             */
            this.highlightElementSelector = '.search input';

            this.setupProperties({
                /**
                 * Disabled indicates if the menu button is disabled.
                 * @type {Boolean}
                 */
                disabled: {
                    default: false,
                    type: Boolean,
                    change: function(newValue) {
                        var actionButton = this.querySelector('button.action-button');
                        if (actionButton) {
                            actionButton.disabled = newValue;
                        }
                        this.querySelector('ha-text-field.search').disabled = newValue;
                        if (newValue) {
                            this.classList.add('disabled');
                        } else {
                            this.classList.remove('disabled');
                        }
                    }
                },

                /**
                 * The name of a Harmony icon to display within the component
                 * @type {string}
                 */
                icon: {
                    default: '',
                    type: String,
                    change: icon.onChangeIconProperty
                },

                /**
                 * The property name of a provided store data element that maps to the "value" of the item.
                 * @type {String}
                 */
                storeValueProperty: {
                    default: 'value'
                },

                /**
                 * Number of elements before showing a scrollbar.
                 * @type {Integer}
                 */
                size: {
                    default: 7,
                    type: Number,
                    change: function(newValue) {
                        var menu = this.dropdownElement.querySelector('ha-menu'),
                            isMenuRendered = !!menu.render;
                        if (isMenuRendered) {
                            menu.size = newValue;
                        } else {
                            menu.setAttribute('size', newValue);
                        }
                    }
                },

                /**
                 * A util for the root component tag name.
                 * @type {String}
                 */
                _ownerComponentName: {
                    default: 'HA-SELECT-TYPE-AHEAD',
                    type: String
                },

                /**
                 * Property to ease with Automation Effort. When set with a value, the value
                 * would get as attribute for ha-popover as well.
                 * @type {String}
                 */
                automationId: {
                    default: '',
                    type: String,
                    change: function(newValue, oldValue) {
                        if (newValue !== oldValue) {
                            if (deviceUtils.isDesktop) {
                                var menuPopover = this.querySelector('ha-select-type-ahead ha-popover.popover-menu-items');
                                if (menuPopover && newValue) {
                                    menuPopover.setAttribute('automationId', newValue + '_popover');
                                } else if (menuPopover && !newValue) {
                                    menuPopover.removeAttribute('automationId');
                                }
                            }

                            if (deviceUtils.isHandheld) {
                                var adpativeModalMenu = this.querySelector('ha-select-type-ahead ha-modal');
                                if (adpativeModalMenu && newValue) {
                                    adpativeModalMenu.setAttribute('automationId', newValue + '_modal');
                                } else if (adpativeModalMenu && !newValue) {
                                    adpativeModalMenu.removeAttribute('automationId');
                                }
                            }
                        }
                    }
                }
            });
        },

        /* when the circle close icon is clicked,
         * clear the input and focus on the input
         */
        _clearInputValue: function(textField) {
            var menu = textField.parentElement.querySelector('ha-menu');

            if (this.value !== '') {
                // if value is not already empty
                this.value = '';
                this._tempValue = '';

                // deselect menu item on menu component
                menu.selectedIndex = -1;
                this.emit('change');
            }
            // reset text field and show results
            textField.value = '';
            this._matchAndShowResults(true);
            // textfield should maintain focus, because otherwise placeholder disappears
            textField.focus();
        },

        postRender: function _() {
            _.super(this);

            var triggerElement = this.querySelector('button.action-button'),
                div = this.querySelector('div.search-container'),
                arrowUp,
                arrowDown,
                accesibilityTextNode,
                handheld = deviceUtils.isHandheld(),
                popoverMenu = this.querySelector((handheld ? 'ha-modal' : 'ha-popover') + '.popover-menu-items');

            if (deviceUtils.isDesktop()) {
                // If we are using declarative/programmatic instantiation (not cloning)
                if (!triggerElement) {
                    triggerElement = this.ownerDocument.createElement('button');
                    triggerElement.type = 'button';
                    triggerElement.classList.add('action-button');
                    triggerElement.setAttribute('aria-expanded', 'false');
                    triggerElement.setAttribute('aria-haspopup', 'true');
                    // add an attribute 'tabindex' = -1 is in order to skip focus on it when press TAB key
                    triggerElement.setAttribute('tabindex', '-1');

                    arrowUp = this.ownerDocument.createElement('span');
                    arrowUp.classList.add('caret');
                    arrowUp.setAttribute('aria-hidden', 'true');
                    triggerElement.appendChild(arrowUp);

                    arrowDown = this.ownerDocument.createElement('span');
                    arrowDown.classList.add('caret');
                    arrowDown.setAttribute('aria-hidden', 'true');
                    triggerElement.appendChild(arrowDown);

                    accesibilityTextNode = this.ownerDocument.createElement('span');
                    accesibilityTextNode.classList.add('sr-only');
                    accesibilityTextNode.innerHTML = this.placeholder || this.typeaheadAriaLabel;
                    triggerElement.appendChild(accesibilityTextNode);

                    div.appendChild(triggerElement);
                }

                this.listenTo(triggerElement, 'click', function(evt) {
                    if (this.disabled) {
                        return;
                    }

                    evt.stopPropagation();

                    // FF and Safari lose focus on the triggerElement when clicked
                    // use workaround below to focus again
                    triggerElement.focus();
                    _triggerElementClickListener(this);
                }.bind(this));

                this.listenTo(triggerElement, 'focus', function() {
                    // Required to be able to style the component when children get focus or hover
                    this.querySelector('.search-container').classList.add('focused');
                }.bind(this), true);

                this.listenTo(triggerElement, 'blur', function(evt) {
                    this._blurCheck(evt);
                }.bind(this), true);

                this.listenTo(triggerElement, 'keydown', function(evt) {
                    if (evt.keyCode === keys.SPACEBAR || evt.keyCode === keys.ENTER) {
                        // If focus in on button with arrows
                        if (evt.target.classList.contains('action-button')) {
                            utils.stopEvent(evt);
                            if (!popoverMenu.open) {
                                this._openedByKeyboard = true;
                                this._matchAndShowResults(this);
                            }
                        }
                    } else if (evt.keyCode === keys.TAB) {
                        /* istanbul ignore if */
                        if (!evt.shiftKey && this.typedText !== this.value) {
                            var matchValue = this._getMatchItemValue(this.typedText, true);
                            this._isValueSetByProgram = false;
                            this.value = matchValue;
                        }
                    }
                }.bind(this), true);

                // Fix for firefox triggering click when pressing spacebar
                this.listenTo(triggerElement, 'keyup', function(evt) {
                    /* istanbul ignore if */
                    if (evt.keyCode === keys.SPACEBAR) {
                        evt.preventDefault();
                    }
                }, true);
            } else {

                var textfield = this.querySelector('ha-text-field'),
                    popoverTF = popoverMenu.querySelector('ha-text-field'),
                    circleClear = this.ownerDocument.createElement('button'),
                    that = this;

                popoverMenu.classList.add('select-ta-mobile-menu');

                // Mobile: different trigger element style
                arrowDown = this.ownerDocument.createElement('button');
                arrowDown.classList.add('hi');
                arrowDown.classList.add('hi-chevron-down');
                arrowDown.setAttribute('aria-hidden', 'true');
                textfield.appendChild(arrowDown);

                circleClear.className = 'btn btn-link hi hi-global-create';
                circleClear.setAttribute('aria-label', 'Clear input');
                popoverTF.appendChild(circleClear);

                // Chrome isn't registering click events
                this.listenTo(circleClear, 'focus', function() {
                    that._clearInputValue(popoverTF);
                });

                // Safari isn't registering focus events
                this.listenTo(circleClear, 'click', function() {
                    that._clearInputValue(popoverTF);
                });
                // HUI-4246: Set ownerTag on elements with a parent component
                textfield.ownerTag = this._ownerComponentName;

                // Only add immediate focus utils if iOS 9
                deviceUtils.addiOS9ImmediateFocus();
            }
        },

        /**
         * Dummy method to avoid problems with getter without setters
         */
        set selectedItem(newValue) {
            // jshint unused:false
        },

        /**
         * Gets the selected item from the menu
         */
        get selectedItem() {
            return this._selectedItem;
        },

        /**
         * Queries the component for it's trigger element, which may be a button or an input depending
         * on whether we're on desktop or mobile.
         * @returns {Element}
         * @private
         */
        _getTriggerElement: function() {
            return this.querySelector('button.action-button') || this.querySelector('input[type="button"]');
        }

    });
    return register('ha-select-type-ahead', HASelectTypeAhead);
});

define('hui/select',[
    './validatable/validatable',
    'register-component/v2/register',
    './core/icon',
    './core/popup',
    './core/event',
    './core/keys',
    './core/utils',
    './core/deviceUtils',
    'object-utils/classes',
    './add-new-helper',
    './core/menuItemUtils',
    './core/domObserver',
    './modal',
    './popover',
    './popover-form',
    './menu',
    './menu-item',
    './item'
],
function(validatable, register, icon, popup, eventUtil, keys, utils, deviceUtils, classes, AddNewHelper, menuItemUtils, domObserver) {
    'use strict';

    var HASelect,

        /**
         * Flag that establish if popover was opened by click on keyboard
         * @type {Boolean}
         */
        openedByKeyboard = false;

    /*
    * Determine whether we should show the required * or not
    * If we are given a newValue overwrite the old label string/DOM with it
    * Else recursively search the label's DOM till we find the last word and manipulate it
    * @param  {String} optional if you want to replace your label string and test showing the required indicator
    */
    function handleRequiredIndicator(component, newValue, label) {
        var lastString;
        label = label || component.querySelector('label');

        // recursively walk through the label DOM to find the last work
        function walkLabelDOM(node) {
            if (node.nodeType === 3 && node.textContent.trim() !== '') {
                lastString = node;
            }
            node = node.firstChild;
            while (node) {
                walkLabelDOM(node);
                node = node.nextSibling;
            }
        }

        if (label) {
            if (newValue) {
                // overwrite old label with newValue, toggle * if needed
                label.textContent = utils.toggleSuffixText(newValue, ' *', component.required && !component.noRequiredIndicator);
            } else {
                // start recursion
                walkLabelDOM(label);
                if (lastString) {
                    // if we found the last work in the label DOM, toggle * if needed
                    lastString.textContent = utils.toggleSuffixText(lastString.textContent, ' *', component.required && !component.noRequiredIndicator);
                }
            }
        }
    }

    function _findImmediateChildNode(childNodeName, select) {
        var childNodes = Array.prototype.slice.call(select.childNodes);
        for (var child in childNodes) {
            if (childNodes[child].nodeName === childNodeName) {
                return childNodes[child];
            }
        }
        return null;
    }

    function _showPopoverMenu(popover, triggerElement) {
        triggerElement.setAttribute('aria-expanded', 'true');
        triggerElement.classList.add('active');

        // logically if you think about it, the setting of properties in menuPopover should be in postRender
        // but due to cloneNode issues, it sets first to true, then the popover.postRender gets called which sets it again to false
        // setting it here guarantees it is always true

        if (deviceUtils.isHandheld()) {
            popover._noAutoFocusLastActiveElementOnClose = false;
        } else {
            // do not focus on menuPopover child element on show
            popover._noAutoFocusFirstTabbableElementOnShow = true;
            // when have a menuPopover open and we click outside it should not focus back to the component
            popover._noAutoFocusLastActiveElementOnClose = true;
        }

        // the positionTarget is the triggerElement in this case
        utils.showPopoverOrModal(popover, triggerElement, popup);
    }

    /**
     * Call the popup helper to close the popover menu of the component.
     * @param {HTMLElement} popover The popover to close.
     * @private
     */
    function _hidePopover(popover) {
        utils.hidePopoverOrModal(popover, popup);
    }

    /**
     * Update the class and aria-expanded attribute of the component and then delegate to `_hidePopover` to
     * handle actually closing the dropdown menu
     * @param {HAModal | HAPopover} popover - the popover to hide
     * @param {HTMLElement} triggerElement - The trigger element of the component
     * @private
     */
    function _hidePopoverMenu(popover, triggerElement) {
        if (!utils.isOpen(popover)) {
            return;
        }

        triggerElement.setAttribute('aria-expanded', 'false');
        utils.hidePopoverOrModal(popover, popup);
    }

    /**
     * Creates a new select item
     * @param  {HTMLElement}    select  Where to insert the new select item
     * @param  {String}         value   Value for the select item
     * @param  {String}         label   Text for the select item
     * @return {HTMLElement}            Created select item
     */
    function _createSelectItem(select, value, label) {
        var item = select.ownerDocument.createElement('ha-item');
        item.label = label;
        item.value = value;
        item.sanitizeInputs = select._sanitizeInputs;
        return item;
    }

    /**
     * Add the select item to the items list
     * @param  {HTMLElement}    select  Where to insert the new select item
     * @param  {String}         label   Text and value for the select item
     */
    function _addHAItemElem(select, label) {
        var selectItem = _createSelectItem(select, label, label),
            items = select.items;

        items.unshift(selectItem);
        select.items = items;
    }

    /**
     * Finds selected item on popover form, and updated the corresponding values on the component
     * @param {HTMLElement} select Component to update values
     * @emits HASelect#change
     */
    function _setNewElementAsSelected(select) {
        var newItem,
            popoverForm;

        popoverForm = select.addNewPopover.querySelector('ha-popover-form');

        // If there's no addNewNameSelector, we don't know where to get the
        // new item name from
        if (!popoverForm.addNewNameSelector) {
            utils.hidePopoverOrModal(select.addNewPopover, popup);
            return;
        }

        newItem = popoverForm.querySelector(popoverForm.addNewNameSelector);

        if (!newItem || !newItem.value) {
            utils.hidePopoverOrModal(select.addNewPopover, popup);
            return;
        }

        // New item is added to the dropdown list
        utils.hidePopoverOrModal(select.addNewPopover, popup);
        _addHAItemElem(select, newItem.value);

        select.value = newItem.value;
        select.classList.add('element-selected');
        select.dropdownElement.classList.add('element-was-selected');

        newItem.value = '';

        select.emit('change');
    }

    function _blurEventHandler(triggerElement, evt) {
        /*jshint validthis:true*/
        var safeTarget = utils.getSafeTargetFromEvent(evt);

        if (!this.contains(safeTarget) &&
            safeTarget !== this._menuPopover &&
            !(this._menuPopover.contains(safeTarget)) &&
            !(this._menuPopover.contains(evt.target))) {

            // at this point we have moved outside, hide all popover and emit blur so
            // that validation can receive it
            _hidePopoverMenu(this._menuPopover, triggerElement);
            this.emit('blur');
        }
    }

    function selectedItemRenderer(label, item, renderer) {
        if (typeof renderer === 'function') {
            utils.replaceChildrenOf(label, renderer(item));
        } else {
            label.textContent = item.textContent || item.label;
        }
    }

    /**
     * Function to determine the menu-items updated by sanitized or not.
     * @param {Array}    newItems Array of new items values
     * @param {Array}    oldItems Array of old items values
     * @return {Boolean}
     * @private
     */
    function isSanitizeUpdate(newItems, oldItems) {
        var i;
        if (!newItems || !oldItems || newItems.length !== oldItems.length) {
            return false;
        }

        for (i = 0; i < newItems.length; i++) {
            if (newItems[i].value !== oldItems[i].value) {
                return false;
            }
        }

        return true;
    }

    function setDefaultAriaLabel(hostComponent) {
        var triggerElement = hostComponent.querySelector('button.action-button');

        // only set aria-label by default if we have placehoder/selectButtonAriaLabel
        if (hostComponent.placeholder || hostComponent.selectButtonAriaLabel) {
            triggerElement.setAttribute('aria-label', hostComponent.placeholder || hostComponent.selectButtonAriaLabel);
        } else {
            if (triggerElement.hasAttribute('aria-label')) {
                triggerElement.removeAttribute('aria-label');
            }
        }
    }

    /**
     * Removes all ha-menu-items underneath ha-menu-items
     * @param {HTMLElement} menuElement The ha-menu element
     */
    function removeMenuItemElements(menuElement) {
        var menuItemsElement;

        // if menu is rendered, remove all menu-items
        if (!!menuElement.render) {
            // If menu is rendered
            while (menuElement.items.length > 0) {
                menuElement.remove(0);
            }
        } else {
            // If menu is not rendered yet
            menuItemsElement = Array.prototype.slice.call(menuElement.querySelectorAll('ha-menu-item'));
            menuItemsElement.forEach(function(item) {
                menuElement.removeChild(item);
            });
        }
    }

    /**
     * Removes all ha-items underneath ha-select
     * @param {HTMLElement} hostElement The ha-select element
     */
    function removeItemElements(hostElement) {
        var itemsElement = Array.prototype.slice.call(hostElement.querySelectorAll('ha-item'));
        itemsElement.forEach(function(item) {
            hostElement.removeChild(item);
        });
    }

    /**
     * Removes all ha-items underneath ha-select
     * @param {HTMLElement} menuElement The ha-menu element
     * @param {Array} menuItemsElement Array of ha-menu-item
     */
    function addMenuItemElements(menuElement, menuItemsElement) {
        // if menu is rendered, then set it via .items
        if (!!menuElement.render) {
            menuElement.items = menuItemsElement;
        } else {
            // just in case ha-menu is not upgraded to a web component yet, loop and add manually
            menuItemsElement.forEach(function(menuItem) {
                menuElement.appendChild(menuItem);
            });
        }
    }

    HASelect = classes.createObject(validatable, {

        createdCallback: function _() {
            var value;
            if (this.hasAttribute('value')) {
                value = this.getAttribute('value');
            }

            _.super(this);

            if (value) {
                setTimeout(function() {
                    this.value = value;
                }.bind(this), 0);
            }
        },

        init: function _() {

            _.super(this);

            /**
             * The element that the validator will use to get the values to validate
             * @type {HTMLElement}
             */
            this.validationTarget = this;

            /**
             * The selector for the elements to highlight if an error is detected
             * @type {String}
             */
            this.highlightElementSelector = '.action-button';

            this._items = null;

            this._label = '';

            this._sanitizeInputs = false;

            /**
             * Popover that contains a form to submit a new item for the select
             * @type {HTMLElement}
             */
            this._addNewPopover = null;

            /**
             * A validation function bound to this instance for use in event callbacks
             * @type {Function}
             * @private
             */
            this._boundValidate = this.validate.bind(this);

            this.setupProperties({

                /**
                 * Whether or not items should be forcibly sanitized
                 * @type {Boolean}
                 */
                sanitizeInputs: {
                    default: false,
                    type: Boolean,
                    change: function(newValue) {
                        var menu = this._menu || this.dropdownElement.querySelector('ha-menu'),
                        isMenuRendered = !!menu.render;
                        if (isMenuRendered) {
                            menu.sanitizeInputs = newValue;
                        } else {
                            menu.setAttribute('sanitizeInputs', newValue);
                        }
                        if (this.items) {
                            this.items.forEach(function(it) {
                                it.sanitizeInputs = newValue;
                            });
                        }

                        this.setAttribute('sanitizeInputs', newValue);
                        this._sanitizeInputs = newValue;
                    }
                },
                /**
                 * Number of elements before showing a scrollbar.
                 * @type {Integer}
                 */
                size: {
                    default: 10,
                    type: Number,
                    change: function(newValue) {
                        var menu = this._menu || this.dropdownElement.querySelector('ha-menu'),
                            isMenuRendered = !!menu.render;
                        if (isMenuRendered) {
                            menu.size = newValue;
                        } else {
                            menu.setAttribute('size', newValue);
                        }
                    }
                },
                /**
                 * Selected item index.
                 * @type {Integer}
                 */
                selectedIndex: {
                    default: -1,
                    type: Number,
                    change: function(newValue, oldValue) {
                        if (newValue !== oldValue) {
                            var menu = this._menu || this.dropdownElement.querySelector('ha-menu');

                            if (newValue === -1) {
                                menu.selectedIndex = -1;
                                this.value = '';
                            } else if (this.items && newValue > -1 && newValue < this.items.length && newValue !== oldValue) {
                                if (this.addNew && this.items.length !== menu.items.length) {
                                    menu.selectedIndex = this.selectedIndex + 1;
                                } else {
                                    menu.selectedIndex = this.selectedIndex;
                                }
                                if (menu.selectedItem) {
                                    this.value = menu.selectedItem.value;
                                }
                            } else {
                                this.selectedIndex = -1;
                            }
                        }
                    }
                },
                /**
                 * Name of the component.
                 * @type {String}
                 */
                name: {
                    default: '',
                    type: String
                },

                /**
                 * Add New capability.
                 * @type {Boolean}
                 */
                addNew: {
                    default: false,
                    type: Boolean
                },

                /**
                 * Add New Text.
                 * @type {String}
                 */
                addNewText: {
                    default: 'Add New',
                    type: String
                },

                /**
                 * Value of the selected item.
                 * @type {String}
                 */
                value: {
                    default: '',
                    type: String,
                    change: function(newValue, oldValue) {
                        var menu = this._menu || this.dropdownElement.querySelector('ha-menu'),
                            isMenuRendered = !!menu.render,
                            label = this.querySelector('span.label'),
                            selectedItem, selectedIndex,
                            triggerElement;

                        if (!newValue) {
                            if (deviceUtils.isDesktop()) {
                                label.textContent = this.placeholder;
                            } else {
                                label.textContent = '';
                            }

                            this.value = '';
                            this.classList.remove('element-selected');
                            // if we don't have a value, make sure we reset the aria-label to the default
                            setDefaultAriaLabel(this);

                            return;
                        }

                        if (newValue !== oldValue) {
                            if (!isMenuRendered) {
                                return;
                            }
                            // If the value is the same as the already selected on the menu
                            // we avoid searching the item on the list
                            if (menu.selectedItem && menu.selectedItem.value === newValue) {
                                // As the menu considers the add new button as an item and the
                                // select doesn't we have to take it into account when setting
                                // the selectedIndex prop.
                                if (this.addNew && this.items.length !== menu.items.length) {
                                    selectedIndex = menu.selectedIndex - 1;
                                } else {
                                    selectedIndex = menu.selectedIndex;
                                }

                                selectedItem = this.items[selectedIndex];
                            } else {
                                // we match the value to the list of ha-items and use the ha-item to render the selected item
                                this.items.forEach(function(item, i) {
                                    // we use getAttribute just in case the item is not upgraded yet
                                    if (item.value === newValue || item.getAttribute('value') === newValue) {
                                        selectedIndex = i;
                                        selectedItem = item;
                                    }
                                }, this);
                            }

                            if (selectedItem) {
                                this.selectedIndex = selectedIndex;
                                selectedItemRenderer(label, selectedItem, this.selectedItemRenderer);

                                // since we have a selection remove the aria-label in the button so that the screen reader reads the selectedItem label instead
                                triggerElement = this.querySelector('button.action-button');
                                if (triggerElement) {
                                    triggerElement.removeAttribute('aria-label');
                                }
                            } else {
                                // If we fail to find the value on the list, we keep the old value
                                label.textContent = this.placeholder;
                                this.selectedIndex = -1;
                                this.value = '';
                                this.classList.remove('element-selected');
                                // if we don't have a value, make sure we reset the aria-label to the default
                                setDefaultAriaLabel(this);
                            }
                        }
                    }
                },

                /**
                 * Disabled indicates if the menu button is disabled.
                 * @type {Boolean}
                 */
                disabled: {
                    default: false,
                    type: Boolean,
                    change: function(newValue) {
                        this.querySelector('button.action-button').disabled = newValue;

                        if (newValue) {
                            this.classList.add('disabled');
                        } else {
                            this.classList.remove('disabled');
                        }
                    }
                },

                /**
                 * This is the text for the button.
                 * @type {String}
                 */
                placeholder: {
                    default: '',
                    change: function(newValue, oldValue) {
                        var button = this.querySelector('button.action-button');

                        if (newValue !== oldValue) {
                            // only set the pseudo placeholder if there is no value
                            if (!this.value) {
                                if (deviceUtils.isDesktop()) {
                                    this.querySelector('span.label').innerHTML = newValue;
                                } else {
                                    this.querySelector('span.label').innerHTML = '';
                                    if (this.dropdownElement) {
                                        this.dropdownElement.subtitle = newValue;
                                    }
                                }
                            }

                            if (!this.label) {
                                if (this.placeholder) {
                                    button.setAttribute('aria-label', newValue);
                                } else {
                                    button.removeAttribute('aria-label');
                                }
                            }
                        }
                    }
                },

                /**
                 * The name of a Harmony icon to display within the component
                 * @type {string}
                 */
                icon: {
                    default: '',
                    type: String,
                    change: icon.onChangeIconProperty
                },

                /**
                 * noRequiredIndicator indicates whether '*' should be
                 * appended to the label when the field is required
                 * @type {Boolean}
                 */
                noRequiredIndicator: {
                    default: false,
                    type: Boolean,
                    change: function(newValue, oldValue) {
                        if (newValue !== oldValue) {
                            handleRequiredIndicator(this);
                        }
                    }
                },

                required: {
                    default: false,
                    type: Boolean,
                    change: function(newValue, oldValue) {
                        if (!this._validateIgnoreEvent) {
                            this._validateIgnoreEvent = function() {
                                this.validate();
                            }.bind(this);
                        }
                        if (newValue !== oldValue) {
                            handleRequiredIndicator(this);

                            /* istanbul ignore next */
                            if (newValue !== oldValue) {
                                if (newValue) {
                                    if (this.addNewPopover) {
                                        eventUtil.on(this.addNewPopover, 'close', this._validateIgnoreEvent);
                                    }
                                    eventUtil.on(this._menuPopover, 'close', this._validateIgnoreEvent);
                                } else {
                                    if (this.addNewPopover) {
                                        eventUtil.off(this.addNewPopover, 'close', this._validateIgnoreEvent);
                                    }
                                    eventUtil.off(this._menuPopover, 'close', this._validateIgnoreEvent);
                                }
                            }

                            this.handleTooltipBinding(newValue);
                            this.querySelector('button.action-button').setAttribute('aria-required', newValue);
                        }
                    }
                },

                /**
                 * Flag indicating that focus should be restored after an item is selected.
                 * Defaults to false
                 *
                 * @type {Boolean}
                 */
                noFocusBackOnSelect: {
                    default: false,
                    type: Boolean
                },

                /**
                 * The aria-label for the select button if no placeholder is provided
                 */
                selectButtonAriaLabel: {
                    default: 'View Choices',
                    type: String,
                    change: function(newValue) {
                        var triggerElement = this.querySelector('button.action-button');
                        if (triggerElement) {
                            triggerElement.setAttribute('aria-label', this.placeholder || newValue);
                        }
                    }
                },

                /**
                 * Property to ease with Automation Effort. When set with a value, the value
                 * would get as attribute for ha-popover as well.
                 * @type {String}
                 */
                automationId: {
                    default: '',
                    type: String,
                    change: function(newValue, oldValue) {
                        if (newValue !== oldValue) {
                            if (deviceUtils.isDesktop) {
                                var menuPopover = this.querySelector('ha-select ha-popover.popover-menu-items');
                                if (menuPopover && newValue) {
                                    menuPopover.setAttribute('automationId', newValue + '_popover');
                                } else if (menuPopover && !newValue) {
                                    menuPopover.removeAttribute('automationId');
                                }
                            }
                            if (deviceUtils.isHandheld) {
                                var adpativeModalMenu = this.querySelector('ha-select ha-modal');
                                if (adpativeModalMenu && newValue) {
                                    adpativeModalMenu.setAttribute('automationId', newValue + '_modal');
                                } else if (adpativeModalMenu && !newValue) {
                                    adpativeModalMenu.removeAttribute('automationId');
                                }
                            }
                        }
                    }
                }
            });
        },

        /**
         * The id used for the local button id which also matches the targetSelector of the popover
         * @private
         * return {String} id
         */
        _getTargetSelectorId: function() {
            return this.localName + '-target-' + this.componentId;
        },

        postRender: function _() {
            _.super(this);

            var triggerElement = this.querySelector('button.action-button'),
                label,
                haLabel = this.querySelector('ha-label'),
                labelElement,
                menuPopover,
                arrowUp, arrowDown,
                handheld = deviceUtils.isHandheld(),
                menu,
                popoverForm = this.querySelector('ha-popover-form'),
                targetSelectorId = this._getTargetSelectorId(),
                labelAttributeValue,
                triggerClickHandler = function(evt) {
                    if (this.disabled) {
                        return;
                    }

                    // should not emit click events
                    evt.stopPropagation();

                    this.classList.add('mobile-focused');

                    // FF and Safari looses focus on the triggerElement when clicked
                    // use workaround below to focus again
                    triggerElement.focus();

                    if (this.addNewPopover && this.addNewPopover.open) {
                        utils.hidePopoverOrModal(this.addNewPopover, popup);
                    } else if (utils.isOpen(menuPopover)) {
                        _hidePopoverMenu(menuPopover, triggerElement);
                    } else {
                        if (this.addNew) {
                            AddNewHelper.addMenuItem(this);
                        }
                        _showPopoverMenu(menuPopover, triggerElement);
                        openedByKeyboard = false;
                        this.emit('click');
                    }

                    setTimeout(function() {
                        this.classList.remove('mobile-focused');
                    }.bind(this), 500);
                }.bind(this);

            if (!triggerElement) {
                // create trigger button
                triggerElement = this.ownerDocument.createElement('button');
                triggerElement.type = 'button';
                triggerElement.className = 'action-button no-connector ha-input';
                triggerElement.id = targetSelectorId;
                triggerElement.setAttribute('aria-expanded', 'false');
                triggerElement.setAttribute('aria-haspopup', 'true');
                triggerElement.setAttribute('aria-label', this.placeholder || this.selectButtonAriaLabel);

                label = this.ownerDocument.createElement('span');
                label.classList.add('label');
                triggerElement.appendChild(label);

                // create arrow up and down caret
                if (!handheld) {
                    arrowUp = this.ownerDocument.createElement('span');
                    arrowUp.classList.add('caret');
                    arrowUp.setAttribute('aria-hidden', 'true');
                    triggerElement.appendChild(arrowUp);
                }

                arrowDown = this.ownerDocument.createElement('span');
                arrowDown.setAttribute('aria-hidden', 'true');
                if (deviceUtils.isDesktop()) {
                    arrowDown.classList.add('caret');
                } else {
                    arrowDown.classList.add('hi');
                    arrowDown.classList.add('hi-chevron-down');
                }
                triggerElement.appendChild(arrowDown);

                this.appendChild(triggerElement);

                // create menu
                menu = this.ownerDocument.createElement('ha-menu');
                menu.setAttribute('role', 'listbox');

                // create popover and append menu
                menuPopover = this.ownerDocument.createElement(handheld ? 'ha-modal' : 'ha-popover');
                menuPopover.targetSelector = '#' + targetSelectorId;
                menuPopover.classList.add('popover-menu-items');
                menuPopover.section = menu;

                if (handheld) {
                    menuPopover.dismissible = true;
                }

                this.appendChild(menuPopover);
            }

            this._menuPopover = menuPopover = menuPopover ||
                this.querySelector((handheld ? 'ha-modal' : 'ha-popover') + '.popover-menu-items');

            if (handheld) {
                menuPopover.classList.add('mobile-menu');
                menuPopover.size = 'fullscreen';
                if (deviceUtils.getOSName() === 'iOS') {
                    menuPopover._lockBody = true;
                }
            }
            this._menu = menu;

            this.items = Array.prototype.slice.call(this.querySelectorAll('ha-item'));

            labelAttributeValue = this.getAttribute('label');
            if (!haLabel) {
                if (labelAttributeValue) {
                    // lets sync the attribute "label" to the component "label" property which then sets to the local input
                    this.label = labelAttributeValue;
                }
            } else if (haLabel) {
                if (handheld) {
                    this.label = haLabel.textContent;
                } else {
                    this.label = Array.prototype.slice.call(haLabel.childNodes);
                }
            }
            if (handheld) {
                menuPopover.titleText = this.label;
                menuPopover.subtitle = this.placeholder;
            }

            this.listenTo(triggerElement, 'click', triggerClickHandler);
            if (deviceUtils.isHandheld() && (labelElement = _findImmediateChildNode('LABEL', this))) {
                this.listenTo(labelElement, 'click', triggerClickHandler);
            }

            this.listenTo(triggerElement, 'keydown', function(evt) {
                var newFocus;

                switch (evt.keyCode) {
                    case keys.TAB:
                    case keys.ESCAPE:
                        if (menuPopover.open) {
                            utils.stopEvent(evt);
                            _hidePopoverMenu(menuPopover, triggerElement);
                            triggerElement.focus();
                        }
                        break;
                    case keys.SPACEBAR:
                    case keys.ENTER:
                        utils.stopEvent(evt);
                        if (!menuPopover.open) {
                            if (this.addNew) {
                                AddNewHelper.addMenuItem(this);
                            }
                            openedByKeyboard = true;
                            _showPopoverMenu(menuPopover, triggerElement);
                        }
                        break;
                    case keys.DOWN:
                        utils.stopEvent(evt);
                        if (menuPopover.open) {
                            // if popover is already open and position is bottom
                            if (menuPopover.classList.contains('position-bottom')) {
                                newFocus = (menu.items && menu.items.length > 0) ? menu.items[0] : menu;
                                newFocus.focus();
                            }
                        } else {
                            // open popover if not yet opened and add Add New menu item
                            if (this.addNew) {
                                AddNewHelper.addMenuItem(this);
                            }
                            openedByKeyboard = true;
                            _showPopoverMenu(menuPopover, triggerElement);
                        }
                        break;
                    case keys.UP:
                        utils.stopEvent(evt);
                        if (menuPopover.open) {
                            // if popover is already open and position is top
                            if (menuPopover.classList.contains('position-top')) {
                                newFocus = (menu.items && menu.items.length > 0) ? menu.items[menu.items.length - 1] : menu;
                                newFocus.focus();
                            }
                        } else {
                            // open popover if not yet opened and add Add New menu item
                            if (this.addNew) {
                                AddNewHelper.addMenuItem(this);
                            }
                            openedByKeyboard = true;
                            _showPopoverMenu(menuPopover, triggerElement);
                        }
                        break;
                }
            }.bind(this), true);

            // Fix for FF triggering click when pressing spacebar
            this.listenTo(triggerElement, 'keyup', function(evt) {
                /* istanbul ignore if */
                if (evt.keyCode === keys.SPACEBAR) {
                    evt.preventDefault();
                }
            }, true);

            // on initial render in templating engines the nested components are still rendering and setting defaults
            // then the popover add items targetSelector is still '_previousSibling'
            // use the attachedCallback to set it again
            if (this._addNewPopover) {
                this._addNewPopover.targetSelector = '#' + this.querySelector('button.action-button').id;
            }

            if (popoverForm && popoverForm.parentNode) {
                this.addNewPopover = popoverForm.parentNode;
            }

            if (!menuPopover) {
                if (this.addNewPopover) {
                    Array.prototype.forEach.call(this.querySelectorAll('ha-popover'), function(popover) {
                        if (popover !== this.addNewPopover && popover.querySelector('ha-menu')) {
                            menuPopover = this._menuPopover = popover;
                        }
                    }.bind(this));
                } else {
                    menuPopover = this._menuPopover = this.querySelector('ha-popover');
                }
            }

            menu = menuPopover.querySelector('ha-menu');

            // menu items should not emit click events
            this.listenTo(menu, 'click', function(evt) {
                if (evt.target.localName === 'ha-menu-item') {
                    evt.stopPropagation();
                }
            }.bind(this));
            /**
             * Handle changes of selected elements on menu
             * @emits HASelect#change
             */
            this.listenTo(menu, 'select', function(evt) {
                if (evt.target !== menu) {
                    return;
                }
                evt.stopPropagation();
                var triggerElement = this.querySelector('button.action-button');

                /* If the first item 'addNew' and the add new property is true and
                 the addNewPopover is set the, show the last */
                if (this.addNew && this.addNewPopover && menu.selectedItem.classList.contains('add-new-menu-item')) {
                    this.addNewPopover._closeOnBlur = true;
                    menu.selectedIndex = -1;
                    AddNewHelper.showPopoverForm(this, this.addNewPopover);
                    this.emit('add-new');
                } else {
                    this.selectedIndex = (this.addNew && this.items.length !== menu.items.length) ?
                    evt.target.selectedIndex - 1 : evt.target.selectedIndex;
                    //this.value = selectedElem.value;
                    this.classList.add('element-selected');
                    this.dropdownElement.classList.add('element-was-selected');
                    // focus on the triggerElement when the event came from keyboard or click
                    // this prevents focusing when we set the this.value which also fires a select event
                    if ((evt.detail && evt.detail.selectedByClickOrKeyboard) && !this.noFocusBackOnSelect) {
                        this._focusOnNextClose = true;
                    } else {
                        triggerElement.classList.remove('active');
                    }

                    this.emit('change');
                }
                _hidePopoverMenu(menuPopover, triggerElement);
            }.bind(this));

            eventUtil.on(menuPopover, 'show', function(evt) {

                // HUI-4234: let HASelect consumers know popover's shown
                this.emit('items-show');
                evt.stopPropagation();

                // focus the actual menu item if opened via keyboard and there is a default selection
                if (openedByKeyboard && menu.selectedItem) {
                    menu.selectedItem.focus();
                }
            }.bind(this));

            eventUtil.on(menuPopover, 'close', function(evt) {

                // HUI-4234: let HASelect consumers know popover's closed
                this.emit('items-close');
                evt.stopPropagation();
                if (this._focusOnNextClose) {
                    triggerElement.focus();
                    this._focusOnNextClose = false;
                }
                if (this.addNew) {
                    // remove Add New menu item
                    menu.remove(0);
                }
                triggerElement.classList.remove('active');
            }.bind(this));

            // backward-compatibility popover hide event, stop bubbling
            eventUtil.on(menuPopover, 'hide', function(evt) {
                evt.stopPropagation();
            }.bind(this));

            eventUtil.on(menuPopover, 'blur', _blurEventHandler.bind(this, triggerElement), true);
            this.listenTo(triggerElement, 'blur', _blurEventHandler.bind(this, triggerElement), true);

            /**
             * Handle key presses
             * @emits HASelect#add-new
             */
            eventUtil.on(menuPopover, 'keydown', function(evt) {
                if (this.disabled) {
                    return;
                }

                var target = evt.target;

                switch (evt.keyCode){
                    case keys.TAB:
                    case keys.ESCAPE:
                        if ((deviceUtils.isDesktop() || evt.keyCode === keys.ESCAPE) && menuPopover.open) {
                            utils.stopEvent(evt);
                            _hidePopoverMenu(menuPopover, triggerElement);
                            // focuses back to the triggerElement so that pressing SPACE opens the popover again
                            triggerElement.focus();
                        }
                        break;
                    case keys.ENTER:
                    case keys.SPACEBAR:
                        if (target.tagName === 'HA-MENU') {
                            utils.stopEvent(evt);
                            openedByKeyboard = true;
                            if (this.addNew) {
                                AddNewHelper.showPopoverForm(this, this.addNewPopover);
                            }
                        }
                        break;
                }
            }.bind(this));
        },

        attachedCallback: function() {
            this._bindHandle = domObserver.bindChildrenChanges(this, 'ha-item', this, 'items');
        },

        detachedCallback: function() {
            // popovers exist outside of the DOM of the component,
            // so we must remove them manually
            [this._addNewPopover, this._menuPopover].forEach(function(popover) {
                if (popover && popover.parentElement) {
                    popover.parentElement.removeChild(popover);
                }
            });

            if (this._bindHandle) {
                this._bindHandle.remove();
                this._bindHandle = null;
            }
        },

        set label(newValue) {
            var _findImmediateChildNode = function(childNodeName, select) {
                    var childNodes = Array.prototype.slice.call(select.childNodes);
                    for (var child in childNodes) {
                        if (childNodes[child].nodeName === childNodeName) {
                            return childNodes[child];
                        }
                    }
                    return null;
                },
                button = this.querySelector('.action-button'),
                label = _findImmediateChildNode('LABEL', this),
                haLabel = this.querySelector('ha-label'),
                isNode,
                labelId;

            if (newValue) {
                isNode = Array.isArray(newValue) || newValue.nodeType === 1;
                if (typeof newValue === 'string') {
                    // if ha-label left from element value, remove <ha-label>
                    if (haLabel) {
                        this.removeChild(haLabel);
                        // recheck label existance because it may have been removed with ha-label
                        label = _findImmediateChildNode('LABEL', this);
                    }

                    // if no label element create it and add it to text-field
                    if (!label) {
                        label = this.ownerDocument.createElement('label');
                        this.insertBefore(label, button);
                    }

                    // toggle * if needed, and add label text to label element
                    handleRequiredIndicator(this, newValue, label);

                    // sync label attribute
                    this.setAttribute('label', newValue);
                } else if (isNode) {
                    // remove label attribute first
                    if (this.hasAttribute('label')) {
                        this.removeAttribute('label');
                    }

                    label = _findImmediateChildNode('LABEL', this);
                    // if label left inside <ha-label> remove <ha-label>, else remove <label>
                    if (label && !haLabel) {
                        this.removeChild(label);
                    } else if (haLabel) {
                        this.removeChild(haLabel);
                    }

                    label = this.ownerDocument.createElement('label');
                    haLabel = this.ownerDocument.createElement('ha-label');
                    newValue = Array.isArray(newValue) ? newValue : [newValue];

                    newValue.forEach(function(node) {
                        label.appendChild(node);
                    });

                    haLabel.appendChild(label);
                    this.insertBefore(haLabel, this.firstElementChild);

                    // toggle * if needed
                    handleRequiredIndicator(this);
                }

                labelId = this.localName + '-label-' + this.componentId;
                label.setAttribute('id', labelId);
                button.setAttribute('aria-describedby', labelId);

                // make sure we don't have aria-label since we have label
                if (button.hasAttribute('aria-label')) {
                    button.removeAttribute('aria-label');
                }
            } else {
                // remove label attribute
                if (this.hasAttribute('label')) {
                    this.removeAttribute('label');
                }

                // if falsy empty string, null or undefined
                button.removeAttribute('aria-describedby');

                label = _findImmediateChildNode('LABEL', this);
                haLabel = this.querySelector('ha-label');
                // remove <ha-label> if it exists
                if (haLabel) {
                    this.removeChild(haLabel);
                } else if (label) {  // otherwise just remove <label>
                    this.removeChild(label);
                }

                // if we don't have a label and we have a placeholder, set aria-label
                if (this.placeholder) {
                    button.setAttribute('aria-label', this.placeholder);
                } else {
                    button.removeAttribute('aria-label');
                }
            }

            this._label = newValue;
        },

        get label() {
            return this._label;
        },

        /**
         * Gets the selected item from the menu
         */
        get selectedItem() {
            return Array.isArray(this.items) && this.selectedIndex > -1 ? this.items[this.selectedIndex] : null;
        },

        /**
         * Dummy method to avoid problems with getter without setters
         */
        set selectedItem(newValue) {
            // jshint unused:false
        },

        /**
         * Gets the ha-popover that will host the ha-menu with the list of items
         */
        get items() {
            return this._items;
        },

        /**
         * Sets the element that is contained inside the ha-popover
         * @param {Array} items List of items to store
         */
        set items(items) {
            var menuElement = this.dropdownElement.querySelector('ha-menu'),
                menuItemsElement;

            if (this._bindHandle) {
                this._bindHandle.pause();
            }

            removeItemElements(this);
            removeMenuItemElements(menuElement);

            items = Array.isArray(items) ? items : [items];
            menuItemsElement = items.map(function(item) {
                // cascasde whether or not to sanitize inputs down to the children
                item.sanitizeInputs = this._sanitizeInputs;
                // insert ha-item into the DOM
                this.insertBefore(item, this._getFirstNonItemChild());
                // create ha-menu-item and pass renderers if needed
                return menuItemUtils.createMenuItem(item, {role: 'option'}, this.itemRenderer, this.ownerDocument);
            }, this);

            // since we have processed the ha-items to ha-menu-items, we add them one time to ha-menu
            addMenuItemElements(menuElement, menuItemsElement);

            // if menu items just updated by sanitizing, keep the selectedIndex.
            if (!isSanitizeUpdate(items, this._items)) {
                this.selectedIndex = -1;
            }
            this._items = items;

            if (this._bindHandle) {
                this._bindHandle.resume();
            }
        },

        /**
         * Gets the ha-popover element that will host the ha-popover-form for adding a new item
         */
        get addNewPopover() {
            return this._addNewPopover;
        },

        /**
         * Sets the ha-popover element that will host the ha-popover-form for adding a new item
         * @param  {HTMLElement} newPopover Popover to store
         */
        set addNewPopover(newPopover) {
            var targetSelectorId;

            if (this.addNewPopover && this.addNewPopover !== newPopover) {
                this.removeChild(this.addNewPopover);
            }

            this._addNewPopover = newPopover;

            if (newPopover) {
                targetSelectorId = this.querySelector('button.action-button').id;

                // make sure we add the targetSelector via id or attribute
                if (newPopover.targetSelector) {
                    newPopover.targetSelector = '#' + targetSelectorId;
                } else {
                    newPopover.setAttribute('targetSelector', '#' + targetSelectorId);
                }

                newPopover.classList.add('popover-add-items');
                newPopover.setAttribute('automationId', 'addNewItem_popover');
                if (newPopover.parentElement !== this) {
                    this.appendChild(newPopover);
                }

                var popoverForm = newPopover.querySelector('ha-popover-form');
                if (popoverForm) {
                    /**
                     * Handle save add item button
                     * @emits HASelect#add-new
                     */
                    eventUtil.on(popoverForm, 'save', function(evt) {
                        utils.stopEvent(evt);
                        _setNewElementAsSelected(this);
                        this.emit('add-new');
                    }.bind(this));

                    /* Handle cancel add item button */
                    eventUtil.on(popoverForm, 'cancel', function(evt) {
                        utils.stopEvent(evt);
                        _hidePopover(this.addNewPopover);
                    }.bind(this));
                }
            }
        },

        get dropdownElement() {
            if (!this._menuPopover) {
                this._menuPopover = this.querySelector((deviceUtils.isHandheld() ? 'ha-modal' : 'ha-popover') + '.popover-menu-items');
            }
            return this._menuPopover;
        },

        set dropdownElement(dropdownElement) {
            this._menuPopover = dropdownElement;
        },

        attributeChangedCallback: function _(attrName, oldValue, newValue) {
            // happens when we modify the attribute via browser inspector or via setAttribute
            if (attrName === 'label') {
                // call the label setter which handles the logic
                this.label = newValue;
            } else {
                _.super(this, attrName, oldValue, newValue);
            }
        },

        /**
         * Gets the ha-popover element that will contain the list of selectable items
         */
        _getMenuPopover: function() {
            console.info('_getMenuPopover should be deprecated in favor of .dropdownElement');
            return this.dropdownElement;
        },

        /**
         * Runs the necessary validations over the component
         * @param  {Event} evt  The event that triggered this handler
         */
        validate: function(evt) {
            return this.reportValidity(evt);
        },

        /**
         * Validates the component. If the event is a blur event we need to
         * execute asynchronously to verify that focus hasn't shifted to the
         * dropdown menu.
         *
         * @param {Event} evt - Optional event parameter
         * @returns {*|{value}}
         */
        reportValidity: function _(evt) {
            // this block for not doing reportValidity when focus jump to menuPopover, so need check menuPopover open state
            if (evt && evt.type === 'blur' && this._menuPopover.open) {
                setTimeout(function() {
                    if (!this._menuPopover ||
                        !(this._menuPopover.contains(document.activeElement) || this.contains(document.activeElement))) {
                        _.super(this, evt);
                    }
                }.bind(this), 0);
            }  else {
                if (deviceUtils.isDesktop() || !evt || (evt.type !== 'blur' && evt.type !== 'hide')) {
                    return _.super(this, evt);
                }
            }
        },

        /**
         * Reset validation for the component. If the popover opens, need close it first and reset validation.
         */
        resetValidation: function _() {
            // need to make sure close the popover first then rest validation
            // since after validation listening to popover close
            if (this.dropdownElement.open) {
                this.dropdownElement.close(true);
            }
            _.super(this);
        },

        _getFirstNonItemChild: function() {
            return Array.prototype.slice.call(this.children).filter(function(element) {
                return element.tagName !== 'HA-ITEM';
            })[0];
        }
    });
    return register('ha-select', HASelect);
});

define('hui/single-step',[
        'object-utils/classes',
        'register-component/v2/UIComponent',
        'register-component/v2/register',
        './core/popup',
        './core/tooltip',
        './core/utils',
        './core/a11y'
    ],
    function(classes, UIComponent, register, popup, coreTooltip, utils, a11y) {
        'use strict';
        var HaSingleStep,
            /**
             * Static var to track the current target of the single step.
             * @type {HTMLElement}
             */
            TARGET = null;

        /**
         * Emits dismiss and hides the component
         * @param  {Event} evt Click event
         * @emits dismiss
         */
        function dismissibleSingleStepClick(evt) {
            var component = evt.target;
            while (component.tagName !== 'HA-SINGLE-STEP') {
                component = component.parentElement;
            }
            component.emit('dismiss');
            component.close();
        }

        /**
         * Sets a delay to hide the popup
         */
        function hideAfterTimeout(evt) {
            var singleStep = evt.target;
            setTimeout(singleStep._hideCallback, singleStep.duration);
        }

        /**
         * Sets title text on single step
         * @param {HTMLElement} singleStep Component to set the title text to
         * @param {HTMLElement} target  Component that can have another title text
         */
        function setTitleText(singleStep, target) {
            var singleStepTitleText = false,
                childrenLength,
                i,
                txt,
                content = singleStep.querySelector('.single-step-title');

            //Single step title text can also be defined as an attribute of the target. If the target
            //defines a "singleStepTitleText" attribute, we take that as the title text for the single step
            if (target) {
                singleStepTitleText = target.singleStepTitleText || target.getAttribute('singleStepTitleText');
            }

            //if target does not define a title text, we take the one defined in the single step itself
            txt = singleStepTitleText ? singleStepTitleText : singleStep.titleText;

            if (txt) {
                if ('string' === typeof txt) {
                    txt = [singleStep.ownerDocument.createTextNode(txt)];
                }

                childrenLength = content.childNodes.length;

                for (i = 0; i < childrenLength; i++) {
                    content.removeChild(content.childNodes[0]);
                }

                content.innerHTML = '';
                utils.appendChildCollection(content, txt);
            }
        }

        /**
         * Sets message on single step
         * @param {HTMLElement} singleStep Component to set the message to
         * @param {HTMLElement} target  Component that can have another message
         */
        function setMessage(singleStep, target) {
            var singleStepMessage = false,
                childrenLength,
                i,
                msg,
                content = singleStep.querySelector('.single-step-inner');

            //Single step message can also be defined as an attribute of the target. If the target
            //defines a "singleStepMessage" attribute, we take that as the message for the single step
            if (target) {
                singleStepMessage = target.singleStepMessage || target.getAttribute('singleStepMessage');
            }

            //if target does not define a message, we take the one defined in the single step itself
            msg = singleStepMessage ? singleStepMessage : singleStep.message;

            if (msg) {
                if ('string' === typeof msg) {
                    msg = [singleStep.ownerDocument.createTextNode(msg)];
                }

                childrenLength = content.childNodes.length;

                for (i = 0; i < childrenLength; i++) {
                    content.removeChild(content.childNodes[0]);
                }

                content.innerHTML = '';
                utils.appendChildCollection(content, msg);
            }
        }

        HaSingleStep = classes.createObject(UIComponent, {

            init: function _() {
                _.super(this);

                /**
                 * Cached listeners of the defined event to show or hide the single step
                 */
                this._listenersTargets = [];

                /**
                 * Title text that will be shown.
                 * @type {String}
                 */
                this._titleText = '';

                /**
                 * Message that will be shown.
                 * @type {String|HTMLElement}
                 */
                this._message = '';

                // I need to store this callbacks in case the consumer changes the triggers
                this._hideCallback = this.close.bind(this);
                this._showCallback = this.show.bind(this);

                this._attached = false;

                this._open = true;

                this.setupProperties({

                    /**
                     * String describing the alignment of the single step.
                     * More than one alignment can be added and will be used as order of preference*
                     * Values can be:
                     *  - left
                     *  - right
                     * @default 'left'
                     * @type {String}
                     * @private
                     */
                    _alignment: {
                        default: 'left'
                    },

                    /**
                     * Determines if the single step is shown on initial page render
                     * @type {Boolean}
                     */
                    open: {
                        default: true,
                        type: Boolean,
                        change: function(newValue) {
                            if (newValue !== this._open) {
                                this._open = newValue;
                                if (this._open) {
                                    this.show();
                                } else {
                                    this.close();
                                }
                            }
                        }
                    },

                    /**
                     * Selector describing which is / are the parents of the single step.
                     * @type {String}
                     */
                    targetSelector: {
                        default: '_previousSibling',
                        change: function(newValue) {
                            coreTooltip.removeOldListeners(this);
                            coreTooltip.setTooltipTargets(this, newValue);
                            coreTooltip.resetListeners(this, this.trigger);
                        }
                    },

                    /**
                     * String describing the position of the single step.
                     * More than one position can be added and will be used as order of preference
                     * Values can be:
                     *  - top
                     *  - bottom
                     * @default 'top bottom'
                     * @type {String}
                     */
                    position: {
                        default: 'top'
                    },

                    /**
                     * If the single step is dismissible by the user.
                     * A close button will be shown if this is true.
                     * @type {Boolean}
                     */
                    dismissible: {
                        type: Boolean,
                        default: false,
                        change: function(newValue) {
                            if (newValue) {
                                this.classList.add('dismissible');
                                this.on('button:click', dismissibleSingleStepClick);
                            } else {
                                this.classList.remove('dismissible');
                                this.off('button:click', dismissibleSingleStepClick);
                            }
                            coreTooltip.resetTooltipDismissal(this);
                        }
                    },

                    /**
                     * Event that will be attached to the parent / parents that will trigger
                     * the show of the single step.
                     * @type {String}
                     */
                    trigger: {
                        default: 'hover',
                        change: function(newValue) {
                            coreTooltip.resetListeners(this, newValue);
                        }
                    },

                    /**
                     * Sets the timeout (ms) to close the single step.
                     * A zero value means disabled.
                     * @type {Number}
                     */
                    duration: {
                        default: 0,
                        change: function(newValue) {
                            if (newValue > 0) {
                                this.on('show', hideAfterTimeout);
                            } else {
                                this.off('show', hideAfterTimeout);
                            }
                            coreTooltip.resetTooltipDismissal(this);
                        }
                    },

                    attributeChangedCallback: function _(attrName, oldValue, newValue) {
                        // happens when we modify the attribute via browser inspector or via setAttribute
                        if (attrName === 'open') {
                            // call the value setter which handles the logic
                            this.open = newValue;
                        } else {
                            _.super(this, attrName, oldValue, newValue);
                        }
                    }
                });
            },

            /**
             * Bind the click event to the close button.
             * @emits HASingleStep#show
             * @emits HASingleStep#close
             */
            createdCallback: function _() {
                var animationEvts;
                _.super(this);

                animationEvts = utils.getAnimationEventNames();
                this.on(animationEvts.animationend, function(evt) {
                    var target = evt.target;
                    switch (evt.animationName) {
                        case 'ha-fade-in':
                            target.classList.remove('enter');
                            target.emit('show');
                            break;
                        case 'ha-fade-out':
                            target.classList.remove('leave');
                            target.classList.remove('visible');
                            target.emit('close');
                            popup.clearPosition(target);
                            break;
                    }
                });
            },

            /**
             * Sets single step initial configs and resets event listeners.
             */
            attachedCallback: function() {
                if (!this._attached) {
                    this._attached = true;
                    coreTooltip.setTooltipTargets(this, this.targetSelector);
                    coreTooltip.resetListeners(this, this.trigger);
                    setTitleText(this, this._listenersTargets[0]);
                    setMessage(this, this._listenersTargets[0]);

                    if (this._open) {
                        this.show();
                    }
                }
            },

            /**
             * Retrieves the targets.
             * Binds some event on them.
             * Makes a verification on the position config.
             */
            postRender: function _() {
                var divContainer,
                    divBar,
                    divTitle,
                    divMessage,
                    titleText,
                    message,
                    innerTitle,
                    innerContent,
                    button;

                _.super(this);
                a11y.addA11yFocus(this);

                if (this.hasAttribute('titleText')) {
                    titleText = this.getAttribute('titleText');
                } else {
                    innerTitle = this.querySelector('.single-step-title');
                    if (innerTitle) {
                        titleText = utils.removeNodesSafe(innerTitle, innerTitle.childNodes);
                    } else {
                        titleText = utils.removeNodesSafe(this, this.children);
                    }
                }

                if (this.hasAttribute('message')) {
                    message = this.getAttribute('message');
                } else {
                    innerContent = this.querySelector('.single-step-inner');
                    if (innerContent) {
                        message = utils.removeNodesSafe(innerContent, innerContent.childNodes);
                    } else {
                        message = utils.removeNodesSafe(this, this.children);
                    }
                }

                divContainer = this.querySelector('div.single-step-container');
                divBar = this.querySelector('div.single-step-bar');
                divTitle = this.querySelector('div.single-step-title');
                divMessage = this.querySelector('div.single-step-inner');
                button = this.querySelector('button.btn-container');
                // We force a minWidth to avoid popup default behaviour of setting minWidth to
                // target's width (required by every other component)
                this.style.minWidth = '1px';

                // Creates template
                if (!divContainer) {
                    divContainer = this.ownerDocument.createElement('div');
                    divContainer.className = 'single-step-container';

                    button = this.ownerDocument.createElement('button');
                    button.className = 'hi hi-close btn-icon-only';
                    divContainer.appendChild(button);

                    divBar = this.ownerDocument.createElement('div');
                    divBar.className = 'single-step-bar';
                    divContainer.appendChild(divBar);

                    divTitle = this.ownerDocument.createElement('div');
                    divTitle.className = 'single-step-title';
                    divContainer.appendChild(divTitle);

                    divMessage = this.ownerDocument.createElement('div');
                    divMessage.className = 'single-step-inner';
                    divContainer.appendChild(divMessage);

                    this.appendChild(divContainer);
                }
                this.titleText = titleText;
                this.message = message;
            },

            get titleText() {
                return this._titleText;
            },

            set titleText(newTitleText) {
                this._titleText = newTitleText;
                setTitleText(this);
            },

            get message() {
                return this._message;
            },

            set message(newMessage) {
                this._message = newMessage;
                setMessage(this);
            },

            get open() {
                return this._open;
            },

            set open(newValue) {
                if (newValue !== this._open) {
                    this._open = newValue;
                    if (this._open) {
                        this.show();
                    } else {
                        this.close();
                    }
                }
            },

            /**
             * Implements the logic to show the single step.
             * @param  {Event} evt Optional. When defined an event triggered this call
             */
            show: function(evt) {
                var MARGIN = 17,
                    isVisible = this.classList.contains('visible'),
                    target = (evt) ? evt.currentTarget : null,
                    singleSteps = [],
                    singleStep,
                    hasPositionSet,
                    location,
                    position,
                    alignment,
                    i;

                if (!target) {
                    target = this._listenersTargets[0];
                }

                // If it is visible but target is different is because
                // we are using the same instance in different targets,
                // so we want to move the single step to the next target.
                if (target) {
                    setTitleText(this, target);
                    setMessage(this, target);
                    if (!TARGET || !target.isEqualNode(TARGET)) {
                        TARGET = target;
                        singleSteps = this.ownerDocument.querySelectorAll('ha-single-step.visible');
                        for (i = 0; i < singleSteps.length; i++) {
                            singleStep = singleSteps[i];
                            singleStep.close();
                        }
                    }

                    location = this.position.split(' ');
                    position = new Array(location[0]);
                    alignment = location[1] ? new Array(location[1]) : new Array(this._alignment);

                    // If the same instance is fading out, we need to interrupt the animation and fade in. Position needs to be
                    // calculated again if that's the case
                    if (isVisible && this.classList.contains('leave')) {
                        this.classList.remove('leave');
                        popup.clearPosition(this);
                    }

                    // If position was already set (because this was called through popup) we don't need to calculate it again
                    hasPositionSet = this.className.indexOf('position-') > -1;
                    if (!hasPositionSet) {
                        if (popup.setPosition(this, target, position, alignment, MARGIN)) {
                            this._resizeMethod = popup.installResizeMethod(this, target, position, alignment, MARGIN);
                        } else {
                            return;
                        }
                    }
                    if (!isVisible) {
                        this.classList.add('visible');
                        this._open = true;
                    }
                }
            },

            /**
             * Implements the logic to hide the single step.
             */
            close: function() {
                // If we close a single step that is timed we
                // will have to ensure that the timeout stops.
                if (this._timed) {
                    clearTimeout(this._timed);
                    delete this._timed;
                }

                if (this.classList.contains('visible')) {
                    this.classList.add('leave');
                    // We need to clean this on close to ensure that
                    // all behaves as expected on a new show.
                    TARGET = null;
                    if (this._resizeMethod) {
                        popup.uninstallResizeMethod(this._resizeMethod);
                        this._resizeMethod = null;
                    }
                    this._open = false;
                }
            }
        });

        return register('ha-single-step', HaSingleStep);
    });

define('hui/combo-link',[
    'object-utils/classes',
    'register-component/v2/register',
    './menu/menu-based-buttons',
    './core/utils'
], function(classes, register, MenuBasedButtons, utils) {
    'use strict';

    var HAComboLink = classes.createObject(MenuBasedButtons, {
        init: function _() {
            _.super(this);

            this.setupProperties({

                /**
                 * Property to ease with Automation Effort. When set with a value, the value
                 * would get as attribute for ha-popover as well.
                 * @type {String}
                 */
                automationId: {
                    default: '',
                    type: String,
                    change: function(newValue, oldValue) {
                        if (newValue !== oldValue) {
                            var menuPopover = this.querySelector('ha-combo-link ha-popover');
                            if (menuPopover && newValue) {
                                menuPopover.setAttribute('automationId', newValue + '_popover');
                            } else if (menuPopover && !newValue) {
                                menuPopover.removeAttribute('automationId');
                            }
                        }
                    }
                }
            });
        },

        _renderTriggerElement: function() {
            var actionButton, label, triggerElement, buttonCaret, btnGroup;

            // create action button
            actionButton = this.ownerDocument.createElement('button');
            actionButton.type = 'button';
            actionButton.className = 'btn btn-link no-connector';
            actionButton.id = this._getTargetSelectorId();

            label = this.ownerDocument.createElement('span');
            label.className = 'label';
            actionButton.appendChild(label);

            // create trigger button
            triggerElement = this.ownerDocument.createElement('button');
            triggerElement.type = 'button';
            triggerElement.className = 'btn hi-icon-button btn-link no-connector';
            triggerElement.setAttribute('aria-expanded', 'false');
            triggerElement.setAttribute('aria-haspopup', 'true');
            triggerElement.setAttribute('aria-label', this.label + ' menu');

            buttonCaret = this.ownerDocument.createElement('span');
            buttonCaret.className = 'caret';
            triggerElement.appendChild(buttonCaret);

            // Create the btn group
            btnGroup = this.ownerDocument.createElement('div');
            btnGroup.className = 'btn-group';
            btnGroup.appendChild(actionButton);
            btnGroup.appendChild(triggerElement);

            this.appendChild(btnGroup);

            return triggerElement;
        },

        _getTriggerElement: function() {
            return this.querySelector('button.hi-icon-button');
        },

        /**
        * We re-emit click events coming from local dom so that the evt.target is the host component
        * @emits click
        */
        postRender: function _() {
            _.super(this);

            var button, label;

            button = this.querySelector('.btn-group > button');

            // guarding against falsy button (IE 11 fix)
            if (button) {
                // needed because when spacebar is pressed it goes to this code path
                this.listenTo(button, 'click', function(evt) {
                    utils.stopEvent(evt);
                    this.emit('click');
                }.bind(this));

                label = button.querySelector('span.label');
                this.listenTo(label, 'click', function(evt) {
                    utils.stopEvent(evt);

                    var popover = this.dropdownElement;
                    if (popover.open) {
                        popover.close();
                    }
                    this.emit('click');
                }.bind(this));
            }
        }
    });

    return register('ha-combo-link', HAComboLink);
});

define('hui/combo-button',[
    'object-utils/classes',
    'register-component/v2/register',
    './menu-button',
    './core/utils'
],
function(classes, register, MenuButton, utils) {
    'use strict';

    var buttonClasses = ['ha-button-default', 'ha-button-primary', 'ha-button-dark'],
        HAComboButton;

    HAComboButton = classes.createObject(MenuButton.prototype, {

        /**
         * Applies button classes to the trigger and action buttons. This method exists because combo and menu buttons
         * have different buttons but need to apply the same classes to both.
         * @private
         */
        _transferButtonClasses: function _() {
            _.super(this);
            var actionButton = this.querySelector('.combo-button-action'),
                triggerElement = this._getTriggerElement();

            if (actionButton && triggerElement) {
                buttonClasses.forEach(function(currentClass) {
                    if (triggerElement.classList.contains(currentClass)) {
                        actionButton.classList.add(currentClass);
                    }
                }, this);
            }
        },

        /**
         * Renders the trigger element. This functionality has been moved to a private method so that combo and menu
         * button can implement their own versions.
         * @returns {Element|*}
         * @private
         */
        _renderTriggerElement: function _() {
            var actionButton, label, triggerElement, buttonCaret;

            // create action button
            actionButton = this.ownerDocument.createElement('button');
            actionButton.type = 'button';
            actionButton.className = 'ha-button combo-button-action no-connector';
            actionButton.id = this._getTargetSelectorId();

            label = this.ownerDocument.createElement('span');
            label.className = 'label';
            actionButton.appendChild(label);

            this.appendChild(actionButton);

            // create trigger button
            triggerElement = this.ownerDocument.createElement('button');
            triggerElement.type = 'button';
            triggerElement.className = 'ha-button combo-button-dropdown no-connector';
            triggerElement.setAttribute('aria-expanded', 'false');
            triggerElement.setAttribute('aria-haspopup', 'true');
            triggerElement.setAttribute('aria-label', this.label + ' menu');

            buttonCaret = this.ownerDocument.createElement('span');
            buttonCaret.className = 'caret';
            triggerElement.appendChild(buttonCaret);
            this.showCaret = true;

            this.appendChild(triggerElement);

            return triggerElement;
        },

        _getTriggerElement: function _() {
            return this.querySelector('button.ha-button.combo-button-dropdown');
        },

        /**
         * Updates the component's rendering in response to a change in screen size
         * @param {Object} screenParameters
         * @param {Object} oldScreenParameters
         * @private
         * @deprecated This method is deprecated in favor of hiding/removing combo buttons on mobile.
         */
        _resize: function(screenParameters, oldScreenParameters) {
            // This is extremely unlikely to happen without refreshing the
            // browser page. This method is implemented here and in menu-button
            // mostly as an example for other components.
            if (oldScreenParameters.isDesktop !== screenParameters.isDesktop) {
                var oldButtons,
                    popover = this.querySelector('ha-modal') || this.querySelector('ha-popover');

                if (popover) {
                    popover.parentNode.removeChild(popover);
                }
                if (oldScreenParameters.isDesktop) {
                    oldButtons = [this.querySelector('button.ha-button.combo-button-dropdown'),
                        this.querySelector('button.ha-button.combo-button-action')];
                } else {
                    oldButtons = [this.querySelector('button.ha-button.no-connector')];
                }
                oldButtons.forEach(function(button) {
                    buttonClasses.forEach(function(currentClass) {
                        if (button.classList.contains(currentClass)) {
                            this.classList.add(currentClass);
                        }
                    }, this);
                    button.parentNode.removeChild(button);
                }, this);
                this._transferButtonClasses();
                this._initBoundProperties();
            }
        },

        postRender: function _() {
            _.super(this);
            // needed because when spacebar is pressed it goes to this code path
            var actionButton = this.querySelector('.combo-button-action');
            this.listenTo(actionButton, 'click', function(evt) {
                utils.stopEvent(evt);
                this.dropdownElement.close();
                this.emit('click');
            }.bind(this));
        }
    });

    return register('ha-combo-button', HAComboButton);
});

define('hui/simple-list',[
        'register-component/v2/register',
        'register-component/v2/UIComponent',
        'object-utils/classes',
        './core/keys',
        './core/utils'
    ], function(register, UIComponent, classes, keys, utils) {

        /**
         * Retrieve the consumer information from the element.
         * @type {HTMLElement}
         * @returns {Array} Array with the items of the element.
         * @private
         */
        var _getConsumerData = function(consumerData) {
                var data = [];

                if (consumerData.childElementCount >= 0) {
                    // We need to remove the nodes since IE will not find the value within the
                    // node if we don't, and that generates a bug.
                    data = utils.removeNodesSafe(consumerData, consumerData.childNodes);
                }

                return data;
            },

            /**
             * Retrieve the index element of given element from their parent element..
             * @param {HTMLElement} el
             * @returns {Number} return the index element.
             * @private
             */
            _getIndexOfElement = function(el) {
                var indexTarget = 0,
                    i = 0,
                    nodes,
                    node;
                if (el && el.parentNode) {
                    nodes = el.parentNode.childNodes;
                    while ((node = nodes.item(i++)) && node !== el) {
                        if (node.nodeType === 1) {
                            indexTarget++;
                        }
                    }
                    return indexTarget;
                }
                return -1;
            },

            LIST_ITEM_HEIGHT = 49,

            HASimpleList = classes.createObject(UIComponent, {

                init: function _() {
                    _.super(this);

                    /**
                     * The last item selected only for single selected list.
                     * by default is null.
                     * @private
                     * @type {HTMLELement}
                     *
                     */
                    this._selectedItem = null;

                    /**
                     * The list of items.
                     * @type {Array}
                     * @private
                     */
                    this._items = [];

                    this.setupProperties({

                        /**
                         * Sets the complexity type of the list: 'basic' or 'complex'. A 'basic' list consists of
                         * a text label and an optional control. A complex list consists of a text label, custom
                         * styling, and any number of custom elements providing information about the item.
                         * Notice this property don't have change handler because is not need change it dynamically.
                         * @type {String}
                         */
                        complexity: {
                            default: 'basic',
                            type: String
                        },

                        /**
                         * The current index item for single selected mode.
                         * @type {Number}
                         */
                        selectedIndex: {
                            default: -1,
                            type: Number,
                            change: function(newValue) {
                                [].forEach.call(this.querySelectorAll('li'), function(el, index) {
                                    if (index === newValue) {
                                        el.classList.add('ha-active');
                                        el.setAttribute('aria-selected', true);
                                        this._selectedItem = el;
                                    } else {
                                        el.classList.remove('ha-active');
                                        el.setAttribute('aria-selected', false);
                                    }
                                }.bind(this));
                                this.emit('select');
                            }
                        },

                        /**
                         * Amount of items to be visible at once. If smaller than length, a scrollbar is shown.
                         * If size property is bigger than 0, adjusts the height of the list.
                         * @type {Number}
                         */
                        size: {
                            type: Number,
                            change: function(newValue) {
                                var list = this.querySelector('ul');
                                if (newValue) {
                                    list.style.maxHeight = (newValue * LIST_ITEM_HEIGHT) + 'px';
                                    list.style.overflowY = 'auto';
                                } else {
                                    list.style.maxHeight = 'none';
                                    list.style.overflowY = 'hidden';
                                }
                            }
                        },

                        /**
                         * The title of the list (optional).
                         * @returns {String}
                         */
                        titleText: {
                            default: '',
                            change: function(newValue, oldValue) {
                                var title = this.querySelector('h2'),
                                    list;

                                if (oldValue !== newValue) {
                                    if (!title) {
                                        list = this.querySelector('ul');
                                        title = this.ownerDocument.createElement('h2');
                                        title.id = 'ha-list-header-' + this.componentId;
                                        title.innerHTML = newValue;
                                        this.insertBefore(title, list);
                                    } else {
                                        title.innerHTML = newValue;
                                    }
                                }
                            }
                        }
                    });

                    this.on('.list-group:keydown', function(evt) {
                        var nextTarget,
                            itemSelected = evt.target;

                        if (evt.keyCode !== keys.TAB) {
                            if (itemSelected && itemSelected.classList.contains('list-group')) {
                                itemSelected.firstChild.focus();
                                return;
                            }

                            while (itemSelected && !itemSelected.classList.contains('list-group-item')) {
                                itemSelected = itemSelected.parentNode;
                            }

                            utils.stopEvent(evt);

                            switch (evt.keyCode) {
                                case keys.UP:
                                    if (itemSelected.previousSibling) {
                                        nextTarget = itemSelected.previousSibling;
                                        nextTarget.focus();
                                        this.selectedIndex = _getIndexOfElement(nextTarget);
                                    } else {
                                        nextTarget = itemSelected.parentNode.lastChild;
                                        nextTarget.focus();
                                        this.selectedIndex = _getIndexOfElement(nextTarget);
                                    }
                                    break;
                                case keys.DOWN:
                                    if (itemSelected.nextSibling) {
                                        nextTarget = itemSelected.nextSibling;
                                        nextTarget.focus();
                                        this.selectedIndex = _getIndexOfElement(nextTarget);
                                    } else {
                                        nextTarget = itemSelected.parentNode.firstChild;
                                        nextTarget.focus();
                                        this.selectedIndex = _getIndexOfElement(nextTarget);
                                    }
                                    break;
                                case keys.ENTER:
                                case keys.SPACEBAR:
                                    this.selectedIndex = _getIndexOfElement(itemSelected);
                                    break;
                            }
                        }

                    }.bind(this));

                    this.on('.list-group-item:click', function(evt) {
                        this.emit('click');
                        utils.stopEvent(evt);
                        var itemSelected = evt.target;
                        while (itemSelected && !itemSelected.classList.contains('list-group-item')) {
                            itemSelected = itemSelected.parentNode;
                        }
                        if (!itemSelected) {
                            return;
                        }
                        this.selectedIndex = _getIndexOfElement(itemSelected);
                    }.bind(this));
                },
                /**
                 * Set a new items on the list.
                 * @param {Array} newValue
                 */
                set items(newValue) {
                    var list = this.querySelector('.list-group'),
                        consumerData,
                        spanEl,
                        control;

                    if (newValue && newValue.length > 0) {
                        // clean older items.
                        list.innerHTML = '';
                        this._items = [];
                        [].forEach.call(newValue, function(item) {
                            item.classList.add('list-group-item');
                            item.tabIndex = -1;
                            consumerData = _getConsumerData(item);
                            consumerData.forEach(function(child) {
                                if (child.data) {
                                    spanEl = this.ownerDocument.createElement('span');
                                    spanEl.innerHTML = child.data;
                                    item.setAttribute('aria-selected', false);
                                    item.appendChild(spanEl);
                                } else {
                                    control = this.ownerDocument.createElement('span');
                                    control.classList.add('control');
                                    control.appendChild(child);
                                    item.appendChild(control);
                                }
                                this._items.push(item);
                            }, this);
                            list.appendChild(item);
                        }.bind(this));
                        if (!this.getAttribute('size')) {
                            this.size = this._items.length;
                        }
                    }
                },

                /**
                 * Retrieve a list of items of the list.
                 * @returns {Array}
                 */
                get items() {
                    return this._items;
                },

                /**
                 *  Read only property
                 */
                set selectedItem(newValue) {
                    // jshint unused:false
                },

                /**
                 * Retrieve the current selected item.
                 * (read only)
                 * @returns {HTMLELement}
                 */
                get selectedItem() {
                    return this._selectedItem;
                },

                postRender: function _() {
                    _.super(this);
                    var isAlreadyRendered = this.querySelector('.list-group-item') !== null,
                        size = this.getAttribute('size'),
                        list,
                        items;

                    if (isAlreadyRendered) {
                        return;
                    }

                    list = this.querySelector('.list-group');
                    if (!list) {
                        list = this.ownerDocument.createElement('ul');
                        list.tabIndex = 0;
                        list.classList.add('list-group');
                        this.appendChild(list);
                    }

                    list.setAttribute('aria-labelledby', 'ha-list-header-' + this.componentId);
                    items = this.querySelectorAll('li') || [];
                    this.items = items;
                    if (!size && items.length > 0) {
                        this.size = items.length;
                    }
                    this.setAttribute('complexity', 'basic'); // This are manual set until will fix V2 Api component default attributes.
                }
            });

        return register('ha-list', HASimpleList);
    }
);


define('text!hui/flyout/flyout.html',[],function () { return '<template>\n  <div class="header-bar">\n    <span class="flyout-tip"></span>\n  </div>\n  <div class="flyout-content-wrapper">\n    <div class="flyout-side-panel-wrapper"></div>\n    <section class="flyout-content">\n    </section>\n  </div>\n</template>';});


define('hui/flyout',[
    'register-component/v2/register',
    'object-utils/classes',
    './core/contentNode',
    './core/popup',
    './core/utils',
    './core/a11y',
    './core/keys',
    './core/Viewport',
    'register-component/template!./flyout/flyout.html',
    'register-component/v2/UIComponent'
], function(register, classes, contentNode, popup, utils, a11y, keys, Viewport, template, UIComponent) {
    'use strict';

    /**
     * Handler onanimationend.
     * @param {AnimationEvent} ev
     * @emits HA-FLYOUT#show
     * @emits HA-FLYOUT#close
     */
    function _animationListenerEnd(ev) {
        var eventName = ev.animationName,
            target = ev.target;

        if (eventName === 'ha-fade-in') {
            target.classList.remove('enter');
            target.emit('show');
        } else if (eventName === 'ha-fade-out') {
            target.classList.remove('visible');
            target.classList.remove('leave');
            target.emit('close');
        }
    }

    /**
     * Sets the flyout and the tip final positions.
     * @param {Event} ev
     */
    function _adjustFinalPosition(ev) {
        var target = ev.target,
            tip = target.querySelector('.flyout-tip'),
            button = _getButton(target);

        if (ev.animationName === 'ha-fade-in' || ev.type === 'more' || ev.type === 'less') {
            //separates the component from the button
            target.style.top = parseInt(target.style.top, 10) + 7 + 'px';
            //sets the tip position under the button
            tip.style.left = button.offsetLeft - target.offsetLeft + button.offsetWidth / 2 - tip.offsetWidth / 2 + 'px';
        }
    }

    /**
     * Blur Handler.
     * @param {Event} ev Blur event.
     */
    function _onBlur(ev) {
        // Stores the ha-flyout that has triggered the blur event
        var component = utils.getComponentFromElement(ev.target, 'HA-FLYOUT');

        if (component.tagName === 'HA-FLYOUT') {
            utils.stopEvent(ev);
        }

        if (!component.contains(utils.getSafeTargetFromEvent(ev)) || !component.contains(document.activeElement) || document.activeElement === ev.target) {
            component.close();
        }
    }

    /**
     * Returns the button that toggles the flyout.
     * @param {Component} component Flyout instance (this).
     * @returns {HTMLElement} The flyout button.
     * @private
     */
    function _getButton(component) {
        var button;

        if (component.targetSelector === '_previousSibling') {
            if (!component._button) {
                component._button = component.previousElementSibling;
            }

            button = component._button;
        } else {
            button = component.querySelector(component.targetSelector);
        }

        return button;
    }

    /**
     * Sets the animationend event handler for animating the popup hide
     * @param {Event} ev click event.
     * @emits HA-Flyou#more / HA-Flyou#less
     * @private
     */
    function _toggleMoreLess(ev) {
        var flyout = utils.getComponentFromElement(ev.target, 'HA-FLYOUT'),
            flyoutMore = flyout.querySelector('.flyout-more'),
            flyoutLess = flyout.querySelector('.flyout-less'),
            toggleMore = flyout.querySelector('.show-more'),
            eventType;
        if (ev.type === 'click' || ev.keyCode === keys.ENTER) {
            ev.preventDefault();
            if (flyoutMore.classList.contains('hidden')) {
                flyoutLess.classList.add('hidden');
                flyoutMore.classList.remove('hidden');
                toggleMore.classList.add('show-less');
                toggleMore.querySelector('span').innerHTML = flyout.lessText;
                eventType = 'more';
            } else {
                flyoutMore.classList.add('hidden');
                flyoutLess.classList.remove('hidden');
                toggleMore.classList.remove('show-less');
                toggleMore.querySelector('span').innerHTML = flyout.moreText;
                eventType = 'less';
            }

            //calls popup setPosition method for updating the flyout position
            popup.setPosition(flyout, _getButton(flyout), POSITION, ALIGNMENT);
            flyout.emit(eventType, {target: flyout});
            a11y.setFocusOnAnyFirst(flyout.querySelector('.flyout-content'));
        }
    }

    /**
     * Toggles Flyout display
     * @param {HTMLElement} flyout to show/hide.
     * @param {Event} event The event that triggered the flyout toggling
     */
    function _toggleFlyout(flyout, event) {
        if (flyout.classList.contains('visible')) {
            flyout.close();
        } else {
            flyout.show(event);
        }
    }

    /**
     * Recalculates the position when resizing viewport or expanding flyout
     * @param {HTMLElement} flyout to show/hide.
     */
    function _recalculatePosition(flyout) {
        popup.setPosition(flyout, _getButton(flyout), POSITION, ALIGNMENT);
        _adjustFinalPosition({target: flyout, animationName: 'ha-fade-in'});

    }

    /**
     * Calculates the width of the wider column, and sets that value as the width of the rest of them
     * @param  {HTMLElement} component The Flyout component
     */
    function _updateColumnsWidth(component) {
        var items = component.querySelectorAll('ha-menu-item, th'),
            sidePanelColumn = component.querySelector('.flyout-side-panel td'),
            contentColumns = component.querySelectorAll('.flyout-content td'),
            columnsNumber = contentColumns.length,
            itemsNumber = items.length,
            longestStringLength = 0,
            canvas = document.createElement('canvas'),
            itemStyle, index,
            itemText, menuStyle, font, itemLength;

        //get the styles from the first item (we assume all items have the same font styling)
        itemStyle = getComputedStyle(items[0]);
        font = itemStyle.fontSize + ' ' + itemStyle.fontFamily;

        //First find the longest string in the menu items
        for (index = 0; index < itemsNumber; index++) {
            itemText = items[index].textContent;
            itemLength = utils.getTextWidth(itemText, font, canvas);
            if (itemLength > longestStringLength) {
                longestStringLength = itemLength;
            }
        }

        menuStyle = getComputedStyle(items[0].parentElement);

        //set the calculated maximum width to every white column, the cells will adjust automatically
        for (index = 0; index < columnsNumber; index++) {
            contentColumns[index].style.width = longestStringLength + CONTENT_COLUMNS_EXTRA_WIDTH + 'px';
        }

        //set the width to the blue panel column if present
        if (sidePanelColumn) {
            sidePanelColumn.style.width = longestStringLength + SIDE_PANEL_COLUMN_EXTRA_WIDTH + 'px';
        }
    }

    var POSITION = ['bottom'],
        ALIGNMENT = ['center'],
        SIDE_PANEL_COLUMN_EXTRA_WIDTH = 59,
        CONTENT_COLUMNS_EXTRA_WIDTH = 40,

        /**
         * Map that says where to insert the content that the consumer sends on the initialization.
         * @type {Object}
         */
        contentPropertyMap = {
            'section': 'section'
        },

        triggerEventType,

        HAFlyout = classes.createObject(UIComponent, {

            init: function _() {

                _.super(this);

                /**
                * Component template
                * @type {function}
                */
                this.template = template;

                /**
                 * Tracks whether the component has been inserted in the dom
                 * to avoid doing certain positioning logic multiple times in the lifetime of the same element
                 * @type {Boolean}
                 */
                this._attached = false;

                contentNode.cacheInputContent(this, contentPropertyMap);

                this.setupProperties({
                    /**
                     * Flyout Header Title
                     * @type {String}
                     */
                    titleText: {
                        default: '',
                        change: function(newValue) {
                            var title = this.querySelector('h3'),
                                content = this.querySelector('.flyout-content');

                            if (!title) {
                                title = this.ownerDocument.createElement('h3');
                                title.innerHTML = newValue;
                                content.insertBefore(title, content.firstElementChild);
                            } else {
                                title.innerHTML = newValue;
                            }

                            title.id = 'flyout-title-' + this.componentId;
                        }
                    },

                    moreText: {
                        default: 'More',
                        change: function(newValue) {
                            var spanText,
                                toggleMore = this.querySelector('.show-more');
                            if (toggleMore && !toggleMore.classList.contains('show-less')) {
                                spanText = toggleMore.querySelector('span');
                                spanText.innerHTML = newValue;
                            }
                        }
                    },

                    lessText: {
                        default: 'Less',
                        change: function(newValue) {
                            var spanText,
                                toggleMore = this.querySelector('.show-more');
                            if (toggleMore && toggleMore.classList.contains('show-less')) {
                                spanText = toggleMore.querySelector('span');
                                spanText.innerHTML = newValue;
                            }
                        }
                    },

                    targetSelector: {
                        default: '_previousSibling'
                    }
                });
            },

            set section(newValue) {
                var flyoutContent = this.querySelector('.flyout-content'),
                    content = flyoutContent.children,
                    title = this.querySelector('h3');
                if (content.length > 0) {
                    utils.removeNodesSafe(flyoutContent, content);
                }

                if (title) {
                    flyoutContent.appendChild(title);
                }

                if (Array.isArray(newValue)) {
                    newValue.forEach(function(node) {
                        flyoutContent.appendChild(node);
                    });
                } else {
                    flyoutContent.appendChild(newValue);
                }
            },

            get section() {
                return this.querySelector('.flyout-content');
            },

            /**
            * Attaches the click event handler to the flyout button.
            */
            attachedCallback: function _() {
                if (!this._attached) {
                    this._attached = true;
                    var button = _getButton(this),
                        leftPanel = this.querySelector('.flyout-side-panel'),
                        panelPlace = this.querySelector('.flyout-side-panel-wrapper'),
                        flyoutMore = this.querySelector('.flyout-more'),
                        content = this.querySelector('.flyout-content'),
                        menu = this.querySelector('ha-menu'),
                        arrowMore, spanText, toggleMore;

                    if (button && button.tagName === 'BUTTON') {
                        this.listenTo(button, 'click', function(evt) {
                            evt.preventDefault();
                            _toggleFlyout(this, evt);
                        }.bind(this));
                        this.listenTo(button, 'keypress', function(evt) {
                            if (evt.keyCode === keys.ENTER) {
                                evt.preventDefault();
                                _toggleFlyout(this, evt);
                            }
                        }.bind(this));
                    } else {
                        console.warn('Flyout must have at least a button as previous sibling');
                    }

                    if (leftPanel) {
                        this.classList.add('ha-flyout-side-panel');
                        utils.removeNodesSafe(this, leftPanel);
                        panelPlace.appendChild(leftPanel);
                        _updateColumnsWidth(this);
                    }

                    if (flyoutMore) {
                        content.classList.add('clearfix');
                        flyoutMore.classList.add('hidden');
                        //Creates "Show More" link
                        toggleMore = this.querySelector('button.show-more');
                        if (!toggleMore) {
                            toggleMore = this.ownerDocument.createElement('button');
                            toggleMore.tabIndex = 0;
                            toggleMore.classList.add('show-more');

                            arrowMore = this.ownerDocument.createElement('i');
                            arrowMore.className = 'show-more-arrow';
                            toggleMore.appendChild(arrowMore);

                            spanText = this.ownerDocument.createElement('span');
                            spanText.innerHTML = this.moreText;
                            toggleMore.appendChild(spanText);

                            content.appendChild(toggleMore);
                        }

                        this.on('.show-more:click', _toggleMoreLess);
                        this.on('.show-more:keypress', _toggleMoreLess);
                        _updateColumnsWidth(flyoutMore);
                    }

                    if (content.children.length > 1 && !leftPanel && !flyoutMore && !menu) {
                        this.classList.add('flyout-non-menu');
                        content.tabIndex = -1;
                    }

                    //sets the aria-labelledby attribute to make the screen reader announce the
                    //title when focus is given to the component.
                    this.setAttribute('aria-labelledby', 'flyout-title-' + this.componentId);
                }
            },

            /**
             * Shows the flyout using popup
             * @param {Event} event The event that triggered the flyout opening
             */
            show: function(event) {
                var button = _getButton(this),
                    menus = this.querySelectorAll('ha-menu');

                //makes the menus tabable.
                if (menus.length && menus[0].tabIndex === -1) {
                    [].forEach.call(menus, function(item) {
                        item.tabIndex = 0;
                    });
                }

                if (popup.setPosition(this, button, POSITION, ALIGNMENT)) {
                    this.classList.remove('leave');
                    this.classList.add('enter');
                    this.classList.add('visible');
                }

                if (event) {
                    triggerEventType = event.type;
                } else {
                    triggerEventType = null;
                }

                this._resizeMethod = function() {
                    _recalculatePosition(this);
                }.bind(this);

                Viewport.onResize(this._resizeMethod);

                this.focus();
            },

            /**
             * Hides Flyout
             */
            close: function() {
                this.classList.add('leave');
                _getButton(this).focus();
            },

            preRender: function _() {
                _.super(this);
            },

            /**
             * Sets event handlers for animations and user interaction events.
             */
            createdCallback: function _() {
                var anim = utils.getAnimationEventNames(),
                    animationEndEvt = anim.animationend,
                    animationStartEvt = anim.animationstart;

                _.super(this);

                // This timeout it's a fix for firefox. Without it, there is no way to tell
                // where the focus is going and we can't be sure we can close the flyout
                this.listenTo(this, 'blur', function(evt) {
                    setTimeout(function() {
                        _onBlur(evt);
                    }, 1);
                }, true);
                this.on(animationStartEvt, _adjustFinalPosition);
                this.on('more', _adjustFinalPosition);
                this.on('less', _adjustFinalPosition);
                this.on(animationEndEvt, _animationListenerEnd);
                this.on('close', function() {
                    popup.uninstallResizeMethod(this._resizeMethod);
                });

                //Keyboard access event handlers
                this.on('keydown', function(evt) {
                    if (keys.ESCAPE === evt.keyCode) {
                        utils.stopEvent(evt);
                        this.close();
                    }
                });
            },

            postRender: function _() {
                _.super(this);
                contentNode.storeCachedInput(this, contentPropertyMap);
                this.tabIndex = -1;
            }

        });

    return register('ha-flyout', HAFlyout);
});


define('text!hui/money-bar/money-bar.html',[],function () { return '<template>\n    <div class="segments">\n    </div>\n</template>';});



define('text!hui/money-bar-cell/money-bar-cell.html',[],function () { return '<template>\n    <div class="money-bar-block"></div>\n    <div class="money-bar-text">\n    \t<span class="primary-text">{{primaryText}}</span>\n    \t<span class="secondary-text">{{secondaryText}}</span>\n    \t<span class="close-icon" tabindex="-1" aria-label="Close" role="button"> &#xf061;</span>\n    </div>\n</template>';});


define('hui/money-bar-cell',[
    'register-component/v2/UIComponent',
    'register-component/v2/register',
    'register-component/template!./money-bar-cell/money-bar-cell.html',
    './core/keys',
    'object-utils/classes'
],
    function(UIComponent, register, template, keys, classes) {
        var HAMoneyBarCell = classes.createObject(UIComponent, {
            init: function _() {

                _.super(this);
                this.template = template;
                this.mbcells = null;

                this.setupProperties({
                    /**
                     * primary text associated with mb cell
                     * used for numbers in classic mb
                     * @type {String}
                     */
                    primaryText: {
                        default: '',
                        change: function(newValue) {
                            var pTextEl = this.querySelector('.primary-text'),
                                mbTextEl = this.querySelector('.money-bar-text'),
                                mbTextChild = mbTextEl.firstChild; //where it should be appended

                            if (newValue) {
                                if (!pTextEl) {
                                    pTextEl = document.createElement('span');
                                    pTextEl.classList.add('primary-text');
                                    mbTextEl.insertBefore(pTextEl, mbTextChild);
                                }
                                pTextEl.textContent = newValue;
                                this._nodes.primaryText = pTextEl;
                            }
                        }
                    },
                    /**
                     * secondary text associated with mb cell
                     * used for description in classic mb
                     * @type {String}
                     */
                    secondaryText: {
                        default: '',
                        change: function(newValue) {
                            var sTextEl = this.querySelector('.secondary-text'),
                                mbTextEl = this.querySelector('.money-bar-text'),
                                mbTextChild = mbTextEl.querySelector('.close-icon'); //where it should be appended before
                            if (newValue) {
                                if (!sTextEl) {
                                    sTextEl = document.createElement('span');
                                    sTextEl.classList.add('secondary-text');
                                    mbTextEl.insertBefore(sTextEl, mbTextChild);
                                }
                                sTextEl.textContent = newValue;
                                this._nodes.secondaryText = sTextEl;
                            }
                        }
                    },
                    /**
                     * state of the mb, adds/removes click class to mb
                     * @type {String}
                     */
                    state: {
                        default: 'deselected',
                        change: function(newValue) {
                            var block = this._nodes.mbBlock,
                                closeIcon = this.querySelector('.close-icon');

                            if (this.state !== block.state) {
                                if (newValue === 'deselected') {
                                    block.state = newValue;
                                    this.classList.remove('click');
                                    closeIcon.setAttribute('tabindex', '-1');
                                    this.emit('deselected', {target: this});
                                } else if (newValue === 'selected') {
                                    block.state = newValue;
                                    this.classList.add('click');
                                    closeIcon.setAttribute('tabindex', '0');
                                    this.emit('selected', {target: this});
                                } else {
                                    //if illegal value is passed
                                    //keep it to whatever value it was originally
                                    this.state = block.state;
                                }
                            }
                        }
                    }
                });
                /* bind event handlers */
                this.listenTo(this, 'mouseenter', function(evt) {
                    this._eventAddClass('hover', 'inlay-hover', evt);
                }.bind(this));

                this.listenTo(this, 'mouseleave', function(evt) {
                    this._eventRemoveClass('hover', 'inlay-hover', evt);
                }.bind(this));

                this.listenTo(this, 'focusin', function(evt) {
                    this._eventAddClass('hover', 'inlay-hover', evt);
                }.bind(this));

                this.listenTo(this, 'focus', function(evt) {
                    this._eventAddClass('hover', 'inlay-hover', evt);
                }.bind(this));

                this.listenTo(this, 'focusout', function(evt) {
                    this._eventRemoveClass('hover', 'inlay-hover', evt);
                    this.setAttribute('tabindex', '-1');
                }.bind(this));

                this.listenTo(this, 'blur', function(evt) {
                    this._eventRemoveClass('hover', 'inlay-hover', evt);
                    this.setAttribute('tabindex', '-1');
                }.bind(this));

                this.listenTo(this, 'click', function(evt) {
                    evt.preventDefault();
                    evt.stopPropagation();
                    if (this.state === 'selected') {
                        this.state = 'deselected';
                        this.classList.remove('inlay-select');
                        this._eventRemoveClass('click', 'inlay-select', evt);
                        this._eventRemoveClass('hover', 'inlay-hover', evt);
                        this.setAttribute('tabindex', '-1');
                        this.blur();
                    } else {
                        this.state = 'selected';
                        this.setAttribute('tabindex', '0');
                        this.focus();
                        this._eventAddClass('click', 'inlay-select', evt);
                    }
                }.bind(this));

                this.listenTo(this, '.close-icon:keydown', function(evt) {
                    if (evt.keyCode === keys.ENTER) {
                        var sibling = this.nextElementSibling;
                        this.state = 'deselected';
                        //behaviors for outlay/inlay
                        if (this.classList.contains('outlay')) {
                            if (sibling !== null && sibling.classList.contains('inlay')) {
                                sibling.classList.remove('inlay-select');
                            }
                        }
                        evt.stopPropagation();
                        this.style.outline = '1px dotted #212121';
                        this.style.outline = '-webkit-focus-ring-color auto 5px';
                        this.focus();
                    } else if (evt.keyCode === keys.TAB) {
                        evt.stopPropagation();
                        evt.preventDefault();
                        this.style.outline = '1px dotted #212121';
                        this.style.outline = '-webkit-focus-ring-color auto 5px';
                        this.focus();
                    }
                }.bind(this));
            },
            /*
             * Creates a Money Bar Cell based on the attributes that were passed.
             */
            postRender: function _() {
                //a11y.addA11yFocus(this);
                var primaryTextEl = this.querySelector('.primary-text'),
                    secondaryTextEl = this.querySelector('.secondary-text'),
                    mbBlockEl = this.querySelector('.money-bar-block');

                //_nodes maintains synchronicity and makes sure properties are legal
                //by keeping track of the previous state of properties when they are changed
                this._nodes = {};
                this._nodes.mbBlock = mbBlockEl;

                this._nodes.primaryText = primaryTextEl;
                this._nodes.secondaryText = secondaryTextEl;

                //accessibility
                this.setAttribute('tabindex', '-1');
                this.setAttribute('role', 'menuitem');
                this.setAttribute('id', 'ha-money-bar-cell-' + this.componentId);
            },
            _eventAddClass: function _(thisClass, inlayClass, evt) {
                this.classList.add(thisClass);
                var sibling = this.nextElementSibling;
                //behaviors for outlay/inlay
                if (this.classList.contains('outlay')) {
                    if (sibling !== null && sibling.classList.contains('inlay')) {
                        sibling.classList.add(inlayClass);
                    }
                }
                evt.stopPropagation();
            },
            _eventRemoveClass: function _(thisClass, inlayClass, evt) {
                this.classList.remove(thisClass);
                var sibling = this.nextElementSibling;
                //behaviors for outlay/inlay
                if (this.classList.contains('outlay')) {
                    if (sibling !== null && sibling.classList.contains('inlay')) {
                        sibling.classList.remove(inlayClass);
                    }
                }
                evt.stopPropagation();
            }

        });
        return register('ha-money-bar-cell', HAMoneyBarCell);
    });

define('text!hui/money-bar-segment/money-bar-segment.html',[],function () { return '<template>\n\t<h4 class="segment-header">\n\t\t<span class="segment-text-bold">{{titleTextBold}}</span>\n\t\t<span class="segment-text">{{titleText}}</span>\n\t</h4>\n    <div class="cells">\n    </div>\n</template>';});


define('hui/money-bar-segment',[
    'register-component/v2/UIComponent',
    'register-component/v2/register',
    'register-component/template!./money-bar-segment/money-bar-segment.html',
    './core/utils',
    'object-utils/classes'
],
    function(UIComponent, register, template, utils, classes) {
        var HAMoneyBarSegment = classes.createObject(UIComponent, {
            init: function _() {
                _.super(this);
                this.template = template;
                this._cells = null;

                /*
                 * ES5 setter that updates this._cells property
                 * and makes sure that DOM nodes are current
                 */
                Object.defineProperty(this, 'cells', {
                    set: function(newCells) {
                        var cellContainer = this.querySelector('.cells'),
                            headerEl = this.querySelector('.segment-header');
                        //if we have initialized the cell container, update the dom
                        if (cellContainer) {
                            cellContainer.innerHTML = '';
                            newCells.forEach(function(element) {
                                element.setAttribute('aria-describedby', headerEl.id);
                                cellContainer.appendChild(element);
                            });
                        }
                        this._cells = newCells;
                    }
                });
                this.setupProperties({
                    /**
                     * part of text associated with mb segment
                     * used for numbers in classic mb
                     * @type {String}
                     */
                    titleTextBold: {
                        default: '',
                        change: function(newValue) {
                            var textEl = this.querySelector('.segment-text-bold'),
                                headerEl = this.querySelector('.segment-header'),
                                theFirstChild = headerEl.firstChild;

                            if (newValue) {
                                if (!textEl) {
                                    textEl = document.createElement('span');
                                    textEl.classList.add('segment-text-bold');
                                    headerEl.insertBefore(textEl, theFirstChild);
                                }
                                textEl.textContent = newValue;
                                this._nodes.titleTextBold = textEl;
                            }
                        }
                    },
                    /**
                     * part of text associated with mb segment
                     * used for description in classic mb
                     * @type {String}
                     */
                    titleText: {
                        default: '',
                        change: function(newValue) {
                            var textEl = this.querySelector('.segment-text'),
                                headerEl = this.querySelector('.segment-header'),
                                theFirstChild = headerEl.firstChild;

                            if (newValue) {
                                if (!textEl) {
                                    textEl = document.createElement('span');
                                    textEl.classList.add('segment-text');
                                    headerEl.insertBefore(textEl, theFirstChild);
                                }
                                textEl.textContent = newValue;
                                this._nodes.titleText = textEl;
                            }
                        }
                    },
                    /**
                     * number of interior cells, used to set "flex" style of segment
                     * @type {String}
                     */
                    size: {
                        default: '2',
                        change: function(newValue) {
                            var cellContainer = this._nodes.cellContainer;
                            if (this.size !== cellContainer.size) {
                                cellContainer.size = newValue;
                                this.style.flex = (newValue + ' 0 auto');
                                //for safari
                                this.style['-webkit-flex'] = (newValue + ' 0 auto');
                            }
                        }
                    }
                });
            },

            /*
             * Sets up Cells for the creation of the Money Bar
             * Transform list of Cells from NodeList to array
             */
            preRender: function _() {
                var mbcells,
                    mbcellContainerEl = this.querySelector('.cells');
                // assign cells from ha-money-bar-cells nodes
                mbcells = this.querySelectorAll('ha-money-bar-cell');
                if (mbcellContainerEl) {
                    // but if we have rendered it already, don't attempt to remove the node
                    // make it an array
                    this.cells = Array.prototype.map.call(mbcells, function(element) {
                        return element;
                    });
                } else {
                    this.cells = utils.removeNodesSafe(this, mbcells);
                }
            },

            /*
             * Creates a Money Bar Segment based on the attributes that were passed.
             */
            postRender: function _() {
                _.super(this);

                var mbcellContainerEl = this.querySelector('.cells'),
                    headerEl = this.querySelector('.segment-header'),
                    titleEl = this.querySelector('.segment-text'),
                    titleBoldEl = this.querySelector('.segment-text-bold');

                //_nodes maintains synchronicity and makes sure properties are legal
                //by keeping track of the previous state of properties when they are changed
                this._nodes = {};
                this._nodes.cellContainer = mbcellContainerEl;
                mbcellContainerEl.innerHTML = ''; //make sure it's empty
                headerEl.setAttribute('id', ('segment-header-' + this.componentId));
                this._nodes.titleText = titleEl;
                this._nodes.titleTextBold = titleBoldEl;
                this._cells.forEach(function(element) {
                    element.setAttribute('aria-describedby', headerEl.id);
                    mbcellContainerEl.appendChild(element);
                });
                //so that the money bar actually displays correctly
                this.style.flex = (this.size + ' 0 auto');
                //for safari
                this.style['-webkit-flex'] = (this.size + ' 0 auto');
                this.id = ('ha-money-bar-segment-' + this.componentId);

            }
        });
        return register('ha-money-bar-segment', HAMoneyBarSegment);
    });

define('hui/money-bar',[
    'register-component/v2/UIComponent',
    'register-component/v2/register',
    'register-component/template!./money-bar/money-bar.html',
    './core/utils',
    './core/keys',
    './core/a11y',
    'object-utils/classes',
    './money-bar-cell',
    './money-bar-segment'
],
    function(UIComponent, register, template, utils, keys, a11y, classes) {

        var HAMoneyBar = classes.createObject(UIComponent, {
            init: function _() {
                _.super(this);
                this.template = template;
                this._segments = null;

                /*
                 * ES5 setter that updates this._segments property
                 * and makes sure that DOM nodes are current
                 */
                Object.defineProperty(this, 'segments', {
                    set: function(newSegs) {
                        var segContainer = this.querySelector('.segments');
                        //if we have initialized the segment container, update the dom
                        if (segContainer) {
                            segContainer.innerHTML = '';
                            newSegs.forEach(function(element) {
                                segContainer.appendChild(element);
                            });
                        }
                        this._segments = newSegs;
                    }
                });

                /* bind event handlers */
                this.listenTo(this, 'ha-money-bar-cell:selected', function(evt) {
                    //a cell has been selected, so we want to clear all other selected cells
                    this.clearSelectedExcept(evt.target);
                }.bind(this));

                this.listenTo(this, 'keydown', function(evt) {
                    var nextTarget,
                        itemSelected = evt.target,
                        selectedIndex,
                        cells = this.querySelectorAll('ha-money-bar-cell'),
                        sibling = evt.target.nextElementSibling;
                    //if the target is a cell
                    if (evt.target.nodeName === 'HA-MONEY-BAR-CELL') {
                        evt.stopPropagation();
                        evt.preventDefault();
                        //move up or left on the money bar
                        if ((evt.keyCode === keys.UP) || (evt.keyCode === keys.LEFT)) {
                            //if not first cell in the Money Bar
                            if (itemSelected.id !== cells[0].id) {
                                selectedIndex = 0;
                                //find next target
                                while (cells[selectedIndex].id !== itemSelected.id) {
                                    selectedIndex++;
                                }
                                nextTarget = cells[(selectedIndex - 1)];
                                itemSelected.setAttribute('tabindex', '-1');
                                itemSelected.style.outline = 'none';
                                itemSelected.blur();
                                nextTarget.setAttribute('tabindex', '0');
                                //add a specific focus outline (necessary for FF)
                                //or override that focus outline and use the browser default, if present
                                nextTarget.style.outline = '1px dotted #212121';
                                nextTarget.style.outline = '-webkit-focus-ring-color auto 5px';
                                nextTarget.focus();
                                if (itemSelected.state === 'selected') {
                                    (itemSelected.querySelector('.close-icon')).setAttribute('tabindex', '-1');
                                }
                                if (nextTarget.state === 'selected') {
                                    (nextTarget.querySelector('.close-icon')).setAttribute('tabindex', '0');
                                }
                            }
                        //move down or right on the money bar
                        } else if ((evt.keyCode === keys.DOWN) || (evt.keyCode === keys.RIGHT)) {
                            //if not last cell in the Money Bar
                            if (itemSelected.id !== cells[cells.length - 1].id) {
                                selectedIndex = cells.length - 1;
                                //find next target
                                while (cells[selectedIndex].id !== itemSelected.id) {
                                    selectedIndex--;
                                }
                                nextTarget = cells[(selectedIndex + 1)];
                                //reset itemSelected to unselected state
                                itemSelected.style.outline = 'none';
                                itemSelected.setAttribute('tabindex', '-1');
                                itemSelected.blur();
                                //select new cell
                                nextTarget.setAttribute('tabindex', '0');
                                //add a specific focus outline (necessary for FF)
                                //or override that focus outline and use the browser default, if present
                                nextTarget.style.outline = '1px dotted #212121';
                                nextTarget.style.outline = '-webkit-focus-ring-color auto 5px';
                                nextTarget.focus();
                                if (itemSelected.state === 'selected') {
                                    (itemSelected.querySelector('.close-icon')).setAttribute('tabindex', '-1');
                                }
                                if (nextTarget.state === 'selected') {
                                    (nextTarget.querySelector('.close-icon')).setAttribute('tabindex', '0');
                                }
                            }
                        } else if (evt.keyCode === keys.ENTER) {
                            //select or deselect the cell, based on its state
                            if (itemSelected.state === 'deselected') {
                                //select a new cell
                                itemSelected.state = 'selected';
                                //behaviors for outlay/inlay
                                if (itemSelected.classList.contains('outlay')) {
                                    if (sibling !== null && sibling.classList.contains('inlay')) {
                                        sibling.classList.add('inlay-select');
                                    }
                                }
                            } else {
                                //deselect the cell
                                itemSelected.state = 'deselected';
                                //behaviors for outlay/inlay
                                if (itemSelected.classList.contains('outlay')) {
                                    if (sibling !== null && sibling.classList.contains('inlay')) {
                                        sibling.classList.remove('inlay-select');
                                    }
                                }
                            }
                        //if we tab, blur focus on the cell
                        } else if (evt.keyCode === keys.TAB) {
                            if (itemSelected.state === 'deselected') {
                                itemSelected.setAttribute('tabindex', '-1');
                                itemSelected.style.outline = 'none';
                                itemSelected.blur();
                                this.focus();
                            } else {
                                itemSelected.style.outline = 'none';
                                (itemSelected.querySelector('.close-icon')).focus();
                            }
                        }
                    // else if the target is the money bar itself
                    } else if (evt.target.nodeName === 'HA-MONEY-BAR') {
                        //start moving through the money bar by focusing on the first cell
                        if ((evt.keyCode === keys.DOWN) || (evt.keyCode === keys.RIGHT)) {
                            cells[0].setAttribute('tabindex', '0');
                            //add a specific focus outline (necessary for FF)
                            //or override that focus outline and use the browser default, if present
                            cells[0].style.outline = '1px dotted #212121';
                            cells[0].style.outline = '-webkit-focus-ring-color auto 5px';
                            cells[0].focus();
                            evt.stopPropagation();
                            evt.preventDefault();
                        }
                    }
                }.bind(this));
            },

            /*
             * Sets up Segments for the creation of the Money Bar
             * Transform list of segments from NodeList to array
             */
            preRender: function _() {
                var mbsegs,
                    mbsegContainerEl = this.querySelector('.segments');

                // assign cells from ha-money-bar-cells nodes
                if (!this._segments) {
                    mbsegs = this.querySelectorAll('ha-money-bar-segment'); //returns NodeList
                    if (mbsegContainerEl) {
                        // but if we have rendered it already, don't attempt to remove the node
                        // make it an array
                        this.segments = Array.prototype.map.call(mbsegs, function(element) {
                            return element;
                        });
                    } else {
                        this.segments = utils.removeNodesSafe(this, mbsegs);
                    }
                }
            },

            /*
             * Creates a Money Bar based on the attributes that were passed.
             */
            postRender: function _() {
                a11y.addA11yFocus(this);
                var mbsegContainerEl = this.querySelector('.segments');

                this._nodes = {};
                this._nodes.segContainer = mbsegContainerEl;
                mbsegContainerEl.innerHTML = ''; //make sure it's empty
                this._segments.forEach(function(element) {
                    mbsegContainerEl.appendChild(element);
                });

                this.setAttribute('role', 'menubar');
                this.setAttribute('tabindex', '0');
            },

            /*
             * Public method which deselects all the cells in a Money Bar
             */
            clearSelected: function _() {
                var mbcells = this.querySelectorAll('ha-money-bar-cell'),
                    i = 0;
                for (i; i < mbcells.length; i++) {
                    mbcells[i].setAttribute('state', 'deselected');
                    mbcells[i].classList.remove('inlay-select');
                }
            },

            /*
             * deselects all cells in all segments except for @segment
             */
            clearSelectedExcept: function _(component) {
                var notOutlay = true,
                    mbcells,
                    i = 0;
                //if the selected component is an outlay, we don't want to
                //remove inlay-select from the inlay
                //without this, there are synchronicity issues in all browsers
                //except for Chrome
                if (component.classList.contains('outlay')) {
                    notOutlay = false;
                }
                mbcells = this.querySelectorAll('ha-money-bar-cell');
                for (i; i < mbcells.length; i++) {
                    if (mbcells[i].id !== component.id) {
                        mbcells[i].setAttribute('state', 'deselected');
                        if (notOutlay) {
                            mbcells[i].classList.remove('inlay-select');
                        }
                    }
                }
            },
            /*
             * Public method which selects one cell in a Money Bar
             * only one cell selectable at a time
             */
            setSelected: function _(component) {
                this.clearSelected();
                component.setAttribute('state', 'selected');
            }
        });
        return register('ha-money-bar', HAMoneyBar);
    });

define('text!hui/tags/tag.html',[],function () { return '<template>\n    <span class="tag-label">{{label}}</span>\n    <button>\n        <span class="hi hi-close" aria-hidden="true"></span>\n        <span class="dismiss-text sr-only">Dismiss {{label}}</span>\n    </button>\n</template>\n';});


/**
 * @module
 * @class HATag
 * Tag component
 * Used by the HATags component - Tags are rendered with an optional dismissible button
 */
define('hui/tag',[
    'register-component/v2/register',
    'object-utils/classes',
    'register-component/v2/UIComponent',
    'register-component/template!./tags/tag.html'
], function(register, classes, UIComponent, template) {
    var HATag = classes.createObject(UIComponent, /** @lends HATag# */{
        /** @constructs **/
        init: function _() {
            _.super(this);

            this.template = template;

            this.setupProperties(/** @lends HATag **/ {
                /**
                 * The value of the tag
                 * @type {string}
                 * @default
                 */
                value: {
                    type: String,
                    default: ''
                },
                /**
                 * The label used to display on the tag
                 * @type {string}
                 * @default
                 */
                label: {
                    type: String,
                    default: '',
                    change: function(newValue) {
                        this.querySelector('span.tag-label').textContent = newValue;
                        this.querySelector('.dismiss-text').textContent = this.dismissText + newValue;
                    }
                },
                /**
                 * The text value for the ARIA dismiss button label
                 * @type String
                 * @default
                 */
                dismissText: {
                    type: String,
                    default: 'Dismiss ',
                    change: function(newValue) {
                        this.querySelector('.dismiss-text').textContent = newValue + this.label;
                    }
                },
                /**
                 * If true, shows the close button on the tag
                 * @type {boolean}
                 * @default false
                 */
                notDismissible: {
                    type: Boolean,
                    default: false,
                    change: function(value) {
                        this.querySelector('button').classList[value ? 'add' : 'remove']('hidden');
                    }
                }
            });

            this.on('button:click', this._onClickDismiss.bind(this));
        },

        preRender: function _() {
            _.super(this);
            this._label = this.textContent;
        },

        postRender: function _() {
            _.super(this);
            if (this._label) {
                this.label = this._label;
            }
        },

        /**
         * the click handler for the dismiss button
         * @private
         */
        _onClickDismiss: function(event) {
            this.emit('dismiss');
            event.stopPropagation();
        }
    });

    return register('ha-tag', HATag);
});


define('text!hui/tags/tags.html',[],function () { return '<template>\n    <div class="tags-container"></div>\n    <button class="more" action="showAll"></button>\n    <button class="dismiss hidden" action="dismissAll"></button>\n</template>\n';});


/**
 * @module
 * @class HATags
 * Tags component
 * Display a list of tags with a dismiss button that fires events when that button is clicked
 */
define('hui/tags',[
    'register-component/v2/register',
    'object-utils/classes',
    'register-component/v2/UIComponent',
    './helpers/string.helper',
    'register-component/template!./tags/tags.html',
    './tag'
], function(register, classes, UIComponent, stringHelper, template) {
    var HATags;

    /**
     * append a CSS rule to the page and return a handle so that the rule can be removed
     * @param {string} selector - The selector to use in the new rule
     * @param {string} css - the CSS rules to add to the stylesheet
     * @returns {Object} - an object with a remove method which can be used to delete the rule
     * @private
     */
    function addCssRule(selector, css) {
        var sheet = document.createElement('style'),
            head = document.querySelector('head');
        head.appendChild(sheet);
        sheet = sheet.sheet;

        /* istanbul ignore next */
        if (sheet.addRule) {
            sheet.addRule(selector, css);
        } else {
            sheet.insertRule(selector + '{' + css + '}', 0);
        }

        return {
            sheet: sheet,
            remove: function() {
                var style = sheet.ownerNode;
                sheet.deleteRule(0);
                style.parentElement.removeChild(style);
                sheet = style = null;
            }
        };
    }

    HATags = classes.createObject(UIComponent, /** @lends HATags# **/ {
        /** @constructs **/
        init: function _() {
            _.super(this);

            this.template = template;

            this.setupProperties(/** @lends HATags# **/{
                /**
                 * The maximum number of tags to display in the component. A CSS rule is generated based on this value
                 * @type {number}
                 * @default
                 */
                maxDisplay: {
                    type: Number,
                    default: 3,
                    change: function(value) {
                        var id = 'ha-tags-' + this.componentId;
                        this.setAttribute('data-unique-id', id);
                        if (this._maxDisplayRule) {
                            this._maxDisplayRule.remove();
                        }
                        this._maxDisplayRule = addCssRule('ha-tags[data-unique-id=' + id + '] ha-tag:nth-of-type(1n + ' + (value + 1) + ')', 'display: none');
                        this._update();
                    }
                },
                /**
                 * Whether to show the dismiss all button in the component
                 * @type {boolean}
                 * @default
                 */
                noDismissAll: {
                    type: Boolean,
                    default: false,
                    change: function() {
                        this._update();
                    }
                },
                /**
                 * The text to display in the dismiss all button
                 * @type {string}
                 * @default
                 */
                dismissAllText: {
                    type: String,
                    default: 'Clear all',
                    change: function(newValue) {
                        var button = this.querySelector('button.dismiss');
                        button.textContent = newValue;
                    }
                },
                /**
                 * The text to display in the More button
                 * @type {string}
                 * @default
                 */
                moreText: {
                    type: String,
                    default: '... and {{count}} more',
                    change: function() {
                        this._update();
                    }
                }
            });

            this.on('ha-tag:dismiss', this._onDismiss.bind(this));
            this.on('button:click', this._onClickButton.bind(this));
        },

        preRender: function _() {
            _.super(this);
            this._tags = this.querySelectorAll('ha-tag');
        },

        postRender: function _() {
            _.super(this);

            this.tags = this._tags;
            var tags = this.querySelectorAll('ha-tag');
            this._tags = [];
            this.tags = tags;
        },

        detachedCallback: function() {
            /* istanbul ignore else */
            if (this._maxDisplayRule) {
                this._maxDisplayRule.remove();
            }
            this._maxDisplayRule = null;
        },

        /**
         * Add a tag to the component
         * @param {HATag} tag - the tag to be added
         */
        add: function(tag) {
            var tags = this._tags;
            tags.push(tag);
            this.querySelector('.tags-container').appendChild(tag);

            this._update();
        },

        /**
         * Remove a tag from the component
         * @param {HATag} tag - the tag to be removed
         */
        remove: function(tag) {
            /* istanbul ignore else */
            if (tag) {
                this.querySelector('.tags-container').removeChild(tag);
                this.tags.splice(this.tags.indexOf(tag), 1);
                this._update();
            }
        },

        /**
         * The tags that currently exist in the component
         * @type {HATag[]}
         */
        set tags(tags) {
            var tagsNode = this.querySelector('.tags-container');
            Array.prototype.forEach.call(tagsNode.querySelectorAll('ha-tag'), this.remove.bind(this));
            this._tags = [];

            if (!tags) {
                // the tags are being cleared
                return;
            }

            Array.prototype.forEach.call(tags, this.add.bind(this));
        },

        get tags() {
            return this._tags;
        },

        /**
         * Called when a tag is dismissed, removing the tag
         * @param {Event} event - the event object
         * @private
         */
        _onDismiss: function(event) {
            this.remove(event.target);
        },

        /**
         * Button dispatch method that determines the appropriate action and performs it
         * @param {Event} event - the event object
         * @private
         */
        _onClickButton: function(event) {
            var action = event.target.getAttribute('action');
            if (typeof this[action] === 'function') {
                this[action]();
            }
        },

        /**
         * Emit a 'show-all' event on the component
         */
        showAll: function() {
            this.emit('show-all');
        },

        /**
         * Emit a 'dismiss-all' event on the component
         */
        dismissAll: function() {
            this.emit('dismiss-all');
            this.tags = null;
        },

        /**
         * update the state of the component, ensuring that the "more" button has the correct number
         * of additional tags displayed and which buttons are currently visible
         * @private
         */
        _update: function() {
            var moreButton = this.querySelector('button.more'),
                dismissButton = this.querySelector('button.dismiss'),
                tags = this.tags;
            if (tags.length > this.maxDisplay) {
                moreButton.classList.remove('hidden');
                moreButton.textContent = stringHelper.replaceKeys(this.moreText, {
                    count: tags.length - this.maxDisplay
                });
            } else {
                moreButton.classList.add('hidden');
                moreButton.textContent = '';
            }

            dismissButton.classList[!this.noDismissAll && tags.length ? 'remove' : 'add']('hidden');
        }
    });

    return register('ha-tags', HATags);
});

define('hui/stage',[
    'register-component/v2/register',
    'register-component/v2/UIComponent',
    'object-utils/classes',
    './core/contentNode',
    './core/a11y'
], function(register, UIComponent, classes, contentNode, a11y) {
    'use strict';

    var HAStage, _contentPropertyMap;

    /**
     * This method is used to toggle the visiblity of the Stage
     */
    function _toggle() {
        /*jshint validthis:true */
        if (this.open) {
            this.close();
        } else {
            this.show();
        }
    }

    /**
     * Updates collapsible's toggle button aria-controls attribute
     * @param  {HTMLElement} stage
     */
    function _updateAriaControls(stage) {
        var section = stage.querySelector('section'),
            buttonToggle = stage.querySelector('.btn-toggle'),
            sectionId;

        if (section && stage.collapsible) {
            sectionId = section.id;
            if (!sectionId) {
                section.id = 'stage-section-' + stage.componentId;
                sectionId = section.id;
            }
            if (buttonToggle) {
                buttonToggle.setAttribute('aria-controls', sectionId);
            }
        }
    }

    _contentPropertyMap = {
        'header': 'header',
        'section': 'section'
    };

    HAStage = classes.createObject(UIComponent, {

        init: function _() {
            _.super(this);
            // header init null
            this._header = null;
            // section init null
            this._section = null;

            contentNode.cacheInputContent(this, _contentPropertyMap);

            this.setupProperties({
                /**
                 * Collapsible indicates if the Stage is collapsible.
                 * @type {Boolean}
                */
                collapsible: {
                    default: false,
                    type: Boolean,
                    change: function(newValue) {
                        var header = this.querySelector('header'),
                            section = this.querySelector('section'),
                            buttonToggle = this.querySelector('.btn-toggle'),
                            iconToggle;
                        if (newValue) {
                            if (!section || !header) {
                                if (!this.reactLayering) {
                                    console.error('You can not set collapsible to be true if you do not have both a header and a section.');
                                }
                            } else {
                                if (!buttonToggle) {
                                    buttonToggle = this.ownerDocument.createElement('button');
                                    buttonToggle.className = 'btn-toggle';
                                    buttonToggle.setAttribute('aria-expanded', 'false');
                                    buttonToggle.setAttribute('aria-label', 'expand');
                                    this.appendChild(buttonToggle);
                                    iconToggle = this.ownerDocument.createElement('i');
                                    iconToggle.className = 'hi hi-chevron-down';
                                    buttonToggle.appendChild(iconToggle);
                                }
                                section.classList.remove('inner-visible');
                                _updateAriaControls(this);
                            }
                        } else {
                            if (buttonToggle) {
                                this.removeChild(buttonToggle);
                            }
                            if (section) {
                                section.classList.add('inner-visible');
                            }
                        }
                    }
                },

                /**
                 * Open indicates if the Stage content is open.
                 * @type {Boolean}
                */
                open: {
                    default: false,
                    type: Boolean,
                    change: function(newValue) {
                        var iconToggle,
                            buttonToggle = this.querySelector('.btn-toggle'),
                            section = this.querySelector('section');
                        if (this.collapsible && section) {
                            iconToggle = buttonToggle.querySelector('.hi');
                            if (newValue) {
                                buttonToggle.setAttribute('aria-expanded', 'true');
                                buttonToggle.setAttribute('aria-label', 'collapse');
                                iconToggle.classList.add('hi-chevron-up');
                                iconToggle.classList.remove('hi-chevron-down');
                                section.classList.add('inner-visible');
                            } else {
                                buttonToggle.setAttribute('aria-expanded', 'false');
                                buttonToggle.setAttribute('aria-label', 'expand');
                                iconToggle.classList.remove('hi-chevron-up');
                                iconToggle.classList.add('hi-chevron-down');
                                section.classList.remove('inner-visible');
                            }
                        }
                    }
                },

                /**
                 * Indicates whether the component is rendered into the body by react
                 * @type {Boolean}
                 */
                reactLayering: {
                    type: Boolean,
                    default: false
                }
            });

            this.on('button.btn-toggle:click', _toggle.bind(this));
        },
        get header() {
            return this._header;
        },

        set header(newValue) {
            var header = this.querySelector('header'),
                backLink;

            if (!header) {
                header = this.ownerDocument.createElement('header');
                this.appendChild(header);
            }
            while (header.firstElementChild) {
                header.removeChild(header.firstElementChild);
            }
            if (Array.isArray(newValue)) {
                newValue.forEach(function(elem) {
                    header.appendChild(elem);
                });
            } else {
                header.appendChild(newValue);
            }
            backLink = header.querySelector('.ha-back-links');
            if (backLink) {
                header.classList.add('ha-stage-contains-back-links');
            } else {
                header.classList.remove('ha-stage-contains-back-links');
            }

            this._header = newValue;
        },

        get section() {
            return this._section;
        },

        set section(newValue) {
            var section = this.querySelector('section');
            if (!section) {
                section = this.ownerDocument.createElement('section');
                this.appendChild(section);
            }
            _updateAriaControls(this);
            while (section.firstElementChild) {
                section.removeChild(section.firstElementChild);
            }
            if (Array.isArray(newValue)) {
                newValue.forEach(function(elem) {
                    section.appendChild(elem);
                });
            } else {
                section.appendChild(newValue);
            }

            if (!this.collapsible) {
                section.classList.add('inner-visible');
            }

            this._section = newValue;
        },

        /**
         * Show the details of the stage if collapsible
         * When the user clicks to expand or show the details of the stage
         * @emits HA-STAGE#show
        */
        show: function() {
            if (this.collapsible && !this.open) {
                this.open = true;
                this.emit('show');
            }
        },

        /**
         * Closes the stage if collapsible
         * When the user clicks to collapse or hide the details of the stage
         * @emits HA-STAGE#close
        */
        close: function() {
            if (this.collapsible && this.open) {
                this.open = false;
                this.emit('close');
            }
        },

        postRender: function _() {
            _.super(this);
            a11y.addA11yFocus(this);
            var buttonToggle = this.querySelector('.btn-toggle');
            /* istanbul ignore if */
            if (buttonToggle) {
                this.removeChild(buttonToggle);
            }
            contentNode.storeCachedInput(this, _contentPropertyMap);
        }
    });

    return register('ha-stage', HAStage);
});


define('text!hui/step-flow/flow-step.html',[],function () { return '<template>\n    <section></section>\n    <footer></footer>\n</template>';});


define('hui/step-flow/flow-step',[
    'object-utils/classes',
    'register-component/v2/UIComponent',
    'register-component/v2/register',
    'register-component/template!./flow-step.html',
    '../core/utils',
    '../core/contentNode'
], function(classes, Component, register, template, utils, ContentNode) {
    'use strict';

    var FlowStep,
        getParent = function(self) {
            return utils.getComponentFromElement(self, 'HA-STEP-FLOW');
        },
        _replaceContent = function(component, selector, content) {
            var container = component.querySelector(selector),
                contentList = [].concat(content),
                oldContent = container && container.children || [];
            utils.removeNodesSafe(container, oldContent);
            utils.appendChildCollection(container, contentList);
        },
        contentPropertyMap = {
            'section': 'section',
            'footer': 'footer'
        };

    FlowStep = classes.createObject(Component, {
        init: function _() {
            var self = this;
            _.super(this);
            this._hideOnTransition = false;
            this._originalTop = null;
            if (!this.classList.contains('landing') && !this.classList.contains('confirmation')) {
                ContentNode.cacheInputContent(this, contentPropertyMap);
                this.template = template;
                this.stepType = 'default';
            } else {
                this._noCacheContent = true;
            }
            this.setupProperties({
                /**
                 * A unique identifier for this step within the step flow.
                 * @type {String}
                 */
                stepId: {},

                /**
                 * Flag indicating the "Save For Later" button should be displayed.
                 * @type {Boolean}
                 */
                showSaveForLaterButton: {
                    type: Boolean
                },

                /**
                 * The button text for the "Save For Later" button.
                 * @type {String}
                 */
                saveForLaterButtonText: {
                    type: String,
                    default: 'Save and Finish Later'
                },

                /**
                 * Text to use for the next button for this step only.
                 * Default is the label set for the step flow.
                 * @type {String}
                 */
                nextButtonText: {},

                /**
                 * Text to use for the previous button for this step only.
                 * Default is the label set for the step flow.
                 * @type {String}
                 */
                previousButtonText: {},

                /**
                 * Flag indicating whether to hide the step buttons in the footer.
                 * @type {Boolean}
                 */
                hideStepButtons: {
                    type: Boolean,
                    change: function(newValue) {
                        this._setButtonsHidden(newValue);
                    }
                },

                /**
                 * The title text for this step, also serves as the text displayed in the progress indicator.
                 * @type {String}
                 */
                titleText: {
                    type: String,
                    default: '',
                    change: function(newValue) {
                        var section = this._section,
                            title = section.querySelector('section>h1.step-title');
                        if (newValue) {
                            if (!title) {
                                title = this.ownerDocument.createElement('h1');
                                title.setAttribute('tabindex', '-1');
                                title.classList.add('step-title');
                                section.insertBefore(title, section.firstChild);
                            }
                            title.innerHTML = newValue;
                            this._titleNode = title;
                        } else if (title) {
                            utils.removeNodesSafe(this.section, title);
                            this._titleNode = null;
                        }
                        if (!this._progressIndicatorTextSet) {
                            this.emit('change-flow-step-progress-indicator-text', {
                                step: self,
                                progressIndicatorText: newValue
                            });
                        }
                    }
                },

                /**
                 * The subtitle for this step.
                 * @type {String}
                 */
                subtitleText: {
                    type: String,
                    default: '',
                    change: function(newValue) {
                        var section = this._section,
                            title = section.querySelector('section>h1.step-title'),
                            subtitle = section.querySelector('section>h3.step-subtitle');
                        if (newValue) {
                            if (!subtitle) {
                                subtitle = this.ownerDocument.createElement('h3');
                                subtitle.classList.add('step-subtitle');
                                if (title) {
                                    section.insertBefore(subtitle, title.nextSibling);
                                } else {
                                    section.insertBefore(subtitle, section.firstChild);
                                }
                            }
                            subtitle.innerHTML = newValue;
                            this._subtitleNode = subtitle;
                        } else if (subtitle) {
                            utils.removeNodesSafe(self, subtitle);
                            this._subtitleNode = subtitle;
                        }
                    }
                },

                /**
                 * If supplied this text will override the "titleText" displayed in the progress indicator.
                 * @type {String}
                 */
                progressIndicatorText: {
                    type: String,
                    default: this.getAttribute('titleText'),
                    change: function(newValue) {
                        this._progressIndicatorTextSet = newValue && newValue !== this.titleText;
                        this.emit('change-flow-step-progress-indicator-text', {
                            step: self,
                            progressIndicatorText: newValue
                        });
                    }
                },

                /**
                 * Flag indicating that the step is complete for display in the progress indicator.
                 * @type {Boolean}
                 */
                stepComplete: {
                    type: Boolean,
                    change: function(newValue) {
                        this.emit('change-flow-step-complete', {
                            step: self,
                            stepComplete: newValue
                        });
                    }
                },

                /**
                 * Flag indicating whether the step should be available to click in the progress indicator.
                 * @type {Boolean}
                 */
                stepAvailable: {
                    type: Boolean,
                    change: function(newValue) {
                        this.emit('change-flow-step-available', {
                            step: self,
                            stepAvailable: newValue
                        });
                    }
                },

                /**
                 * Flag indicating whether the progress indicator should be hidden for this step.
                 * @type {Boolean}
                 */
                hideProgressIndicator: {
                    type: Boolean
                },

                /**
                 * Flag indicating whether this step should be hidden in the progress indicator.
                 * @type {Boolean}
                 */
                hideProgressIndicatorItem: {
                    type: Boolean
                },

                /**
                 * Flag indicating whether custom buttons will be added to the step.  If false the default
                 * buttons will be added.
                 * @type {Boolean}
                 */
                useCustomButtons: {
                    type: Boolean
                }
            });

            this._btnListener = function(evt) {
                var btn = evt.target,
                    toStepId = btn.getAttribute('data-to-step-id');
                if (toStepId) {
                    self.swipeToById(toStepId,
                        btn.getAttribute('data-to-step-direction') !== 'down');
                } else if (btn.classList.contains('next-btn')) {
                    getParent(self).emit('next');
                    getParent(self).swipeToNext();
                } else if (btn.classList.contains('prev-btn')) {
                    getParent(self).emit('previous');
                    getParent(self).swipeToPrevious();
                } else if (btn.classList.contains('done-btn')) {
                    getParent(self).emit('done');
                    getParent(self).swipeToIndex(null);
                } else if (btn.classList.contains('save-for-later-btn')) {
                    self.emit('saveForLater', {
                        step: self
                    });
                }
            };
            var animationEndEvent = utils.getAnimationEventNames().animationend;
            this.listenTo(this, animationEndEvent, function(evt) {
                if (evt.target.tagName === 'HA-FLOW-STEP') {
                    if (this._hideOnTransition) {
                        this._hideOnTransition = false;
                        getParent(self)._doneOutTransition(self);
                    } else {
                        this._setFocus();
                        getParent(this)._setTransition(false);
                    }
                }
            });
        },

        get stepType() {
            return this._stepType;
        },

        set stepType(newValue) {
            if (newValue === 'landing' || newValue === 'confirmation') {
                this.hideProgressIndicatorItem = true;
                this.hideProgressIndicator = true;
                this.classList.remove('default');
                if (!this.classList.contains(newValue)) {
                    this.classList.add(newValue);
                }
                this._stepType = newValue;
            } else {
                this._stepType = 'default';
                this.classList.remove('landing');
                this.classList.remove('confirmation');
                this.classList.add('default');
            }
        },

        set section(content) {
            _replaceContent(this, 'section', content);
            this._addButtonListeners();
        },

        get section() {
            return this._section;
        },

        set content(content) {
            this._section.appendChild(content);
            this._content = content;
        },

        get content() {
            return this._content;
        },

        set footer(content) {
            _replaceContent(this, 'footer', content);
            this._addButtonListeners();
        },

        get footer() {
            return this._footer;
        },

        postRender: function _() {
            _.super(this);
            this._section = this.querySelector('section');
            this._footer = this.querySelector('footer');
            if (!this._noCacheContent) {
                ContentNode.storeCachedInput(this, contentPropertyMap);
            }
            this._addButtonListeners();
        },

        _setFocus: function() {
            var title = this.querySelector('.step-title');
            if (title) {
                title.focus();
            }
        },

        _setButtonsHidden: function(hidden) {
            var buttons = this.querySelectorAll('.step-flow-button'),
                button,
                i;
            if (buttons) {
                for (i = 0; i < buttons.length; i++) {
                    button = buttons.item(i);
                    if (hidden) {
                        button.classList.add('hide');
                    } else {
                        button.classList.remove('hide');
                    }
                }
            }
        },

        /**
         * @returns {Boolean} true if this step is a landing step.
         */
        isLanding: function() {
            return this.stepType === 'landing';
        },

        /**
         * Replaces this steps section element.
         * @argument {Element} newSection the new content for the section
         */
        replaceSection: function(newSection) {
            utils.removeNodesSafe(this, [this._section]);
            this._section = newSection;
            this.insertBefore(newSection, this.firstChild);
        },

        /**
         * Performs validation if there is a validator function.
         * @returns {Boolean} true if valid, false otherwise.
         */
        validate: function() {
            if (this.validator) {
                return this.validator.call(this);
            }
            return true;
        },

        /**
         * See StepFlow.swipeToIndex(idx)
         */
        swipeToIndex: function(idx) {
            getParent(this).swipeToIndex(idx);
        },

        /**
         * See StepFlow.swipeToIndex(stepId, forward)
         */
        swipeToById: function(stepId, forward) {
            getParent(this).swipeToById(stepId, forward);
        },

        /**
         * Initializes this step in the context of the parent step-flow.
         * @argument {Element} parent the parent step-flow.
         */
        initialize: function(parent) {
            if (this._initialized) {
                return;
            }
            if (!this.useCustomButtons) {
                this._createButtons(parent);
                this._setButtonsHidden(this.hideStepButtons);
            }
            this._initialized = true;
        },

        /**
         * Creates the default buttons for this step.
         * @argument {Element} parent the parent step-flow.
         */
        _createButtons: function(parent) {
            var steps = parent.getStepsArray(),
                found = steps.indexOf(this),
                self = this,
                labelFor = function(propertyName) {
                    return self[propertyName] ? self[propertyName] : parent[propertyName];
                };
            if (found < 0) {
                return;
            }
            if (found > 0 && this.stepType === 'default') {
                this._createButton(labelFor('previousButtonText'), ['prev-btn', 'ha-button-secondary']);
            }
            if (found === steps.length - 1) {
                this._createButton(parent.doneButtonText, ['done-btn', 'ha-button-primary']);
            } else {
                this._createButton(labelFor('nextButtonText'), ['next-btn', 'ha-button-primary']);
            }
            if (this.showSaveForLaterButton) {
                this._createButton(this.saveForLaterButtonText, ['save-for-later-btn', 'ha-button-secondary']);
            }
            this._addButtonListeners();
        },

        /**
         * Create and append a button to this step.
         * @argument {String} text for the button.
         * @argument {Array} classes list of classes to be added to the class list.
         */
        _createButton: function(text, classes) {
            var button = this.ownerDocument.createElement('button');
            button.classList.add('ha-button');
            button.classList.add('step-flow-button');
            classes.forEach(function(clz) {
                button.classList.add(clz);
            });
            button.innerHTML = text;
            this._footer.appendChild(button);
        },

        /**
         * Add button listeners to any buttons in this step with a "step-flow-button" class.
         */
        _addButtonListeners: function() {
            var self = this,
                btns = Array.prototype.slice.call(
                    this.querySelectorAll('button.step-flow-button'));

            if (btns) {
                btns.forEach(function(btn) {
                    self.listenTo(btn, 'click', self._btnListener);
                });
            }
        },

        /**
         * Setup step for transition into view (sliding in).
         */
        _setup: function() {
            this.classList.remove('slide-in-next');
            this.classList.remove('slide-in-back');
            this.classList.remove('slide-out-next');
            this.classList.remove('slide-out-back');
            this.classList.remove('slide-out-next-delayed');
            this.classList.remove('slide-out-back-delayed');
        },

        /**
         * Perform transition in.
         * @argument {Boolean} forward
         */
        _swipeIn: function(forward) {
            this._saveOriginal(this);
            this._setup();
            this.parentElement.scrollTop = 0;
            if (forward) {
                this.classList.add('slide-in-next');
            } else {
                this.classList.add('slide-in-back');
            }
            this.stepAvailable = true;
        },

        /**
         * Perform transition out.
         * @argument {Boolean} forward
         * @argument {Boolean} delayed if true, used the delayed animation
         */
        _swipeOut: function(forward, delayed) {
            this._setup();
            if (forward) {
                this.classList.add(delayed ? 'slide-out-next-delayed' : 'slide-out-next');
            } else {
                this.classList.add(delayed ? 'slide-out-back-delayed' : 'slide-out-back');
            }
            this._hideOnTransition = true;
        },

        /**
         * Save original parameters for this step.
         */
        _saveOriginal: function() {
            if (this._originalTop === null) {
                this._originalTop = this.getBoundingClientRect().top -
                    getParent(this).getBoundingClientRect().top;
            }
        }
    });

    return register('ha-flow-step', FlowStep);
});


define('text!hui/step-flow/step-flow-progress-indicator-step.html',[],function () { return '<div class="prog-container">\n    <button class="prog-circle" disabled="true">\n        <div class="prog-step-number">{{stepNumber}}</div>\n        <div  aria-label="Go back to the completed step {{stepNumber}}" class="prog-check hi hi-checkmark"></div>\n    </button>\n    <div class="prog-step-name">{{stepName}}</div>\n</div>';});



define('text!hui/step-flow/step-flow-progress-indicator-bar.html',[],function () { return '<div class="mobile-step-indicator">\n    <div class="mobile-step-title"></div>\n    <div class="mobile-step-number"></div>\n</div>\n<div class="mobile-prog-bar">\n\t<div class="mobile-prog-bar-complete" style="width: 0%;"></div>\n</div>';});


define('hui/step-flow/step-flow-progress-indicator',[
    'object-utils/classes',
    'register-component/v2/UIComponent',
    'register-component/v2/register',
    'register-component/template!./step-flow-progress-indicator-step.html',
    'register-component/template!./step-flow-progress-indicator-bar.html',
    '../core/utils'
], function(classes, Component, register, template, barTemplate, Utils) {
    'use strict';

    var ProgressIndicator,
        getParent = function(self) {
            return Utils.getComponentFromElement(self, 'HA-STEP-FLOW');
        };

    ProgressIndicator = classes.createObject(Component, {
        init: function _() {
            _.super(this);

            this.setupProperties({
                /**
                 * Flag indicating whether progress indicator steps should trigger navigation on click.
                 * @type {Boolean}
                 */
                disableNavigation: {
                    type: Boolean
                }
            });
        },

        initialize: function(parent) {
            var self = this,
                steps = parent.getStepsArray(),
                stepNum = 1,
                progressItemElement,
                progressBarElement,
                progressId,
                totalProgressIndicatorSteps,
                i,
                wrap = function(funcName) {
                    return function() {
                        self[funcName].apply(self, arguments);
                    };
                };

            this._setVisible(false);
            this._stepFlow = parent;
            this._progressItems = {};

            totalProgressIndicatorSteps = steps.filter(function(step) {
                return !step.hideProgressIndicatorItem;
            }).length;
            progressBarElement = this.ownerDocument.createElement('div');
            progressBarElement.innerHTML = barTemplate();
            progressBarElement.classList.add('mobile-progress-indicator');

            this.appendChild(progressBarElement);
            this._progressBar = progressBarElement;
            this._progressIndicatorSteps = totalProgressIndicatorSteps;

            for (i = 0; i < steps.length; i++) {
                if (steps[i].hideProgressIndicatorItem) {
                    continue;
                }
                progressId = i + '';
                progressItemElement = this.ownerDocument.createElement('div');
                progressItemElement.setAttribute('data-progress-id', progressId);
                progressItemElement.setAttribute('data-progress-step-number', stepNum);
                progressItemElement.innerHTML = template({
                    stepNumber: stepNum++,
                    stepName: steps[i].progressIndicatorText ? steps[i].progressIndicatorText : steps[i].titleText
                });
                progressItemElement.classList.add('progress-indicator-step');

                this.listenTo(progressItemElement.querySelector('.prog-container'), 'click', wrap('_onProgressItemClick'));
                this.listenTo(steps[i], 'change-flow-step-progress-indicator-text', wrap('_onChangeProgressIndicatorText'));
                this.listenTo(steps[i], 'change-flow-step-complete', wrap('_onChangeFlowStepComplete'));
                if (steps[i].stepComplete) {
                    progressItemElement.classList.add('completed');
                }
                this.listenTo(steps[i], 'change-flow-step-available', wrap('_onChangeFlowStepAvailable'));
                if (steps[i].stepAvailable) {
                    progressItemElement.classList.add('available');
                }

                this.appendChild(progressItemElement);

                this._progressItems[progressId] = progressItemElement;
                steps[i].setAttribute('data-progress-id', progressId);
            }

            this.listenTo(parent, 'before-step', wrap('_onBeforeStep'));
            this.listenTo(parent, 'after-step', wrap('_onAfterStep'));
        },

        reset: function() {
            var self = this;
            Object.keys(this._progressItems).forEach(function(k) {
                var item = self._progressItems[k];
                item.classList.remove('selected');
            });
            this._setVisible(false);
        },

        _getItemFromStep: function(step) {
            var progressId = step.getAttribute('data-progress-id');
            return this._progressItems[progressId];
        },

        _onProgressItemClick: function(evt) {
            var progressItem = evt.currentTarget.parentElement,
                progressId = progressItem.getAttribute('data-progress-id'),
                i,
                steps;

            if (!this.disableNavigation &&
                !this.classList.contains('hide-progress-indicator') &&
                !progressItem.classList.contains('selected') && progressId && progressId !== '') {
                steps = getParent(this).getStepsArray();
                for (i = 0; i < steps.length; i++) {
                    if (steps[i].stepAvailable && steps[i].getAttribute('data-progress-id') === progressId) {
                        getParent(this).swipeToAutoForward(steps[i]);
                        break;
                    }
                }
            }
        },

        _onBeforeStep: function(evt) {
            if (evt) {
                var progressItem;
                if (evt.fromStep) {
                    progressItem = this._getItemFromStep(evt.fromStep);
                    if (progressItem) {
                        progressItem.classList.remove('selected');
                    }
                } else if (evt.toStep) {
                    // If !evt.fromStep, this is the first time the step-flow is being shown.
                    progressItem = this._getItemFromStep(evt.toStep);
                    if (progressItem) {
                        progressItem.classList.add('selected');
                    }
                    if (evt.toStep.hideProgressIndicator && !this.classList.contains('hide-progress-indicator')) {
                        this._setVisible(false);
                    } else {
                        this._setVisible(true);
                    }
                }

                if (evt.toStep && evt.toStep.hideProgressIndicator) {
                    this._setVisible(false);
                } else {
                    this._setVisible(true);
                }
                // Update mobile progress bar indicator
                if (evt.toStep && !evt.toStep.hideProgressIndicator) {
                    progressItem = this._getItemFromStep(evt.toStep);
                    this._progressBar.querySelector('.mobile-step-title').textContent = evt.toStep.titleText;
                    this._progressBar.querySelector('.mobile-step-number').textContent =  progressItem.getAttribute('data-progress-step-number') + ' ' + this.parentElement.mobileProgressIndicatorText + ' ' + this._progressIndicatorSteps;
                    var completePercent = 100 * progressItem.getAttribute('data-progress-step-number') / this._progressIndicatorSteps;
                    this._progressBar.querySelector('.mobile-prog-bar-complete').style.width =  completePercent + '%';
                }
            }
        },

        _setVisible: function(visible) {
            if (visible) {
                this.classList.remove('hide');
                this.classList.remove('hide-progress-indicator');
                this.setAttribute('aria-hidden', false);
            } else {
                this.setAttribute('aria-hidden', true);
                this.classList.add('hide-progress-indicator');
            }
        },

        _onAfterStep: function(evt) {
            if (evt && evt.toStep) {
                var progressItem = evt && evt.toStep && this._getItemFromStep(evt.toStep);
                if (progressItem) {
                    progressItem.classList.add('selected');
                }
            }
        },

        _onChangeProgressIndicatorText: function(evt) {
            if (evt && evt.step) {
                var progressText = this._getItemFromStep(evt.step).querySelector('.prog-step-name'),
                    mobileProgessText = this._progressBar.querySelector('.mobile-step-title');
                progressText.textContent = evt.progressIndicatorText;
                mobileProgessText.textContent = evt.progressIndicatorText;
            }
        },

        _onChangeFlowStepComplete: function(evt) {
            if (evt && evt.step) {
                var progressItem = this._getItemFromStep(evt.step);
                if (progressItem) {
                    if (evt.stepComplete) {
                        progressItem.classList.add('completed');
                    } else {
                        progressItem.classList.remove('completed');
                    }
                }
            }
        },

        _onChangeFlowStepAvailable: function(evt) {
            if (evt && evt.step) {
                var progressItem = this._getItemFromStep(evt.step),
                    button;
                if (progressItem) {
                    button = progressItem.querySelector('button');
                    if (evt.stepAvailable) {
                        progressItem.classList.add('available');
                        button.removeAttribute('disabled');
                    } else {
                        progressItem.classList.remove('available');
                        button.setAttribute('disabled', 'true');
                    }
                }
            }
        }
    });

    return register('ha-step-flow-progress-indicator', ProgressIndicator);
});

define('hui/step-flow/flow-landing',[
    'object-utils/classes',
    'register-component/v2/UIComponent',
    'register-component/v2/register',
    '../core/utils',
    '../core/contentNode'
], function(classes, Component, register, Utils) {
    'use strict';

    var FlowLanding = classes.createObject(Component, {
        set content(customContent) {
            var content = customContent instanceof Array ? customContent : [customContent];
            this._section = this.querySelector('section');
            if (!this._section) {
                this._section = this.ownerDocument.createElement('section');
                this.appendChild(this._section);
            }
            Utils.appendChildCollection(this._section, content);
        },

        get content() {
            return this._section;
        }
    });

    return register('ha-flow-landing', FlowLanding);
});


define('text!hui/step-flow/flow-confirmation.html',[],function () { return '<section>\n    <div class="confirm-check hi hi-circle-check"></div>\n    <h1 class="step-title" tabindex="-1">{{titleText}}</h1>\n    <h3 class="step-subtitle">{{subtitleText}}</h3>\n</section>\n';});


define('hui/step-flow/flow-confirmation',[
    'object-utils/classes',
    'register-component/v2/UIComponent',
    'register-component/v2/register',
    'register-component/template!./flow-confirmation.html',
    '../core/utils',
    '../core/contentNode'
], function(classes, Component, register, template, Utils, ContentNode) {
    'use strict';

    var contentPropertyMap = {'section': 'content'},
        FlowConfirmation;

    FlowConfirmation = classes.createObject(Component, {
        init: function _() {
            var self = this;
            _.super(this);
            this.setupProperties({
                titleText: {},
                subtitleText: {}
            });
            if (!this.classList.contains('processed')) {
                ContentNode.cacheInputContent(this, contentPropertyMap);
                this.template = function() {
                    return template({
                        titleText: self.titleText,
                        subtitleText: self.subtitleText
                    });
                };
            }
        },

        set content(customContent) {
            var content = customContent instanceof Array ? customContent : [customContent];
            Utils.appendChildCollection(this._section, content);
        },

        get content() {
            return this._section;
        },

        postRender: function _() {
            _.super(this);
            this._section = this.querySelector('section');
            if (!this.classList.contains('processed')) {
                ContentNode.storeCachedInput(this, contentPropertyMap);
                this.classList.add('processed');
            }
        }
    });

    return register('ha-flow-confirmation', FlowConfirmation);
});

define('hui/step-flow',[
    'object-utils/classes',
    'register-component/v2/UIComponent',
    'register-component/v2/register',
    './core/utils',
    './step-flow/flow-step',
    './step-flow/step-flow-progress-indicator',
    './step-flow/flow-landing',
    './step-flow/flow-confirmation'
], function(classes, Component, register, utils) {
    'use strict';

    var animationEndEvent, StepFlow;

    animationEndEvent = utils.getAnimationEventNames().animationend;

    StepFlow = classes.createObject(Component, {
        init: function _() {
            var self = this;
            _.super(this);

            this._steps = [];
            this._visible = false;
            this._currentStep = null;
            this._currentIdx = -1;

            this.setupProperties({
                /**
                 * Flag indicating whether the progress indicator should be visible.
                 * @type {Boolean}
                 */
                progressIndicator: {
                    type: Boolean,
                    default: false,
                    change: function(value) {
                        if (value) {
                            if (!this._progressIndicator) {
                                this._progressIndicator = this.ownerDocument.createElement('ha-step-flow-progress-indicator');
                                this._progressIndicator.disableNavigation = this.disableProgressIndicatorNavigation;
                                this.insertBefore(this._progressIndicator, this.firstChild);
                                if (this._visible) {
                                    this._initializeProgressIndicator();
                                    this._progressIndicator._setVisible(true);
                                }
                            }
                            this.classList.add('with-progress');
                        } else if (this._progressIndicator) {
                            utils.removeNodesSafe(this, [this._progressIndicator]);
                            this._progressIndicator = null;
                            this._progressIndicatorInitialized = false;
                            this.classList.remove('with-progress');
                        }
                    }
                },

                /**
                 * Flag indicating whether progress indicator steps should trigger navigation on click.
                 * @type {Boolean}
                 */
                disableProgressIndicatorNavigation: {
                    type: Boolean,
                    change: function(value) {
                        if (this._progressIndicator) {
                            this._progressIndicator.disableNavigation = value;
                        }
                    }
                },

                /**
                 * Type of flow, "linear" (default) or "non-linear".
                 * @type {String}
                 */
                flow: {
                    type: String,
                    default: 'linear',
                    change: function(newValue) {
                        this.steps.forEach(function(step) {
                            step.stepAvailable = step.stepAvailable || newValue !== 'linear';
                        });
                    }
                },

                /**
                 * Flag indicating whether steps should not be automatically set to complete once validation passes.
                 * @type {Boolean}
                 */
                disableAutoComplete: {
                    type: Boolean
                },

                /**
                 * Enables slide in of step flow component.
                 * @type {Boolean}
                 */
                enableAnimateIn: {
                    type: Boolean
                },

                /**
                 * If true, the parent trowser will close when this step flow is closed.
                 * @type {Boolean}
                 */
                closeParentTrowser: {
                    type: Boolean
                },

                /**
                 * Text to use for the next button, default to "Next"
                 * @type {String}
                 */
                nextButtonText: {
                    default: 'Next'
                },

                /**
                 * Text to use for the previous button, default to "Previous"
                 * @type {String}
                 */
                previousButtonText: {
                    default: 'Previous'
                },

                /**
                 * Text to use for the done button, default to "Done"
                 * @type {String}
                 */
                doneButtonText: {
                    default: 'Done'
                },

                /**
                 * Text to use for the mobile progress indicator, default to "of"
                 * @type {String}
                 */
                mobileProgressIndicatorText: {
                    default: 'of'
                },

                /**
                 * Number to use if initialize step-flow with {startIndex}, default to 0.
                 * @type {Integer}
                 */
                startIndex: {
                    default: 0
                }
            });

            this.listenTo(this, animationEndEvent, function(evt) {
                var animationName = evt.animationName;

                if (animationName === 'ha-step-flow-vertical-out') {
                    self.classList.remove('shown');
                }
                if (animationName === 'ha-step-flow-vertical-in' && this._currentStep === null) {
                    self.swipeToIndex(0);
                    self.classList.remove('vertical-in');
                }
                if (animationName === 'ha-step-progress-indicator-fade-out') {
                    self.querySelector('ha-step-flow-progress-indicator').classList.add('hide');
                }
                if (animationName === 'ha-step-flow-bg-step') {
                    self.classList.remove('landing');
                    self.classList.remove('landing-out');
                }

                if (animationName === 'ha-step-flow-bg-landing') {
                    self.classList.add('landing');
                    self.classList.remove('landing-in');
                }
            });
        },

        set steps(content) {
            var self = this,
                toAdd = [];

            utils.removeNodesSafe(self, this._steps);
            content.forEach(function(e) {
                if (e.tagName === 'HA-FLOW-STEP') {
                    self.appendChild(e);
                    if (e.classList.contains('landing')) {
                        self._landingStep = e;
                        self._landing = e.querySelector('ha-flow-landing');
                    } else if (e.classList.contains('confirmation')) {
                        self._confStep = e;
                        self._confirmation = e.querySelector('ha-flow-confirmation');
                    } else {
                        e.stepAvailable = e.stepAvailable || self.flow !== 'linear';
                        toAdd.push(e);
                    }
                }
            });
            this._steps = toAdd;
        },

        get steps() {
            return this._steps;
        },

        set landing(flowLanding) {
            this._landingStep = this.ownerDocument.createElement('ha-flow-step');
            this._landingStep.replaceSection(flowLanding);
            this._landingStep.stepType = 'landing';
            this._landing = flowLanding;
            this.insertBefore(this._landingStep, this.querySelector('ha-flow-step'));
        },

        get landing() {
            return this._landing;
        },

        set confirmation(flowConfirmation) {
            this._confStep = this.ownerDocument.createElement('ha-flow-step');
            this._confStep.stepType = 'confirmation';
            this._confirmation = flowConfirmation;
            this._confStep.replaceSection(this._confirmation);
            this.appendChild(this._confStep);
        },

        get confirmation() {
            return this._confirmation;
        },

        attachedCallback: function _() {
            _.super(this);

            var pageModal = utils.getComponentFromElement(this, 'HA-PAGE-MODAL');

            if (utils.isNode(pageModal)) {
                // The ancestor page modal needs to know that it is hosting
                // a step-flow so that special styling can be applied after
                // the page modal has been detached from a trowser
                pageModal.classList.add('step-flow');
            }
        },

        postRender: function _() {
            var landing = this._getChildByTag('ha-flow-landing'),
                confirmation = this._getChildByTag('ha-flow-confirmation'),
                temp = this.querySelectorAll('ha-flow-step') || [];
            _.super(this);

            this.steps = Array.prototype.slice.call(temp);

            if (landing) {
                this.landing = landing;
            }
            if (confirmation) {
                this.confirmation = confirmation;
            }
        },

        /**
         * Makes the step flow visible.
         * @emits show
         */
        show: function() {
            this._initializeProgressIndicator();

            if (!this._visible) {
                this.classList.remove('vertical-out');
                this.classList.add('shown');

                if (this.enableAnimateIn) {
                    this.classList.add('vertical-in');
                } else if (this._currentStep === null) {
                    this.swipeToIndex(this.startIndex || 0);
                }

                this._visible = true;
                this.emit('show');
            }
        },

        /**
         * Closes this step flow retaining the current state.
         * @emits close
         */
        close: function() {
            if (this._visible) {
                if (this.closeParentTrowser) {
                    var parent = utils.getComponentFromElement(this, 'HA-TROWSER');
                    if (parent) {
                        parent.close();
                        this.classList.remove('shown');
                    }
                }
                this.classList.remove('vertical-in');
                this.classList.add('vertical-out');
                this._visible = false;
                this.emit('close');
                this._reset();
            }
        },

        /**
         * Swipe to the next step in the flow.
         */
        swipeToNext: function() {
            this.swipeToIndex(this._currentIdx + 1, true);
        },

        /**
         * Swipe to the previous step in the flow.
         */
        swipeToPrevious: function() {
            this.swipeToIndex(this._currentIdx - 1, false);
        },

        /**
         * Swipe to a step using a "stepId"
         *
         * @argument {String} stepId the "stepId" of the step to navigate to.
         * @argument {Boolean} forward true for forward, false for backward.
         */
        swipeToById: function(stepId, forward) {
            var stepIdx = this._findById(stepId);
            this.swipeToIndex(stepIdx, forward);
        },
        /**
         * Swipe to a step using a "stepId" automatically determining if it is
         * forward or backward based on the step's position.
         *
         * @argument {String} stepId the "stepId" of the step to navigate to.
         */
        swipeToAutoForward: function(stepId) {
            var stepIdx = this.getStepsArray().indexOf(stepId);
            this.swipeToIndex(stepIdx, stepIdx > this._currentIdx);
        },

        /**
         * Swipe to a step using the step's index.
         *
         * @argument {Number} idx the index of the step to navigate to.
         * @argument {Boolean} forward true for forward, false for backward.
         */
        swipeToIndex: function(idx, forward) {
            var self = this,
                validateResult,
                navigateToNext = function() {
                    self._setTransition(true);
                    if (self._currentStep && forward && !self.disableAutoComplete) {
                        self._currentStep.stepComplete = true;
                        self._currentStep.stepAvailable = true;
                    }
                    if (idx !== null) {
                        self._gotoStep(idx, forward);
                    } else {
                        self._swipeBusy = false;
                        self.close();
                    }
                };

            if (this._swipeBusy) {
                return;
            }

            this._swipeBusy = true;

            if (this._currentStep && forward) {
                validateResult = this._currentStep.validate();

                if (!validateResult) {
                    /// Validation failed right away
                    this._swipeBusy = false;
                    return;
                } else if (this._isPromise(validateResult)) {
                    // Validation done using promise.
                    this._startSpinner('validate', this._currentStep);
                    validateResult.then(function(valid) {
                        if (valid) {
                            navigateToNext();
                        } else {
                            self._stopSpinner('validate', self._currentStep);
                            self._swipeBusy = false;
                        }
                        return valid;
                    }, function() {
                        self._stopSpinner('validate', self._currentStep);
                        self._swipeBusy = false;
                        return false;
                    });
                    return;
                }
            }

            // Validation succeeded right away or no need to validate
            navigateToNext();
        },

        /**
         * @returns {Array} an array of all steps in order including the landing and confirmation.
         */
        getStepsArray: function() {
            var steps = [];
            if (this._landingStep) {
                steps.push(this._landingStep);
            }
            steps = steps.concat(this._steps);
            if (this._confStep) {
                steps.push(this._confStep);
            }
            return steps;
        },

        _initializeProgressIndicator: function() {
            if (this._progressIndicator && !this._progressIndicatorInitialized) {
                this._progressIndicator.initialize(this);
                this._progressIndicatorInitialized = true;
            }
        },

        /**
         * @argument {String}  tagName the tag name to search for.
         * @returns  {Element} the first direct child of this element matching the "tagName" or null
         *                     if one is not found.
         */
        _getChildByTag: function(tagName) {
            var list = this.querySelectorAll(tagName),
                i;
            for (i = 0; i < list.length; i++) {
                if (list[i].parentElement === this) {
                    return list[i];
                }
            }
            return null;
        },

        /**
         * Resets the step flow to initial state.
         */
        _reset: function() {
            this._currentStep = null;
            this._currentIdx = -1;
            this.getStepsArray().forEach(function(step) {
                step.style.visibility = 'hidden';
                step.stepComplete = false;
                step.stepAvailable = false;
            });
            if (this._progressIndicator) {
                this._progressIndicator.reset();
            }
        },

        /**
         * Find a flow-step with the matching "stepId".
         *
         * @argument {String} stepId the "stepId" of the flow-step being searched for.
         * @returns {Element}   the flow-step with the matching stepId or null if not found.
         */
        _findById: function(stepId) {
            var i,
                steps = this.getStepsArray() || [];
            for (i = 0; i < steps.length; i++) {
                if (steps[i].stepId === stepId) {
                    return i;
                }
            }
            return -1;
        },

        /**
         * Called when transition to a step is complete.
         *
         * @argument {Element} step the previous flow-step
         * @emits after-step
         */
        _doneOutTransition: function(step) {
            this.emit('after-step', {
                fromStep: step,
                toStep: this._currentStep
            });
            this._swipeBusy = false;
            // workaround for IE11 here, since the flow step animationEndEvent IE11 just do once, but other browsers do twice;
            // so the transition class has not been removed which cause flow-step content not scrollable in IE11.
            this._setTransition(false);
        },

        /**
         *  Determines if a given value is a promise.
         *  @argument {Object} value
         *  @returns  {Boolean} true if "value" is a promise, false otherwise.
         */
        _isPromise: function(value) {
            return value && typeof value.then === 'function' ?
                true : false;
        },

        _setTransition: function(on) {
            if (on) {
                this.classList.add('transition');
            } else {
                this.classList.remove('transition');
            }
        },

        _setBackground: function(step) {
            if (!this._currentStep && step.isLanding()) {
                this.classList.add('landing');
            } else if (this._currentStep) {
                if (this._currentStep.isLanding() && !step.isLanding()) {
                    this.classList.add('landing-out');
                } else if (step.isLanding() && !this._currentStep.isLanding()) {
                    this.classList.add('landing-in');
                }
            }
        },

        /**
         * Peform the navigation to a flow step including any validation and evaluating
         * any prerequisite promises.
         *
         * @argument {Number} idx the index of the step to navigate to.
         * @argument {Boolean} forward true for forward navigation, false for backward.
         * @emits before-step
         */
        _gotoStep: function(idx, forward) {
            var step = this.getStepsArray()[idx],
                self = this,
                performSwipe = function() {
                    var delayed = self._currentStep &&
                        (self._currentStep.isLanding() ||
                            step && step.isLanding());
                    if (self._currentStep) {
                        self._currentStep._swipeOut(forward, delayed);
                        self._stopSpinner('validate', self._currentStep);
                    }

                    setTimeout(function() {
                        step.initialize(self);
                        self.emit('before-step', {
                            fromStep: self._currentStep,
                            toStep: step
                        });
                        step._swipeIn(forward);
                        self._currentStep = step;
                        self._currentIdx = idx;
                        self._swipeBusy = false;
                    }, delayed ? 250 : 0);
                },
                beforeShow;

            if (!step) {
                return;
            }

            this._setBackground(step);

            if (step.beforeShowPromise) {
                beforeShow = typeof step.beforeShowPromise === 'function' ?
                    step.beforeShowPromise() :
                    step.beforeShowPromise;
            }

            if (this._isPromise(beforeShow)) {
                this._startSpinner('before-show', step);
                beforeShow.then(function() {
                    performSwipe();
                    self._stopSpinner('before-show', step);
                    return true;
                }, function() {
                    self._stopSpinner('before-show', step);
                    self._swipeBusy = false;
                    return false;
                });
            } else {
                // No promise so swipe right away
                performSwipe();
            }
        },

        /**
         * @returns {Element} the spinner element for this step flow, if one
         *                    does not exist it is created and appended.
         */
        _getSpinner: function() {
            var spinner = this.querySelector('div.ha-step-flow-spinner');
            if (!spinner) {
                spinner = this.ownerDocument.createElement('div');
                spinner.appendChild(this.ownerDocument.createElement('div'));
                spinner.classList.add('ha-step-flow-spinner');
                this.appendChild(spinner);
            }
            return spinner;
        },

        /**
         * Starts the spinner.
         *
         * @argument {String} reason reason for the spinner starting which is included in the event.
         * @argument {Element} step step for which the spinner was launched.
         * @emits start-spinner
         */
        _startSpinner: function(reason, step) {
            var spinner = this._getSpinner();
            spinner.style.top = -this.getBoundingClientRect().top + 'px';
            spinner.classList.add('spinner-show');
            this.emit('start-spinner', {
                reason: reason,
                step: step
            });
        },

        /**
         * Stop the spinner.
         *
         * @argument {String} reason reason for the spinner stopping which is included in the event.
         * @argument {Element} step step for which the spinner was launched.
         * @emits stop-spinner
         */
        _stopSpinner: function(reason, step) {
            var spinner = this._getSpinner();
            spinner.classList.remove('spinner-show');
            this.emit('stop-spinner', {
                reason: reason,
                step: step
            });
        }
    });

    return register('ha-step-flow', StepFlow);
});

define('hui/core/timeUtils',[], function() {
    return {
        _isoRegex: /^(?:(\d{4})(?:-(\d{2})(?:-(\d{2}))?)?)?(?:T(\d{2}):(\d{2})(?::(\d{2})(.\d+)?)?((?:[+-](\d{2}):(\d{2}))|Z)?)?$/,

        /**
         * Parses an ISO date string, and return a Date object, or false if the
         * string doesn't match the ISO format
         * @param {String} dateString
         *
         */
        parseISODateString: function(dateString) {
            var match = this._isoRegex.exec(dateString),
                result = null,
                offset = 0,
                zoneSign;

            if (match) {
                match.shift();
                // Javascript Date months are 0-based
                if (match[1]) {
                    match[1]--;
                }
                result = new Date(match[0] || 1970, match[1] || 0, match[2] || 1, match[3] || 0, match[4] || 0, match[5] || 0);
                if (match[0] < 100) {
                    result.setFullYear(match[0] || 1970);
                }

                offset = 0;
                zoneSign = match[7] && match[7].charAt(0);
                if (zoneSign !== 'Z') {
                    offset = ((match[8] || 0) * 60) + (Number(match[9]) || 0);
                    if (zoneSign !== '-') {
                        offset *= -1;
                    }
                }
                if (zoneSign) {
                    offset -= result.getTimezoneOffset();
                }
                if (offset) {
                    result.setTime(result.getTime() + offset * 60000);
                }
            }

            return result;
        },

        /**
         * Pads a day or month string to some number of digits, adding a leading 0 if needed
         * @param {string | number} value A one or two character string or a number, representing a day or month
         * @param {number}  length        Optional value specifying the number of digits to pad to. Default is 2.
         * @returns {string} A padded version of the day or month value
         */
        pad: function(value, length) {
            var padded = String(value),
                padLength = length || 2;

            while (padded.length < padLength) {
                padded = '0' + padded;
            }

            return padded;
        },

        /**
         * Formats a Date object in YYYY-MM-DD format
         * @param {Date} dateValue A Date object to format
         * @returns {String} An empty string of the date object is in an instance of Date, and the formatted date string
         * otherwise
         */
        formatDateAsEsDateString: function(dateValue) {
            if (!(dateValue instanceof Date)) {
                return '';
            }

            return dateValue.getFullYear() + '-' + this.pad(dateValue.getMonth() + 1) + '-' + this.pad(dateValue.getDate());
        },

        /**
         * Formats a Date object based on the supplied date pattern.
         * @param {Date} dateObject A Date object to format
         * @param {String} pattern A String representing the targeted date pattern
         * @returns {String} A string representing the matched target date format
         */
        formatDateAsPattern: function(dateObject, pattern) {
            return pattern.replace(/([a-z])\1*/ig, function(match) {
                var s, pad,
                    c = match.charAt(0),
                    l = match.length;
                switch (c) {
                    case 'y':
                        s = dateObject.getFullYear();
                        switch (l) {
                            case 1:
                                break;
                            case 2:
                                s = String(s);
                                s = s.substr(s.length - 2);
                                pad = true;
                                break;
                            default:
                                pad = true;
                        }
                        break;
                    case 'm':
                        var m = dateObject.getMonth();
                        if (l < 3) {
                            s = m + 1;
                            pad = true;
                        }
                        break;
                    case 'd':
                        s = dateObject.getDate();
                        pad = true;
                        break;
                }

                if (pad) {
                    s = this.pad(s, l);
                }
                return s;
            }.bind(this));
        },

        /**
         * Date comparison based on year and month.
         * @param {Date}          date1  First date Object
         * @param {Date}          date2  Second date Object
         * @returns {number}      return 0 means date1 same as date2,
         *                        return 1 means date1 greater than date2,
         *                        return -1 means date1 less than date2.
         */
        compareDateWithoutDay: function(date1, date2) {
            var tempDate1 = new Date(date1),
                tempDate2 = new Date(date2),
                result = tempDate1.setDate(1) - tempDate2.setDate(1);
            return result === 0 ? 0 : result > 0 ? 1 : -1;
        },

        parsePatternAsDate: function(pattern, value) {
            if (!pattern) {
                return new Date(value);
            }

            var info = this.regExForPattern(pattern),
                matchPositions = info.matchPositions,
                regEx = info.regEx,
                matches = value.match(regEx);

            if (matches) {
                var date = new Date(),
                    month = (matchPositions.m && parseInt(matches[matchPositions.m])) || (date.getMonth() + 1),
                    day = (matchPositions.d && parseInt(matches[matchPositions.d])) || date.getDate(),
                    year = (matchPositions.y && parseInt(matches[matchPositions.y])) || date.getFullYear();

                return new Date(year, month - 1, day);
            }

            return new Date('');
        },

        regExForPattern: function(pattern) {
            var matchPositions = {},
                position = 1,
                regEx = new RegExp(('^' + pattern.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&') + '$').replace(/([a-z])\1*/ig, function(match) {
                    var c = match.charAt(0),
                        l = match.length;

                    switch (c) {
                        case 'm':
                        case 'y':
                        case 'd':
                            matchPositions[c] = position++;
                            return '(\\d{' + l + '})';
                    }

                    return match;
                }));

            return {
                regEx: regEx,
                matchPositions: matchPositions
            };
        }
    };
});

define('text!hui/date-picker/calendar.html',[],function () { return '<template>\n    <div class="ha-calendar-main-div" role="presentation">\n        <div class="ha-calendar-navigation" role="presentation">\n            <div class="ha-calendar-previous-month hi hi-chevron-left" tabindex="0"\n                 aria-describedby="dates-navigation{{componentId}}" id="decrementMonth{{componentId}}" role="button"\n                 aria-label="Go to previous month">\n            </div>\n            <div class="ha-calendar-next-month hi hi-chevron-right" tabindex="0"\n                 aria-describedby="dates-navigation{{componentId}}" id="incrementMonth{{componentId}}" role="button"\n                 aria-label="Go to next month">\n            </div>\n            <div aria-live="assertive" class="ha-calendar-month-display" id="monthAndYearNode{{componentId}}"></div>\n        </div>\n        <table aria-labelledby="monthAndYearNode{{componentId}}" tabindex="0" cellspacing="0" cellpadding="0"\n               id="gridNode{{componentId}}">\n            <thead>\n            <tr id="dayCellsNode{{componentId}}">\n            </tr>\n            </thead>\n            <tbody id="dateRowsNode{{componentId}}">\n            </tbody>\n        </table>\n        <div class="ha-calendar-year-navigation">\n            <span class="ha-calendar-previous-year" role="button" tabindex="0" aria-label="Go to previous year"\n                    aria-describedby="dates-navigation{{componentId}}">\n            </span>\n            <span aria-live="assertive" class="ha-calendar-current-year">\n            </span>\n            <span class="ha-calendar-next-year" role="button" tabindex="0" aria-label="Go to next year"\n                    aria-describedby="dates-navigation{{componentId}}">\n            </span>\n        </div>\n        <span class="sr-only selectionAlertNode"></span>\n        <div class="sr-only" id="dates-navigation{{componentId}}">shift focus to input to change calendar dates</div>\n    </div>\n</template>\n';});


define('hui/date-picker/calendar',[
    'register-component/v2/register',
    'object-utils/classes',
    'register-component/v2/UIComponent',
    'register-component/template!./calendar.html',
    '../core/keys',
    '../core/a11y',
    '../core/timeUtils',
    '../tooltip'
], function(register, classes, UIComponent, template, keys, a11y, timeUtils) {
    var HACalendar = classes.createObject(UIComponent, {

        init: function _() {
            _.super(this);

            this.template = template;

            /**
             * The date at which this calendar was created,
             * used to initialize the display and add custom styles
             * @type {Date}
             * @private
             */
            this._currentDate = new Date(Date.now());
            this._selection =  [this._currentDate];
            this._month = this._currentDate.getMonth();
            this._year = this._currentDate.getFullYear();
            this._otherMonth = 'other-month';
            this._blackout = 'blackout-date';
            this._selected = 'selected-date';
            this._highlighted = 'highlighted-date';
            this._currentDateClass = 'current-date';
            this._notableDate = 'notable-date';
            this._monthLabels = ['JANUARY', 'FEBRUARY', 'MARCH', 'APRIL', 'MAY', 'JUNE', 'JULY',
                'AUGUST', 'SEPTEMBER', 'OCTOBER', 'NOVEMBER', 'DECEMBER'];
            this._monthAbbreviations = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'June', 'July',
                'Aug', 'Sept', 'Oct', 'Nov', 'Dec'];
            this._dayOfWeekLabels = ['S', 'M', 'T', 'W', 'T', 'F', 'S'];

            this.setupProperties({
                /**
                 * The maximum valid date value (ECMAScript Date Time String)
                 * @type {string}
                 */
                maxDate: {
                    default: '',
                    type: String,
                    change: function() {
                        this.updateRendering();
                    }
                },

                /**
                 * The minimum valid date value (ECMAScript Date Time String)
                 * @type {string}
                 */
                minDate: {
                    default: '',
                    type: String,
                    change: function() {
                        this.updateRendering();
                    }
                },

                /**
                 * Whether or not to display buttons for changing the date by a year at a time.
                 * Defaults to false
                 */
                showYearNavigation: {
                    default: false,
                    type: Boolean,
                    change: function(showYearNavigation) {
                        if (showYearNavigation) {
                            this.querySelector('.ha-calendar-year-navigation').classList.remove('hidden');
                        } else {
                            this.querySelector('.ha-calendar-year-navigation').classList.add('hidden');
                        }
                        this.updateRendering();
                    }
                },

                /**
                 * The text to use for a selected date range alert
                 * {{start}} and {{end}} signal where the start date and end date should be inserted
                 */
                selectedDateRangeText: {
                    default: 'Selected {{start}} through {{end}}',
                    type: String
                },

                /**
                 * The text to use for a selected date range alert
                 * {{date}} signals where the selected date should be inserted
                 */
                selectedDateText: {
                    default: 'Selected date: {{date}}',
                    type: String
                }
            });
        },

        postRender: function _() {
            _.super(this);
            this.querySelector('#gridNode' + this.componentId).focus();

            this.updateRendering();

            this.listenTo(this, '.ha-calendar-next-month:click', function() {
                this.month = this.month + 1;
                this.select(new Date(this._year, this._month));
            }.bind(this), true);

            this.listenTo(this, '.ha-calendar-previous-month:click', function() {
                this.month = this.month - 1;
                this.select(new Date(this._year, this._month + 1, 0));
            }.bind(this), true);

            this.listenTo(this, '.ha-calendar-next-year:click', function() {
                this.year = this.year + 1;
                this.select(new Date(this._year, this._month));
            }.bind(this), true);

            this.listenTo(this, '.ha-calendar-previous-year:click', function() {
                this.year = this.year - 1;
                this.select(new Date(this._year, this._month + 1, 0));
            }.bind(this), true);

            this.listenTo(this, 'td:click', function(event) {
                var dateCell = event.target.nodeName === 'TD' ? event.target : event.target.parentNode,
                    date = dateCell.nodeName === 'TD' ? this._getDateFromCell(dateCell) : null;
                if (date && !this._isBlackoutDate(date) && !this.isInOtherMonth(date)) {
                    this.emit('change', {
                        date: date
                    });
                    this.select([date]);
                }
            }.bind(this), true);

            this.listenTo(this, 'td:mouseover', function(event) {
                var dateCell = event.target.nodeName === 'TD' ? event.target : event.target.parentNode,
                    date = dateCell.nodeName === 'TD' ? this._getDateFromCell(dateCell) : null;
                if (date && !this._isBlackoutDate(date) && !this.isInOtherMonth(date)) {
                    this.select([date]);
                }
            }.bind(this));

            this.listenTo(this, 'keydown', this.handleKeyDown.bind(this));
        },

        attachedCallback: function _() {
            _.super(this);

        },

        /**
         * These dates have special blackout styling applied
         * and are not selectable
         *
         * @type {Array}
         */
        set blackoutDates(dates) {
            if (this._blackoutDates) {
                this._setClass(this._blackoutDates, this._blackout, false);
            }
            this._blackoutDates = dates;
            this._setClass(this._blackoutDates, this._blackout, true);
        },

        get blackoutDates() {
            return this._blackoutDates;
        },

        /**
         * The current date, defaults to Date.now()
         *
         * @type {Date}
         */
        set currentDate(currentDate) {
            if (this._currentDate) {
                this._setClass(this._currentDate, this._currentDateClass, false);
            }
            this._currentDate = currentDate;

            this._setClass(this._currentDate, this._currentDateClass, true);
        },

        get currentDate() {
            return this._currentDate;
        },

        /**
         * These are dates that are not directly selected,
         * but are in the selected range or that should be  highlighted
         * for some other reason
         *
         * @type {Array}
         */
        set highlightedDates(dates) {
            if (this._highlightedDates) {
                this._setClass(this._highlightedDates, this._highlighted, false);
            }
            this._highlightedDates = dates;
            this._setClass(this._highlightedDates, this._highlighted, true);
        },

        get highlightedDates() {
            return this._highlightedDates;
        },

        /**
         * The month that the calendar should display, starts
         * from 0
         *
         * @type {Number}
         */
        set month(month) {
            while (month < 0) {
                month += 12;
                this._year--;
            }
            while (month >= 12) {
                month -= 12;
                this._year++;
            }
            this._month = month;
            this.updateRendering();
        },

        get month() {
            return this._month;
        },

        /**
         * The labels to display for each month, the array
         * should have January or its equivalent at position 0
         *
         * @type {Array}
         */
        set monthLabels(monthLabels) {
            this._monthLabels = monthLabels;
            this.updateRendering();
        },

        get monthLabels() {
            return this._monthLabels;
        },

        /**
         * The labels to display for each day of the week, the
         * array should be in order from the first day of the week to the
         * last.
         *
         * @type {Array}
         */
        set dayOfWeekLabels(dayOfWeekLabels) {
            this._dayOfWeekLabels = dayOfWeekLabels;
            this.updateRendering();
        },

        get dayOfWeekLabels() {
            return this._dayOfWeekLabels;
        },

        /**
         * The abbreviations for month names, used in tooltips, should start with
         * the abbreviation for January in position 0
         *
         * @type {Array}
         */
        set monthAbbreviations(monthAbbreviations) {
            this._monthAbbreviations = monthAbbreviations;
            this.updateRendering();
        },

        get monthAbbreviations() {
            return this._monthAbbreviations;
        },

        /**
         * Notable dates are displayed with orange text, these are things like
         * holidays, birthdays, etc.
         *
         * @type {Array}
         */
        set notableDates(dates) {
            if (this._notableDates) {
                this._setClass(this._notableDates, this._notableDate, false);
            }
            this._notableDates = dates;
            this._setClass(this._notableDates, this._notableDate, true);
        },

        get notableDates() {
            return this._notableDates;
        },

        /**
         * The year that the calendar displays
         *
         * @type {Number}
         */
        set year(year) {
            this._year = year;
            this.updateRendering();
        },

        get year() {
            return this._year;
        },

        /**
         * A map of dates in string format(any format parseable to a date via new Date(string)
         * is acceptable) to tooltip text. The tooltip text will be displayed inside of an HATooltip when the
         * corresponding date is hovered.
         *
         * @type {Object}
         */
        set tooltips(tooltips) {
            var key,
                date,
                tooltip,
                monthTitle,
                description,
                targetIdSelector,
                targetNode;

            if (this._tooltipNodes) {
                this._tooltipNodes.forEach(function(tooltip) {
                    if (tooltip) {
                        tooltip.close();

                        if (tooltip.parentNode) {
                            tooltip.parentNode.removeChild(tooltip);
                        }
                    }
                });
            }

            this._tooltips = tooltips;
            this._tooltipNodes = [];
            for (key in tooltips) {
                if (tooltips.hasOwnProperty(key)) {
                    date = this._parseIfString(key);
                    if (date) {
                        tooltip = this.ownerDocument.createElement('ha-tooltip');
                        this._tooltipNodes.push(tooltip);
                        monthTitle = this.ownerDocument.createElement('div');
                        monthTitle.classList.add('ha-calendar-tooltip-header');
                        monthTitle.textContent = this._monthAbbreviations[date.getMonth()] +
                            ' ' + date.getDate();
                        description = this.ownerDocument.createElement('div');
                        description.classList.add('ha-calendar-tooltip-content');
                        description.textContent = tooltips[key];
                        tooltip.trigger = 'hover';
                        tooltip.appendChild(monthTitle);
                        tooltip.appendChild(description);
                        targetIdSelector = '#' + this._getDateId(date);
                        tooltip.targetSelector = targetIdSelector;
                        targetNode = this.querySelector(targetIdSelector);
                        if (targetNode) {
                            targetNode.appendChild(tooltip);
                        }
                    }
                }
            }
        },

        get tooltips() {
            return this._tooltips;
        },

        /**
         * Removes all of the passed in dates from the list of currently
         * selected dates, and removes the corresponding styling from the
         * nodes in the calendar. If the dates are not currently selected, this
         * will not do anything.
         *
         * @param {Array | Date} dateOrDates a date or array of dates to deselect
         */
        deselect: function(dateOrDates) {
            if (this._selection) {
                var self = this,
                    index;
                if (Array.isArray(dateOrDates)) {
                    dateOrDates.forEach(function(date) {
                        while ((index = self._selection.indexOf(date)) > -1) {
                            self._selection.splice(index, 1);
                        }
                    });
                } else {
                    while ((index = self._selection.indexOf(dateOrDates)) > -1) {
                        self._selection.splice(index, 1);
                    }
                }
            }

            this._setClass(dateOrDates, this._selected, false);
        },

        /**
         * Adds the passed in date or dates to the selection and adds appropriate styles.
         * If isRange is true, the dates between the first and last date passed in will
         * be set as the list of highlighted dates.
         * If show is true, the calendar will be updated to display the first date in the passed
         * in range
         *
         * @param {Array | Date | String} dateOrDates selected date or dates
         * @param {Boolean} isRange Whether the dates represent a range of selected dates or
         * individual selected dates
         * @param {Boolean} show Whether the calendar should update to display the selected date
         */
        select: function(dateOrDates, isRange, show) {
            var firstDate,
                iterateDate,
                lastDate,
                dateRange,
                dateCellId,
                dateCell,
                alertNode = this.ownerDocument.createElement('span'),
                oldAlertNode = this.querySelector('.selectionAlertNode'),
                lastDateValue,
                maxDate = this.maxDate ? timeUtils.parseISODateString(this.maxDate) : null,
                minDate = this.minDate ? timeUtils.parseISODateString(this.minDate) : null;

            if (Array.isArray(dateOrDates)) {
                firstDate = this._parseIfString(dateOrDates[0]);
                lastDate = this._parseIfString(dateOrDates[dateOrDates.length - 1]);
            } else {
                firstDate = this._parseIfString(dateOrDates);
            }

            if (maxDate) {
                if (firstDate > maxDate || (lastDate && lastDate > maxDate)) {
                    return;
                }
            }

            if (minDate) {
                if (firstDate < minDate) {
                    return;
                }
            }

            alertNode.classList.add('sr-only');
            alertNode.classList.add('selectionAlertNode');
            alertNode.setAttribute('role', 'alert');

            if (this._selection) {
                this._setClass(this._selection, this._selected, false);
            }

            if (Array.isArray(dateOrDates)) {
                this._selection = dateOrDates.slice(0);
            } else {
                if (this.isInOtherMonth(dateOrDates) && !show) {
                    this._selection = [];
                    return;
                }
                this._selection = [dateOrDates];
            }

            this._setClass(dateOrDates, this._selected, true);

            if (show) {
                if (firstDate && (firstDate.getFullYear() !== this._year || firstDate.getMonth() !== this._month)) {
                    this._year = firstDate.getFullYear();
                    this._month = firstDate.getMonth();
                    this.updateRendering();
                }
            }

            if (isRange) {
                iterateDate = firstDate ?
                    new Date(firstDate.getFullYear(), firstDate.getMonth(), firstDate.getDate()) : null;
                dateRange = [];

                if (firstDate && lastDate) {
                    lastDateValue = lastDate.valueOf();
                    while (iterateDate.valueOf() <= lastDateValue) {
                        dateRange.push(iterateDate);
                        iterateDate = new Date(
                            iterateDate.getFullYear(),
                            iterateDate.getMonth(),
                            iterateDate.getDate() + 1
                        );
                    }

                    this.highlightedDates = dateRange;
                }

                if (firstDate && lastDate) {
                    alertNode.textContent = this.selectedDateRangeText
                        .replace('{{start}}', firstDate.toLocaleDateString())
                        .replace('{{end}}', lastDate.toLocaleDateString());
                    this.querySelector('#selectionAlertNode' + this.componentId);
                    oldAlertNode.parentNode.replaceChild(alertNode, oldAlertNode);
                }
            } else if (firstDate) {
                alertNode.textContent = this.selectedDateText.replace('{{date}}', firstDate.toLocaleDateString());
                oldAlertNode.parentNode.replaceChild(alertNode, oldAlertNode);
            }

            if (firstDate) {
                dateCellId = this._getDateId(firstDate);
                dateCell = this.querySelector('#' + dateCellId);
                if (dateCell) {
                    this.querySelector('#gridNode' + this.componentId).setAttribute('aria-activedescendant', dateCellId);
                }
            }
        },

        /**
         * Determines whether this calendar is in a visible popover
         *
         * @private
         */
        _inVisiblePopover: function() {
            var parent = this.parentNode;
            while (parent) {
                if (parent.tagName === 'HA-POPOVER' && parent.classList.contains('visible')) {
                    return true;
                }
                parent = parent.parentNode;
            }

            return false;
        },

        /**
         * Handles moving the focus to the appropriate element when tabbing. Because the calendar popover is not
         * a child of the calendar element itself, tabbing between components requires manually managing focus.
         *
         * @param {Event} event
         * @private
         */
        _moveFocus: function(event) {
            var shouldRestoreInputFocus = false,
                shouldFocusNextElement = false,
                focusableElements = a11y.getBoundariesTabableElement(this, true, true);
            if (event.target.tagName === 'INPUT') {
                if (!event.shiftKey) {
                    event.preventDefault();
                    event.stopPropagation();
                    focusableElements.first.focus();
                }
            } else if (event.shiftKey) {
                if (event.target === focusableElements.first) {
                    shouldRestoreInputFocus = true;
                }
            } else if (event.target === focusableElements.last) {
                shouldFocusNextElement = true;
            }

            if (shouldRestoreInputFocus || shouldFocusNextElement) {
                if (this._owningInput) {
                    if (shouldRestoreInputFocus) {
                        event.preventDefault();
                        event.stopPropagation();
                    } else {
                        this.emit('ha-calendar-exiting');
                    }
                    this._owningInput.focus();
                }
            }
        },

        /**
         * Updates the calendar's display based on the latest selected year, month, blackout dates,
         * selected dates, month labels, etc.
         */
        updateRendering: function() {
            var monthAndYearNode = this.querySelector('#monthAndYearNode' + this.componentId),
                dateRowsNode = this.querySelector('#dateRowsNode' + this.componentId),
                dayCellsNode = this.querySelector('#dayCellsNode' + this.componentId),
                previousYear = this.querySelector('.ha-calendar-previous-year'),
                currentYear = this.querySelector('.ha-calendar-current-year'),
                nextYear = this.querySelector('.ha-calendar-next-year'),
                i,
                dayCell;

            while (dayCellsNode.firstChild) {
                dayCellsNode.removeChild(dayCellsNode.firstChild);
            }
            for (i = 0; i < this._dayOfWeekLabels.length; i++) {
                dayCell = this.ownerDocument.createElement('th');
                dayCell.textContent = this._dayOfWeekLabels[i];
                dayCellsNode.appendChild(dayCell);
            }

            monthAndYearNode.textContent = this._monthLabels[this._month] +
                (this.showYearNavigation ? '' : ' ' + this._year);
            while (dateRowsNode.firstChild) {
                dateRowsNode.removeChild(dateRowsNode.firstChild);
            }

            dateRowsNode.appendChild(this._buildDateRows());

            previousYear.textContent = this.year - 1;
            currentYear.textContent = this.year;
            nextYear.textContent = this.year + 1;
            this._setClass(this._highlightedDates, this._highlighted, true);
            this._setClass(this._blackoutDates, this._blackout, true);
            this._setClass(this._selection, this._selected, true);
            this._setClass(this._currentDate, this._currentDateClass, true);
            this._setClass(this._notableDates, this._notableDate, true);
            this.tooltips = this._tooltips;
        },

        /**
         * Renders the cells that display the actual date values
         * @returns {DocumentFragment} A document fragment containing the rendered dates
         * @private
         */
        _buildDateRows: function() {
            var date = new Date(this._year, this._month),
                minDate = this.minDate ? timeUtils.parseISODateString(this.minDate) : null,
                maxDate = this.maxDate ? timeUtils.parseISODateString(this.maxDate) : null,
                i,
                j,
                week,
                day,
                dayDiv,
                nextMonthButton = this.querySelector('.ha-calendar-next-month'),
                prevMonthButton = this.querySelector('.ha-calendar-previous-month'),
                fragment = this.ownerDocument.createDocumentFragment();
            this._otherMonthDays = [];
            //Get the closest sunday to start the calendar,
            //but if the month starts on a sunday still show a week of the previous month
            if (date.getDay() === 0) {
                date.setDate(date.getDate() - 7);
            } else {
                date.setDate(date.getDate() - date.getDay());
            }
            for (i = 0; i < 6; i++) {
                week = this.ownerDocument.createElement('tr');

                for (j = 0; j < 7; j++) {
                    day = this.ownerDocument.createElement('td');
                    day.setAttribute('aria-selected', 'false');
                    dayDiv = this.ownerDocument.createElement('div');
                    if (date.getMonth() !== this._month) {
                        this._otherMonthDays.push(new Date(date.getFullYear(), date.getMonth(), date.getDate()));
                        day.classList.add(this._otherMonth);
                    }

                    dayDiv.textContent = date.getDate();
                    day.appendChild(dayDiv);
                    day.setAttribute('id', this._getDateId(date));

                    if ((maxDate && date > maxDate) ||
                        (minDate && date < minDate)) {
                        day.setAttribute('disabled', 'disabled');
                        day.classList.add(this._blackout);
                    }

                    week.appendChild(day);
                    date.setDate(date.getDate() + 1);
                }

                fragment.appendChild(week);
            }

            if (maxDate && timeUtils.compareDateWithoutDay(this._otherMonthDays[this._otherMonthDays.length - 1], maxDate) > 0) {
                // If the next/prev button is focused when it is hidden, focus will automatically shift
                // to the document body - to prevent that, we shift focus to the other button
                if (document.activeElement === nextMonthButton) {
                    prevMonthButton.focus();
                }

                nextMonthButton.classList.add('hidden');
                nextMonthButton.setAttribute('aria-hidden', 'true');
            } else {
                nextMonthButton.classList.remove('hidden');
                nextMonthButton.setAttribute('aria-hidden', 'false');
            }

            if (minDate && timeUtils.compareDateWithoutDay(this._otherMonthDays[0], minDate) < 0) {
                if (document.activeElement === prevMonthButton) {
                    nextMonthButton.focus();
                }

                prevMonthButton.classList.add('hidden');
                prevMonthButton.setAttribute('aria-hidden', 'true');
            } else {
                prevMonthButton.classList.remove('hidden');
                prevMonthButton.setAttribute('aria-hidden', 'false');
            }

            return fragment;
        },

        /**
         * Parses the ID of the cell element into a date object;
         * assumes that the date is formatted as 'idMMDDYYYYcomponentCOMPONENT_ID'
         *
         * @param {HTMLElement} cell The cell to retrieve the date from
         * @returns {Date} The parsed Date object
         * @private
         */
        _getDateFromCell: function(cell) {
            var dateId = cell.getAttribute('id').substring(2).split('component')[0],
                month = dateId.substring(0, 2),
                day = dateId.substring(2, 4),
                year = dateId.substring(4);
            return new Date(year, month, day);
        },

        /**
         * Converts the passed in date object to a
         * string in the format 'idMMDDYYYYcomponentCOMPONENT_ID'
         *
         * @param {Date} date The date to parse
         * @returns {string} The string representing the date, to be used as an element ID
         * @private
         */
        _getDateId: function(date) {
            var day = date.getDate(),
                month = date.getMonth();

            if (day < 10) {
                day = '0' + day;
            }

            if (month < 10) {
                month = '0' + month;
            }

            return 'id' + month + day + date.getFullYear() + 'component' + this.componentId;
        },

        /**
         * Returns an array of strings created by passing the passed in
         * date or dates to _getDateId
         *
         * @param {Array | Date} dateOrDates A date or dates to get the Ids for
         * @returns {Array} An array of strings that can be used as unique IDs for HTML elements
         * representing dates
         * @private
         */
        _getDateIds: function(dateOrDates) {
            var ids = [],
                self = this,
                date;

            if (Array.isArray(dateOrDates)) {
                dateOrDates.forEach(function(dateOrString) {
                    if ((date = self._parseIfString(dateOrString))) {
                        ids.push(self._getDateId(date));
                    }
                });

            } else if ((date = self._parseIfString(dateOrDates))) {
                ids.push(this._getDateId(date));
            }

            return ids;
        },

        /**
         * Queries this document for the nodes corresponding to the passed
         * in dates, which can be actual Date objects or strings that can be parsed
         * to a date via a call to new Date(string)
         *
         * @param {Array | Number | Date} dates An array of strings or Date objects,
         * or a single string or Date object
         * @returns {Array} An array of nodes corresponding to the passed in dates
         * @private
         */
        _getDateNodes: function(dates) {
            var nodes = [],
                node,
                self = this;
            this._getDateIds(dates).forEach(function(dateId) {
                if ((node = self.querySelector('#' + dateId))) {
                    nodes.push(node);
                }
            });
            return nodes;
        },

        /**
         * Returns the first date in the list of selected dates
         * or the current date if none is selected
         *
         * @returns Date The first selected date or the current date if none is
         * selected
         * @private
         */
        _getSelectedDate: function() {
            return (this._selection && this._parseIfString(this._selection[0])) || this._currentDate;
        },

        /**
         * Determines whether the passed in date is in another month
         * @param {Date} date The date to check
         * @returns {Boolean} Flag indicating whether the date is from another month
         * @private
         */
        isInOtherMonth: function(date) {
            date = this._parseIfString(date);
            var isInOtherMonth = false;
            if (this._otherMonthDays) {
                this._otherMonthDays.forEach(function(otherMonthDate) {
                    otherMonthDate = this._parseIfString(otherMonthDate);
                    if (otherMonthDate.getFullYear() === date.getFullYear() &&
                        otherMonthDate.getMonth() === date.getMonth() &&
                        otherMonthDate.getDate() === date.getDate()) {
                        isInOtherMonth = true;
                    }
                }.bind(this));
            }

            return isInOtherMonth;
        },

        /**
         * Determines whether the passed in date is in the set of blackout dates
         *
         * @param {Date} date The date to check
         * @returns {boolean} Flag indicating whether the date is a blackout date
         * @private
         */
        _isBlackoutDate: function(date) {
            var isBlackoutDate = false,
                minDate = this.minDate ? timeUtils.parseISODateString(this.minDate) : null,
                maxDate = this.maxDate ? timeUtils.parseISODateString(this.maxDate) : null;

            if ((maxDate && date > maxDate) ||
                (minDate && date < minDate)) {
                return true;
            }

            if (this._blackoutDates) {
                this._blackoutDates.forEach(function(blackoutDate) {
                    blackoutDate = this._parseIfString(blackoutDate);
                    if (blackoutDate.getFullYear() === date.getFullYear() &&
                        blackoutDate.getMonth() === date.getMonth() &&
                        blackoutDate.getDate() === date.getDate()) {
                        isBlackoutDate = true;
                    }
                }.bind(this));
            }

            return isBlackoutDate;
        },

        /**
         * Handles keydown events, changing the selected day
         *
         * Enter or space on the navigation buttons will have the same affect
         * as clicking the navigation buttons. Enter or space anywhere else will
         * emit a 'change' event with a 'date' property corresponding to the
         * first currently selected date chronologically.
         *
         * Other keys are used for navigation:
         *
         * +, or Right will move forward a day,
         * -, or Left will move back a day,
         * Up will move back one week
         * Down will move forward one week
         * Pagedown will move forward one month, selecting the last day of the month if the
         * currently selected date doesn't exist in that month
         * Pageup will move backward one month, selecting the last day of the month if the
         * currently selected date doesn't exist in that month
         * Ctrl + Pagedown will move forward one year, selecting the last day of the month if the
         * currently selected date doesn't exist in that month
         * Ctrl + Pageup will move backward one year, selecting the last day of the month if the
         * currently selected date doesn't exist in that month
         * m will select the first day of the current month
         * h will select the last day of the current month
         * w will select the first day of the current week
         * k will select the last day of the current week
         * y will select the first day of the current year
         * r will select the last day of the current year
         *
         * @param {Event} event
         */
        handleKeyDown: function(event) {
            var date;
            if (event.keyCode === keys.TAB) {
                this._moveFocus(event);
            } else if (event.keyCode === keys.ENTER || event.keyCode === keys.SPACEBAR) {
                event.preventDefault();
                if (event.target === this.querySelector('.ha-calendar-next-year')) {
                    this.year = this.year + 1;
                    this.select(new Date(this._year, this._month));
                } else if (event.target === this.querySelector('.ha-calendar-previous-year')) {
                    this.year = this.year - 1;
                    this.select(new Date(this._year, this._month + 1, 0));
                } else if (event.target === this.querySelector('.ha-calendar-next-month')) {
                    this.month = this.month + 1;
                    this.select(new Date(this._year, this._month));
                } else if (event.target === this.querySelector('.ha-calendar-previous-month')) {
                    this.month = this.month - 1;
                    this.select(new Date(this._year, this._month + 1, 0));
                } else if (this._selection && this._selection[0]) {
                    date = this._getDateFromCell(this._getDateNodes(this._selection[0])[0]);
                    if (!this._isBlackoutDate(date) && !this.isInOtherMonth(date)) {
                        this.emit('change', {
                            date: date
                        });
                    }
                }
            } else if (event.keyCode === keys.LEFT ||
                event.keyCode === keys.NUM_PAD_MINUS ||
                event.keyCode === keys.MINUS) {
                event.preventDefault();
                date = this._getSelectedDate();

                if (date) {
                    this.select(new Date(
                        date.getFullYear(),
                        date.getMonth(),
                        date.getDate() - 1
                    ), false, true);
                } else {
                    this.select([new Date(this._year, this._month)]);
                }
            } else if (event.keyCode === keys.RIGHT ||
                event.keyCode === keys.NUM_PAD_PLUS ||
                (event.keyCode === keys.EQUALS && event.shiftKey)) {
                event.preventDefault();
                date = this._getSelectedDate();

                if (date) {
                    this.select([new Date(
                        date.getFullYear(),
                        date.getMonth(),
                        date.getDate() + 1
                    )], false, true);
                } else {
                    this.select([new Date(this._year, this._month)]);
                }
            } else if (event.keyCode === keys.END || event.keyCode === keys.H) {
                event.preventDefault();
                this.select([new Date(this._year, this._month + 1, 0)]);
            } else if (event.keyCode === keys.HOME || event.keyCode === keys.M) {
                event.preventDefault();
                this.select([new Date(this._year, this._month)]);
            } else if (event.keyCode === keys.PAGEUP) {
                event.preventDefault();
                if (event.ctrlKey) {
                    this._updateSelectionYear(-1);
                } else {
                    this._updateSelectionMonth(-1);
                }

            } else if (event.keyCode === keys.PAGEDOWN) {
                event.preventDefault();
                if (event.ctrlKey) {
                    this._updateSelectionYear(1);
                } else {
                    this._updateSelectionMonth(1);
                }
            } else if (event.keyCode === keys.Y) {
                event.preventDefault();
                this.select([new Date(this._year, 0, 1)], false, true);
            } else if (event.keyCode === keys.R) {
                event.preventDefault();
                this.select([new Date(this._year + 1, 0, 0)], false, true);
            } else if (event.keyCode === keys.W) {
                event.preventDefault();
                date = this._getSelectedDate();
                if (date) {
                    this.select([new Date(this._year, this._month, date.getDate() - date.getDay())], false, true);
                }
            } else if (event.keyCode === keys.K) {
                event.preventDefault();
                date = this._getSelectedDate();
                if (date) {
                    this.select([new Date(this._year, this._month, date.getDate() + (6 - date.getDay()))], false, true);
                }
            } else if (event.keyCode === keys.T) {
                event.preventDefault();
                this.select(this._currentDate, false, true);
            } else if (event.keyCode === keys.UP) {
                event.preventDefault();
                date = this._getSelectedDate();
                if (date) {
                    this.select([new Date(date.getFullYear(), date.getMonth(), date.getDate() - 7)], false, true);
                }
            } else if (event.keyCode === keys.DOWN) {
                event.preventDefault();
                date = this._getSelectedDate();
                if (date) {
                    this.select([new Date(date.getFullYear(), date.getMonth(), date.getDate() + 7)], false, true);
                }
            }
        },

        /**
         * Will parse the passed in string into a date,
         * or simply return the passed in objec if it is a Date
         *
         * @param {Date | String} dateOrString
         * @returns {Date|null} A Date object or null if the input was not a string
         * or Date object
         * @private
         */
        _parseIfString: function(dateOrString) {
            if (typeof dateOrString === 'string') {
                return new Date(dateOrString);
            } else if (dateOrString && dateOrString.getDate) {
                return dateOrString;
            } else {
                return null;
            }
        },

        /**
         * Sets or removes the passed in class on the nodes
         * corresponding to the passed in date or dates
         *
         * @param {Array | Date | String} dateOrDates An array of Dates or date strings,
         * or a Date, or a date string
         * @param {String} className The class to apply
         * @param {Boolean | undefined} add Whether to add or remove the class,
         * if not specified the class will be toggled
         * @private
         */
        _setClass: function(dateOrDates, className, add) {
            var isSelectedOrHighlightedClass = this._selected === className || this._highlighted === className;
            this._getDateNodes(dateOrDates).forEach(function(dateNode) {
                if (typeof add !== 'undefined') {
                    if (add) {
                        dateNode.classList.add(className);
                        if (isSelectedOrHighlightedClass) {
                            dateNode.setAttribute('aria-selected', 'true');
                        }
                    } else {
                        dateNode.classList.remove(className);
                    }
                } else {
                    dateNode.classList.toggle(className);
                }
            });
        },

        /**
         * Increments(or decrements if negative) the displayed year by
         * the passed in amount
         *
         * @param {Number} numYears
         * @private
         */
        _updateSelectionYear: function(numYears) {
            var date,
                newDate;
            if (this._selection && (date = this._parseIfString(this._selection[0]) || this._currentDate)) {
                newDate = new Date(date.getFullYear() + numYears, date.getMonth(), date.getDate());

                if (newDate.getMonth() !== date.getMonth() || newDate.getDate() !== date.getDate()) {
                    newDate = new Date(date.getFullYear() + numYears, date.getMonth() + 1, 0);
                }

                this.select([newDate], false, true);
            } else {
                this.select([new Date(this._year + numYears, this._month + 1, 0)], false, true);
            }
        },

        /**
         * Increments(or decrements if negative) the displayed month by
         * the passed in amount
         *
         * @param {Number} numMonths
         * @private
         */
        _updateSelectionMonth: function(numMonths) {
            var date,
                newDate;
            if (this._selection && (date = this._parseIfString(this._selection[0]) || this._currentDate)) {
                newDate = new Date(date.getFullYear(), date.getMonth() + numMonths, date.getDate());
                // If the day doesn't exist in the target month our month will be one greater
                // than expected. This works going forwards or backwards
                if (newDate.getMonth() === date.getMonth() + (numMonths + 1)) {
                    newDate = new Date(date.getFullYear(), date.getMonth() + (numMonths + 1), 0);
                }

                this.select([newDate], false, true);
            } else {
                this.select([new Date(this._year, this._month + numMonths + 1, 0)], false, true);
            }
        }
    });

    return register('ha-calendar', HACalendar);
});

define('hui/date-picker/double-calendar',[
    'register-component/v2/register',
    'object-utils/classes',
    'register-component/v2/UIComponent',
    '../core/keys',
    './calendar'
], function(register, classes, UIComponent, keys) {
    var HACalendar = classes.createObject(UIComponent, {
        init: function _() {
            _.super(this);

            /**
             * The date at which this calendar was created,
             * used to initialize the display and add custom styles
             * @type {Date}
             * @private
             */
            this._currentDate = new Date(Date.now());
            this._selection = [this._currentDate];
            this._minMonth = this._currentDate.getMonth();
            this._maxMonth = this._minMonth + 1;
            this._year = this._currentDate.getFullYear();

            this.setupProperties({
            });
        },

        postRender: function _() {
            _.super(this);

            if (!this.calendarOne) {
                var calendarOne = this.ownerDocument.createElement('ha-calendar'),
                    calendarTwo = this.ownerDocument.createElement('ha-calendar');
                this.appendChild(calendarOne);
                this.appendChild(calendarTwo);
            }
            this.updateRendering();

            this.listenTo(this, '.ha-calendar-next-month:click', function(event) {
                event.stopPropagation();
                this.show(this._year, this._maxMonth + 1);
                this.select(new Date(this._year, this._maxMonth));
            }.bind(this), true);

            this.listenTo(this, '.ha-calendar-previous-month:click', function(event) {
                event.stopPropagation();
                this.show(this._year, this._minMonth - 1);
                this.select(new Date(this._year, this._minMonth + 1, 0));
            }.bind(this), true);

            this.listenTo(this, 'td:click', function(event) {
                event.stopPropagation();
                var dateCell = event.target.nodeName === 'TD' ? event.target : event.target.parentNode,
                    date = dateCell.nodeName === 'TD' ? this._getDateFromCell(dateCell) : null;
                if (date && !this._isBlackoutDate(date) && !this._isOtherMonthCell(dateCell, date)) {
                    this.emit('change', {
                        date: date
                    });
                    this.select([date]);
                    // Don\'t make any new selections for a brief period. This ensures that
                    // the selection won't be changed while the popover is being hidden
                    this._pauseForClick = true;
                    setTimeout(function() {
                        this._pauseForClick = false;
                    }.bind(this), 500);
                }
            }.bind(this), true);

            this.listenTo(this, 'td:mouseover', function(event) {
                event.stopPropagation();
                if (!this._pauseForClick) {
                    var dateCell = event.target.nodeName === 'TD' ? event.target : event.target.parentNode,
                        date = dateCell.nodeName === 'TD' ? this._getDateFromCell(dateCell) : null;
                    if (date && !this._isBlackoutDate(date) && !this._isOtherMonthCell(dateCell, date)) {
                        this.select([date]);
                    }
                }
            }.bind(this));

            this.listenTo(this, 'keydown', this.handleKeyDown.bind(this));
        },

        attachedCallback: function _() {
            _.super(this);
            this.calendarOne.stopListening();
            this.calendarOne.querySelector('.ha-calendar-next-month').classList.add('hidden');
            this.calendarTwo.querySelector('.ha-calendar-previous-month').classList.add('hidden');
            this.calendarTwo.stopListening();
        },

        /**
         * These dates have special blackout styling applied
         * and are not selectable
         *
         * @type {Array}
         */
        set blackoutDates(dates) {
            this._blackoutDates = dates;
            this.calendarOne.blackoutDates = dates;
            this.calendarTwo.blackoutDates = dates;
        },

        get blackoutDates() {
            return this._blackoutDates;
        },

        get calendarOne() {
            return this.querySelector('ha-calendar');
        },

        get calendarTwo() {
            return this.querySelectorAll('ha-calendar')[1];
        },

        /**
         * The labels to display for each day of the week, the
         * array should be in order from the first day of the week to the
         * last.
         *
         * @type {Array}
         */
        set dayOfWeekLabels(dayOfWeekLabels) {
            this._dayOfWeekLabels = dayOfWeekLabels;
            this.calendarOne.dayOfWeekLabels = dayOfWeekLabels;
            this.calendarTwo.dayOfWeekLabels = dayOfWeekLabels;
        },

        get dayOfWeekLabels() {
            return this._dayOfWeekLabels || this.calendarOne.dayOfWeekLabels;
        },

        /**
         * The current date, defaults to Date.now()
         *
         * @type {Date}
         */
        set currentDate(currentDate) {
            this._currentDate = currentDate;
            this.calendarOne.currentDate = currentDate;
            this.calendarTwo.currentDate = currentDate;
        },

        get currentDate() {
            return this._currentDate;
        },

        /**
         * These are dates that are not directly selected,
         * but are in the selected range or that should be  highlighted
         * for some other reason
         *
         * @type {Array}
         */
        set highlightedDates(dates) {
            this._highlightedDates = dates;
            this.calendarOne.highlightedDates = dates;
            this.calendarTwo.highlightedDates = dates;
        },

        get highlightedDates() {
            return this._highlightedDates;
        },

        /**
         * Returns the highest month currently being displayed
         *
         * @type {Number}
         */
        get maxMonth() {
            return (this._maxMonth + 12) % 12;  //round by 12 to prevent overflow
        },

        /**
         * Returns the lowest month currently being displayed
         *
         * @type {Number}
         */
        get minMonth() {
            return (this._minMonth + 12) % 12; //round by 12 to prevent overflow
        },

        /**
         * The labels to display for each month, the array
         * should have January or its equivalent at position 0
         *
         * @type {Array}
         */
        set monthLabels(monthLabels) {
            this._monthLabels = monthLabels;
            this.calendarOne.monthLabels = monthLabels;
            this.calendarTwo.monthLabels = monthLabels;
        },

        get monthLabels() {
            return this._monthLabels || this.calendarOne.monthLabels;
        },

        /**
         * The abbreviations for month names, used in tooltips, should start with
         * the abbreviation for January in position 0
         *
         * @type {Array}
         */
        set monthAbbreviations(monthAbbreviations) {
            this._monthAbbreviations = monthAbbreviations;
            this.calendarOne.monthAbbreviations = monthAbbreviations;
            this.calendarTwo.monthAbbreviations = monthAbbreviations;
        },

        get monthAbbreviations() {
            return this._monthAbbreviations || this.calendarOne.monthAbbreviations;
        },

        /**
         * Notable dates are displayed with orange text, these are things like
         * holidays, birthdays, etc.
         *
         * @type {Array}
         */
        set notableDates(dates) {
            this._notableDates = dates;
            this.calendarOne.notableDates = dates;
            this.calendarTwo.notableDates = dates;
        },

        get notableDates() {
            return this._notableDates;
        },

        /**
         * A Date that should be treated as the beginning of a selected range ending with
         * the date selected on this calendar
         *
         * @param {Date} date
         */
        set preselection(date) {
            this._preselection = date;
            if (this._selection) {
                this.select(this._selection);
            }
        },

        get preselection() {
            return this._preselection;
        },

        /**
         * A Date that should be treated as the end of a selected range beginning with
         * the date selected on this calendar
         *
         * @param {Date} date
         */
        set postselection(date) {
            this._postselection = date;
            if (this._selection) {
                this.select(this._selection);
            }
        },

        get postselection() {
            return this._postselection;
        },

        /**
         * Updates the calendars to show the selected year
         * and month. Adjusts the year if the month is greater than 11 or
         * less than 0.
         * @param {Number} year The year to display
         * @param {Number} month Zero indexed month to display
         */
        show: function(year, month) {
            while (month < 0) {
                month += 12;
                year--;
            }

            while (month >= 12) {
                month -= 12;
                year++;
            }

            var lastDate = new Date(this._year, this._maxMonth + 1, 0),
                firstDate = new Date(this._year, this._minMonth),
                newDate = new Date(year, month);
            if (newDate.valueOf() > lastDate.valueOf()) {
                this._maxMonth = month;
                this._minMonth = month - 1;
                this._year = year;
                this.updateRendering();
            } else if (newDate.valueOf() < firstDate.valueOf()) {
                this._minMonth = month;
                this._maxMonth = month + 1;
                this._year = year;
                this.updateRendering();
            }
        },

        /**
         * A map of dates in string format(any format parseable to a date via new Date(string)
         * is acceptable) to tooltip text. The tooltip text will be displayed inside of an HATooltip when the
         * corresponding date is hovered.
         *
         * @type {Object}
         */
        set tooltips(tooltips) {
            this._tooltips = tooltips;
            this.calendarOne.tooltips = this.calendarTwo.tooltips = tooltips;
        },

        get tooltips() {
            return this._tooltips;
        },

        /**
         * The current year being displayed
         *
         * @type {Number}
         */
        get year() {
            return this._year;
        },

        /**
         * Removes all of the passed in dates from the list of currently
         * selected dates, and removes the corresponding styling from the
         * nodes in the calendar. If the dates are not currently selected, this
         * will not do anything.
         *
         * @param {Array | Date} dateOrDates a date or array of dates to deselect
         */
        deselect: function(dateOrDates) {
            if (this._selection) {
                var self = this,
                    index;
                if (Array.isArray(dateOrDates)) {
                    dateOrDates.forEach(function(date) {
                        while ((index = self._selection.indexOf(date)) > -1) {
                            self._selection.splice(index, 1);
                        }
                    });
                } else {
                    while ((index = self._selection.indexOf(dateOrDates)) > -1) {
                        self._selection.splice(index, 1);
                    }
                }
            }

            this.calendarOne.deselect(dateOrDates);
            this.calendarTwo.deselect(dateOrDates);
        },

        /**
         * Adds the passed in date or dates to the selection and adds appropriate styles.
         * If isRange is true, the dates between the first and last date passed in will
         * be set as the list of highlighted dates.
         * If show is true, the calendar will be updated to display the first date in the passed
         * in range
         *
         * @param {Date | Array} dateOrDates One or more dates to select
         * @param {Boolean} isRange Whether this represents a range of selected dates or just
         * individual selected dates
         * @param {Boolean} show Whether the calendar should update to display the selected date
         */
        select: function(dateOrDates, isRange, show) {
            var showDate,
                modifiedSelection;
            if (Array.isArray(dateOrDates)) {
                this._selection = dateOrDates.slice(0);
            } else {
                this._selection = [dateOrDates];
            }
            if (this._preselection) {
                modifiedSelection = this._selection.slice(0);
                modifiedSelection.unshift(this._preselection);
                isRange = true;
            } else if (this._postselection) {
                modifiedSelection = this._selection.slice(0);
                modifiedSelection.push(this._postselection);
                isRange = true;
            }

            if (show) {
                showDate = this._parseIfString(this._getSelectedDate());
                if (showDate && !isNaN(showDate.getFullYear())) {
                    this.show(showDate.getFullYear(), showDate.getMonth());
                }
            }

            this.calendarOne.select(modifiedSelection || this._selection, isRange);
            this.calendarTwo.select(modifiedSelection || this._selection, isRange);

        },

        /**
         * Updates the calendars' displays based on the latest selected year, month, blackout dates,
         * selected dates, month labels, etc.
         */
        updateRendering: function() {
            this.calendarOne._year = this.calendarTwo._year = this._year;
            this.calendarOne.month = this._minMonth;
            this.calendarTwo.month = this._maxMonth;
        },

        /**
         * Parses the ID of the cell element into a date object;
         * assumes that the date is formatted as 'idMMDDYYYYcomponentCOMPONENT_ID'
         *
         * @param {HTMLElement} cell The cell to retrieve the date from
         * @returns {Date} The parsed Date object
         * @private
         */
        _getDateFromCell: function(cell) {
            var dateId = cell.getAttribute('id').substring(2).split('component')[0],
                month = dateId.substring(0, 2),
                day = dateId.substring(2, 4),
                year = dateId.substring(4);
            return new Date(year, month, day);
        },

        /**
         * Queries this document for the nodes corresponding to the passed
         * in dates, which can be actual Date objects or strings that can be parsed
         * to a date via a call to new Date(string)
         *
         * @param {Array | Number | Date} dates An array of strings or Date objects,
         * or a single string or Date object
         * @returns {Array} An array of nodes corresponding to the passed in dates
         * @private
         */
        _getDateNodes: function(dates) {
            return this.calendarOne._getDateNodes(dates).concat(this.calendarTwo._getDateNodes(dates));
        },

        /**
         * Returns the first date in the list of selected dates if no preselection has
         * been made, the last date in the list of selected dates if a preseleciton has
         * been made, or the current date if no dates are selected
         *
         * @returns Date The first selected date or the current date if none is
         * selected
         * @private
         */
        _getSelectedDate: function() {
            return (this._selection && (this._preselection ?
                this._parseIfString(this._selection[this._selection.length - 1]) :
                this._parseIfString(this._selection[0]))) || this._currentDate;
        },

        /**
         * Determines whether the passed in date is in the set of blackout dates
         *
         * @param {Date} date The date to check
         * @returns {boolean} Flag indicating whether the date is a blackout date
         * @private
         */
        _isBlackoutDate: function(date) {
            var isBlackoutDate = false;
            if (this._blackoutDates) {
                this._blackoutDates.forEach(function(blackoutDate) {
                    blackoutDate = this._parseIfString(blackoutDate);
                    if (blackoutDate.getFullYear() === date.getFullYear() &&
                        blackoutDate.getMonth() === date.getMonth() &&
                        blackoutDate.getDate() === date.getDate()) {
                        isBlackoutDate = true;
                    }
                }.bind(this));
            }

            return isBlackoutDate;
        },

        /**
         * Determines if the speciied cell is in the first calendar
         *
         * @param {HTMLElement} dateCell The cell to check
         * @returns {boolean} Flag indicating the result
         * @private
         */
        _inFirstCalendar: function(dateCell) {
            var calendarOne = this.calendarOne;
            while (dateCell && dateCell !== this) {
                if (dateCell === calendarOne) {
                    return true;
                }
                dateCell = dateCell.parentNode;
            }
            return false;
        },

        _isOtherMonthCell: function(dateCell, date) {
            if (!date) {
                date = dateCell;
                return this.calendarOne.isInOtherMonth(date) && this.calendarTwo.isInOtherMonth(date);
            } else {
                return this._inFirstCalendar(dateCell) ?
                    this.calendarOne.isInOtherMonth(date) : this.calendarTwo.isInOtherMonth(date);
            }
        },

        /**
         * Handles keydown events, changing the selected day
         *
         * Enter or space on the navigation buttons will have the same affect
         * as clicking the navigation buttons. Enter or space anywhere else will
         * emit a 'change' event with a 'date' property corresponding to the
         * first currently selected date chronologically.
         *
         * Other keys are used for navigation:
         *
         * +, or Right will move forward a day,
         * -, or Left will move back a day,
         * Up will move back one week
         * Down will move forward one week
         * Pagedown will move forward one month, selecting the last day of the month if the
         * currently selected date doesn't exist in that month
         * Pageup will move backward one month, selecting the last day of the month if the
         * currently selected date doesn't exist in that month
         * Ctrl + Pagedown will move forward one year, selecting the last day of the month if the
         * currently selected date doesn't exist in that month
         * Ctrl + Pageup will move backward one year, selecting the last day of the month if the
         * currently selected date doesn't exist in that month
         * m will select the first day of the current month
         * h will select the last day of the current month
         * w will select the first day of the current week
         * k will select the last day of the current week
         * y will select the first day of the current year
         * r will select the last day of the current year
         *
         * @param {Event} event
         */
        handleKeyDown: function(event) {
            var date;
            if (event.keyCode === keys.TAB) {
                this._moveFocus(event);
            } else if (event.keyCode === keys.ENTER || event.keyCode === keys.SPACEBAR) {
                event.preventDefault();
                if (event.target === this.calendarTwo.querySelector('.ha-calendar-next-month')) {
                    this.show(this._year, this._maxMonth + 1);
                    this.select(new Date(this._year, this._maxMonth));
                } else if (event.target === this.calendarOne.querySelector('.ha-calendar-previous-month')) {
                    this.show(this._year, this._minMonth - 1);
                    this.select(new Date(this._year, this._minMonth + 1, 0));
                } else if ((date = this._getSelectedDate())) {
                    if (!this._isBlackoutDate(date) && !this._isOtherMonthCell(date)) {
                        this.emit('change', {
                            date: date
                        });
                    }
                }
            } else if (event.keyCode === keys.LEFT ||
                event.keyCode === keys.NUM_PAD_MINUS ||
                event.keyCode === keys.MINUS) {
                event.preventDefault();
                date = this._getSelectedDate();

                if (date) {
                    this.select(new Date(
                        date.getFullYear(),
                        date.getMonth(),
                        date.getDate() - 1
                    ), false, true);
                } else {
                    this.select([new Date(this._year, this._minMonth)]);
                }
            } else if (event.keyCode === keys.RIGHT ||
                event.keyCode === keys.NUM_PAD_PLUS ||
                (event.keyCode === keys.EQUALS && event.shiftKey)) {
                event.preventDefault();
                date = this._getSelectedDate();

                if (date) {
                    this.select([new Date(
                        date.getFullYear(),
                        date.getMonth(),
                        date.getDate() + 1
                    )], false, true);
                } else {
                    this.select([new Date(this._year, this._minMonth)]);
                }
            } else if (event.keyCode === keys.END || event.keyCode === keys.H) {
                event.preventDefault();
                date = this._getSelectedDate();
                if (date && !isNaN(date.getMonth())) {
                    this.select(
                        new Date(date.getFullYear(), date.getMonth() + 1, 0),
                        false,
                        true
                    );
                } else {
                    this.select([new Date(this._year, this._maxMonth + 1, 0)]);
                }
            } else if (event.keyCode === keys.HOME || event.keyCode === keys.M) {
                date = this._getSelectedDate();
                if (date && !isNaN(date.getMonth())) {
                    this.select(
                        new Date(date.getFullYear(), date.getMonth()),
                        false,
                        true
                    );
                } else {
                    this.select(new Date(this._year, this._minMonth));
                }
                event.preventDefault();
            } else if (event.keyCode === keys.PAGEUP) {
                event.preventDefault();
                if (event.ctrlKey) {
                    this._updateSelectionYear(-1);
                } else {
                    this._updateSelectionMonth(-1);
                }

            } else if (event.keyCode === keys.PAGEDOWN) {
                event.preventDefault();
                if (event.ctrlKey) {
                    this._updateSelectionYear(1);
                } else {
                    this._updateSelectionMonth(1);
                }
            } else if (event.keyCode === keys.Y) {
                event.preventDefault();
                this.select(new Date(this._year, 0, 1), false, true);
            } else if (event.keyCode === keys.R) {
                event.preventDefault();
                this.select(new Date(this._year + 1, 0, 0), false, true);
            } else if (event.keyCode === keys.W) {
                event.preventDefault();
                date = this._getSelectedDate();
                if (date) {
                    this.select(new Date(this._year, date.getMonth(), date.getDate() - date.getDay()), false, true);
                }
            } else if (event.keyCode === keys.K) {
                event.preventDefault();
                date = this._getSelectedDate();
                if (date) {
                    this.select(new Date(this._year, date.getMonth(), date.getDate() + (6 - date.getDay())), false, true);
                }
            } else if (event.keyCode === keys.T) {
                event.preventDefault();
                this.select(this._currentDate, false, true);
            } else if (event.keyCode === keys.UP) {
                event.preventDefault();
                date = this._getSelectedDate();
                if (date) {
                    this.select(new Date(date.getFullYear(), date.getMonth(), date.getDate() - 7), false, true);
                }
            } else if (event.keyCode === keys.DOWN) {
                event.preventDefault();
                date = this._getSelectedDate();
                if (date) {
                    this.select(new Date(date.getFullYear(), date.getMonth(), date.getDate() + 7), false, true);
                }
            }
        },

        /**
         * Handles moving the focus to the appropriate element when tabbing. Because the calendar popover is not
         * a child of the calendar element itself, tabbing between components requires manually managing focus.
         *
         * @param {Event} event
         * @private
         */
        _moveFocus: function(event) {
            var shouldRestoreInputFocus = false,
                shouldFocusNextElement = false;
            if (event.target.tagName === 'INPUT') {
                if (!event.shiftKey) {
                    event.preventDefault();
                    event.stopPropagation();
                    this.calendarOne.querySelector('.ha-calendar-previous-month').focus();
                }
            } else if (event.shiftKey) {
                if (event.target.classList.contains('ha-calendar-previous-month')) {
                    shouldRestoreInputFocus = true;
                }
            } else if (event.target.classList.contains('ha-calendar-next-month')) {
                shouldFocusNextElement = true;
            }

            if (shouldRestoreInputFocus || shouldFocusNextElement) {
                if (this._owningInput) {
                    if (shouldRestoreInputFocus) {
                        event.preventDefault();
                        event.stopPropagation();
                    } else {
                        this.emit('ha-calendar-exiting');
                    }
                    this._owningInput.focus();
                }
            }
        },

        /**
         * Will parse the passed in string into a date,
         * or simply return the passed in objec if it is a Date
         *
         * @param {Date | String} dateOrString
         * @returns {Date|null} A Date object or null if the input was not a string
         * or Date object
         * @private
         */
        _parseIfString: function(dateOrString) {
            if (typeof dateOrString === 'string') {
                return new Date(dateOrString);
            } else if (dateOrString && dateOrString.getDate) {
                return dateOrString;
            } else {
                return null;
            }
        },

        /**
         * Increments(or decrements if negative) the displayed year by
         * the passed in amount
         *
         * @param {Number} numYears
         * @private
         */
        _updateSelectionYear: function(numYears) {
            var date,
                newDate;
            if ((date = this._getSelectedDate())) {
                newDate = new Date(date.getFullYear() + numYears, date.getMonth(), date.getDate());

                if (newDate.getMonth() !== date.getMonth() || newDate.getDate() !== date.getDate()) {
                    newDate = new Date(date.getFullYear() + numYears, date.getMonth() + 1, 0);
                }

                this.select([newDate], false, true);
            } else {
                this.select([new Date(this._year + numYears, numYears > 0 ? (this._maxMonth + 1) : (this._minMonth + 1), 0)], false, true);
            }
        },

        /**
         * Increments(or decrements if negative) the displayed month by
         * the passed in amount
         *
         * @param {Number} numMonths
         * @private
         */
        _updateSelectionMonth: function(numMonths) {
            var date,
                newDate;
            if ((date = this._getSelectedDate())) {
                newDate = new Date(date.getFullYear(), date.getMonth() + numMonths, date.getDate());
                // If the day doesn't exist in the target month our month will be one greater
                // than expected. This works going forwards or backwards
                if (newDate.getMonth() === date.getMonth() + (numMonths + 1)) {
                    newDate = new Date(date.getFullYear(), date.getMonth() + (numMonths + 1), 0);
                }

                this.select([newDate], false, true);
            } else {
                this.select([new Date(this._year, numMonths > 0 ? (this._maxMonth + numMonths + 1) : (this._minMonth + numMonths + 1), 0)], false, true);
            }
        }
    });

    return register('ha-double-calendar', HACalendar);
});

define('hui/date-picker',[
    'register-component/v2/register',
    './text-field',
    'object-utils/classes',
    './core/keys',
    './core/deviceUtils',
    './core/event',
    './core/utils',
    './core/timeUtils',
    './popover',
    './date-picker/calendar',
    './date-picker/double-calendar'
], function(register, HATextField, classes, keys, deviceUtils, eventUtil, utils, timeUtils) {
    /* We need this so as not to send invalidate dates to the native date picker */
    var nativeFormatRegExp = /\d{4}-\d{2}-\d{2}/,
        supportedDateFormats = [
            'dd/mm/yyyy',
            'mm/dd/yyyy',
            'yyyy/mm/dd',
            'dd-mm-yyyy',
            'mm-dd-yyyy',
            'yyyy-mm-dd',
            'dd.mm.yyyy',
            'mm.dd.yyyy',
            'yyyy.mm.dd'
        ];

    /**
     * Return the target related of the event with IE compliance way.
     *
     * @argument {Event} event that will be try to take the related target.
     * @returns {Object} The related target of the event.
     * @private
     */
    function _getSafeTargetFromEvent(event) {
        return document.activeElement || event.relatedTarget || event.explicitOriginalTarget;
    }

    /**
     * This component allows the user to select date on a calendar or by typing it in. The API, detailed
     * in DatePicker.md, allows for applying special styling to certain dates, validating entered dates, properly
     * formatting selected dates for display, limiting the range of dates that can be selected, etc.
     * @type {Object}
     */
    var HADatePicker = classes.createObject(HATextField.prototype, {

        init: function _() {

            _.super(this);

            /**
             * Holds validation functions
             *
             * @type {Array}
             */
            this._validatorFunctions = [];

            /**
             * Boolean flag to indicate if embedded within Android WebView.
             *
             * @type {Boolean}
             */
            this._isAndroidWebView = deviceUtils.isAndroidWebView();

            this._isMobileNotAndroidWebView = deviceUtils.isHandheld() && !this._isAndroidWebView;

            this.setupProperties({
                /**
                 * The maximum valid date value (ISO 8601 timestamp)
                 * @type {string}
                 */
                maxDate: {
                    default: '',
                    type: String,
                    change: function(newValue) {
                        var newDate = newValue ? timeUtils.parseISODateString(newValue) : null,
                            calendar = this._getCalendar();

                        if (newDate) {
                            if (calendar) {
                                calendar.maxDate = timeUtils.formatDateAsEsDateString(newDate);
                            }
                            this.startValidation();
                        } else {
                            if (calendar) {
                                calendar.maxDate = '';
                            }
                            this.stopValidation();
                        }

                    }
                },

                /**
                 * The minimum valid date value (ISO 8601 timestamp)
                 * @type {string}
                 */
                minDate: {
                    default: '',
                    type: String,
                    change: function(newValue) {
                        var newDate = newValue ? timeUtils.parseISODateString(newValue) : null,
                            calendar = this._getCalendar();

                        if (newDate) {
                            if (calendar) {
                                calendar.minDate = timeUtils.formatDateAsEsDateString(newDate);
                            }
                            this.startValidation();
                        } else {
                            if (calendar) {
                                calendar.minDate = '';
                            }
                            this.stopValidation();
                        }
                    }
                },

                /**
                 * Whether or not to display buttons for changing the date by a year at a time.
                 * Defaults to false
                 *
                 * @type {Boolean}
                 */
                showYearNavigation: {
                    default: false,
                    type: Boolean,
                    change: function(showYearNavigation) {
                        if (this._isMobileNotAndroidWebView) {
                            if (showYearNavigation) {
                                console.warn('showYearNavigation API isn\'t supported on mobile devices');
                            }

                            return;
                        }

                        if (this._getCalendar()) {
                            this._getCalendar().showYearNavigation = showYearNavigation;
                        }
                    }
                },

                /**
                 * If true, uses the double calendar instead of a single calendar,
                 * needs to be set before the element's attachedCallback
                 *
                 * @type {Boolean}
                 */
                useDoubleCalendar: {
                    default: false,
                    type: Boolean,
                    change: function(useDoubleCalendar) {
                        if (deviceUtils.isHandheld()) {
                            if (useDoubleCalendar) {
                                console.warn('useDoubleCalendar API isn\'t supported on mobile devices');
                            }

                            return;
                        }

                        var calendar = this._getCalendar();

                        if (useDoubleCalendar) {
                            this.classList.add('ha-double-calendar-date-picker');
                            if (calendar && calendar.nodeName !== 'HA-DOUBLE-CALENDAR') {
                                calendar.parentNode.removeChild(calendar);
                                this._popoverElement.section = this.ownerDocument.createElement('ha-double-calendar');
                            } else if (!calendar) {
                                this._popoverElement.section = this.ownerDocument.createElement('ha-double-calendar');
                            }
                        } else {
                            this.classList.remove('ha-double-calendar-date-picker');
                            if (calendar && calendar.nodeName !== 'HA-CALENDAR') {
                                calendar.parentNode.removeChild(calendar);
                                this._popoverElement.section = this.ownerDocument.createElement('ha-calendar');
                            } else if (!calendar) {
                                this._popoverElement.section = this.ownerDocument.createElement('ha-calendar');
                            }
                        }

                        this._getCalendar()._owningInput = this.querySelector('input');

                        Array.prototype.forEach.call(this._getCalendar().querySelectorAll('[id*=gridNode]'), function(gridNode) {
                            gridNode.removeAttribute('tabindex');
                        });
                        this._setupListeners();
                    }
                },

                /**
                 * This label is announced when the month/year navigation buttons
                 * are focused, indicating to the user that they need to focus the input
                 * to select a data.
                 *
                 * @type {String}
                 */
                navigationAriaDescription: {
                    default: 'shift focus to input to change calendar dates',
                    type: String,
                    change: function(text) {
                        if (this._isMobileNotAndroidWebView) {
                            if (text !== 'shift focus to input to change calendar dates') {
                                console.warn('navigationAriaDescription API isn\'t supported on mobile devices');
                            }

                            return;
                        }

                        var calendars = this.querySelectorAll('ha-calendar'),
                            calendar,
                            componentId,
                            node,
                            i;

                        for (i = 0; i < calendars.length; i++) {
                            calendar = calendars[i];
                            componentId = calendar && calendar.componentId;
                            node = componentId && this.querySelector('#' + 'dates-navigation' + componentId);
                            if (node) {
                                node.textContent = text;
                            }
                        }
                    }
                },

                /**
                 * Set the date format to one of the predefined date formats. Internally, this will set `dateFormatter`
                 * and `datePattern`. If this value is set to a non-blank value, you will not be allowed to set `dateFormatter` or
                 * `datePattern` manually. Predefined date formats are, `dd/mm/yyyy`, `mm/dd/yyyy`, `yyyy/mm/dd`, `dd-mm-yyyy`, `mm-dd-yyyy`, `yyyy-mm-dd`, `dd.mm.yyyy`, `mm.dd.yyyy`, `yyyy.mm.dd`.
                 *
                 * @type {String}
                 */
                dateFormat: {
                    default: '',
                    type: String,
                    change: function(text) {
                        var oldValue = this.value;

                        if (text) {
                            var formatSupported = false,
                                newValue = text.toLowerCase();

                            // Ensure that the new format is from the supported list
                            formatSupported = supportedDateFormats.some(function(format) {
                                return format === newValue;
                            });

                            if (formatSupported) {
                                var regEx = timeUtils.regExForPattern(newValue);

                                this._dateFormat = '';
                                this.placeholder = text.toUpperCase();
                                this.dateFormatter = function(date) {
                                    return timeUtils.formatDateAsPattern(date, newValue);
                                };
                                this.datePattern = regEx.regEx;
                                this._dateFormat = newValue;
                            } else {
                                console.warn('Attempted to use a dateFormat that was not supported, ' + newValue);
                            }
                        } else {
                            this._dateFormat = '';
                        }

                        this.value = oldValue;
                    }
                }
            });

            this._dateFormat = '';
        },

        postRender: function _() {
            _.super(this);

            this.stopListening();

            if (deviceUtils.isHandheld()) {
                this.classList.add('mobile-date-picker');
            }

            var popover = this._popoverElement,
                calendar = this._getCalendar(),
                patternAttribute = this.getAttribute('pattern') || this.getAttribute('_pattern'),
                input = this.querySelector('input'),
                value = this.getAttribute('value'),
                placeholder = this.getAttribute('placeholder'),
                self = this;

            if (this._isMobileNotAndroidWebView) {
                // HUI-4394: If Android WebWiew don't set native date
                this.type = 'date';
            } else {
                if (calendar) {
                    calendar.parentNode.removeChild(calendar);
                }
                if (popover) {
                    popover.parentNode.removeChild(popover);
                }
                popover = this.ownerDocument.createElement('ha-popover');
                calendar = this.useDoubleCalendar ? this.ownerDocument.createElement('ha-double-calendar') :
                    this.ownerDocument.createElement('ha-calendar');
                Array.prototype.forEach.call(calendar.querySelectorAll('[id*=gridNode]'), function(gridNode) {
                    gridNode.removeAttribute('tabindex');
                });
                popover.section = calendar;
                popover.targetSelector = '#' + input.id;
                popover._closeOnBlur = false;
                popover._noAutoFocusFirstTabbableElementOnShow = true;
                // This prevents the popover from refocusing the input when it closes.
                // We handle that ourselves, to avoid it getting focused after tabbing out
                // of the calendar and to prevent the calendar from immediately appearing
                // again after it is hidden.
                popover._noAutoFocusLastActiveElementOnClose = true;
                this.appendChild(popover);
                this._popover = popover;
            }

            // Clean up pattern attribute. The validation module assumes
            // this pattern should be validated against the value of this component,
            // but in this case it should not.
            if (patternAttribute) {
                this.datePattern = patternAttribute;
                this.pattern = '';
                this.removeAttribute('pattern');
                this.setAttribute('_pattern', patternAttribute);
            } else {
                this.datePattern = /^$|^(0[1-9]|1[012])[- /.](0[1-9]|[12][0-9]|3[01])[- /.]((?:19|20)\d\d)$/;
            }

            this._rendered = true;

            if (value) {
                this.value = value;
            }

            // Set up validator function, binding to the component
            this.validator = function() {
                return self._validator.call(this, self);
            };
            this.placeholder = placeholder ? placeholder : 'MM/DD/YYYY';

            this._setupListeners();
        },

        detachedCallback: function() {
            var popover = this._popoverElement;
            if (popover && popover.parentElement) {
                popover.parentElement.removeChild(popover);
            }
        },

        /**
         * Hides the calendar popover
         */
        closeCalendar: function() {
            if (this._isMobileNotAndroidWebView) {
                console.warn('closeCalendar API isn\'t supported on mobile devices');
                return;
            }

            this._popoverElement.close();
        },

        /**
         * Selects the specified date on the calendar, without
         * emitting an event or updating the component's value
         *
         * @param {Date} date The date to select
         */
        select: function(date) {
            if (this._isMobileNotAndroidWebView) {
                return;
            }

            var calendar = this._getCalendar();
            if (calendar) {
                calendar.select(date);
                return true;
            }

            return false;
        },

        /**
         * Sets the 'preselection' date on the calendar
         *
         * @param {Date} date The date to 'preselect'
         */
        preselect: function(date) {
            if (this._isMobileNotAndroidWebView) {
                console.warn('preselect API isn\'t supported on mobile devices');
                return;
            }

            var calendar = this._getCalendar();
            if (calendar) {
                calendar.preselection = date;
                return true;
            }
            return false;
        },

        /**
         * Sets the 'postselection' date on the calendar
         *
         * @param {Date} date The date to 'postselect'
         */
        postselect: function(date) {
            if (this._isMobileNotAndroidWebView) {
                console.warn('postselect API isn\'t supported on mobile devices');
                return;
            }

            var calendar = this._getCalendar();
            if (calendar) {
                calendar.postselection = date;
                return true;
            }
            return false;
        },
        /**
         * Shows the calendar popover
         */
        showCalendar: function() {
            if (this._isMobileNotAndroidWebView) {
                console.warn('showCalendar API isn\'t supported on mobile devices');
                return;
            }

            this._popoverElement.show();
            this._popoverElement.tabIndex = -1;
            this._popoverElement.lastFocus = null;
        },

        /**
         * Updates the calendars display to the next month
         */
        showNextMonth: function() {
            if (this._isMobileNotAndroidWebView) {
                console.warn('showNextMonth API isn\'t supported on mobile devices');
                return;
            }

            if (this._getCalendar().nodeName === 'HA-CALENDAR') {
                this._getCalendar().month += 1;
            } else {
                this._getCalendar().show(this._getCalendar().year, this._getCalendar().maxMonth + 1);
            }
        },

        /**
         * Updates the calendars display to the previous month
         */
        showPreviousMonth: function() {
            if (this._isMobileNotAndroidWebView) {
                console.warn('showPreviousMonth API isn\'t supported on mobile devices');
                return;
            }

            if (this._getCalendar().nodeName === 'HA-CALENDAR') {
                this._getCalendar().month -= 1;
            } else {
                this._getCalendar().show(this._getCalendar().year, this._getCalendar().minMonth - 1);
            }
        },

        /**
         * Parses a date object into string format for display.
         * Parses to MM/DD/YYYY format by default, or delegates to
         * the formatter argument if present
         *
         * @param {Date} date The date to parse
         * @param {Function} formatter optional function to override default formatting
         * behavior
         * @private
         */
        format: function(date, formatter) {
            if (formatter) {
                return formatter(date);
            } else {
                var month = date.getMonth() >= 9 ? date.getMonth() + 1 : '0' + (date.getMonth() + 1),
                    day = date.getDate() >= 10 ? date.getDate() : '0' + date.getDate(),
                    year = date.getFullYear();
                return '' + month + '/' + day + '/' + year;
            }
        },

        _getCalendar: function() {
            var popover = this._popoverElement;
            return popover && (popover.querySelector('ha-double-calendar') || popover.querySelector('ha-calendar'));
        },

        get _popoverElement() {
            return this._popover || this.querySelector('ha-popover');
        },

        _getInput: function() {
            return this.querySelector('input');
        },

        /**
         * Formats a date to YYYY-MM-DD to match the API for the native date input element
         *
         * @param {Date} date A Date object
         * @return {String} A string representing the date in the local timezone of the format YYYY-MM-DD
         */
        _nativeDateInputFormat: function(date) {
            var month = date.getMonth() + 1,
                day = date.getDate();
            return date.getFullYear() + '-' + ((month < 10) ? '0' + month : month) + '-' + (day < 10 ? '0' + day : day);
        },

        _setupListeners: function() {
            this._validationListenersAdded = false;
            this.stopListening();
            if (this._closeListener) {
                this._closeListener.remove();
            }
            var popover = this._popoverElement,
                calendar = this._getCalendar(),
                input = this.querySelector('input'),
                self = this,
                focusableElements = [
                    input,
                    popover
                ],
                handheld = deviceUtils.isHandheld(),
                closeIfOutsideOfDatePicker = function(event) {
                    setTimeout(function() {
                        var activeElement = _getSafeTargetFromEvent(event),
                            currentNode = activeElement,
                            popover = self._popoverElement,
                            inPopover = false,
                            isInputFocused = activeElement === input;
                        if (!isInputFocused) {
                            while (currentNode) {
                                if (currentNode === popover) {
                                    inPopover = true;
                                    break;
                                }
                                currentNode = currentNode.parentNode;
                            }
                        }

                        if (!isInputFocused && !inPopover) {
                            if (popover.openOrOpening) {
                                self._dontRefocusInput = true;
                                self.closeCalendar();
                            }
                        }
                    }, 100);
                };

            if (this._isMobileNotAndroidWebView) {
                //This event listener is created for preventing the change events from bubbling up.
                this.listenTo(input, 'change', function(event) {
                    var date = input.value;
                    this.value = date;
                    if (this.value && handheld) {
                        this.classList.add('mobile-text-field-content');
                    } else {
                        this.classList.remove('mobile-text-field-content');
                    }
                    this.reportValidity();
                    event.stopPropagation();
                    this.emit('change', {
                        date: date
                    });
                }.bind(this));

                // Only add immediate focus utils if iOS 9
                deviceUtils.addiOS9ImmediateFocus();

                this._setUpMobileListeners();
            } else {
                focusableElements.forEach(function(element) {
                    this.listenTo(element, 'blur', closeIfOutsideOfDatePicker, true);
                }, this);

                //This event listener is created for preventing the change events from bubbling up.
                this.listenTo(input, 'change', function(evt) {
                    evt.stopPropagation();
                    if (this._isAndroidWebView) {
                        if (this.value) {
                            this.classList.add('mobile-text-field-content');
                        } else {
                            this.classList.remove('mobile-text-field-content');
                        }
                    }
                }.bind(this));

                this.listenTo(calendar, 'change', function(event) {
                    var date = event.date;
                    this.value = date;
                    this.closeCalendar();
                    this.reportValidity();
                    event.stopPropagation();
                    this.emit('change', {
                        date: date
                    });
                }.bind(this));

                this.listenTo(calendar, 'ha-calendar-exiting', function() {
                    this._dontOpenCalendar = true;
                    this._dontRefocusInput = true;
                    popover.close();
                }.bind(this));

                this.listenTo(input, 'focus', function() {
                    if (this._dontOpenCalendar) {
                        this._dontOpenCalendar = false;
                        return;
                    }
                    if (this._isAndroidWebView) {
                        this.classList.add('mobile-text-field-focused');
                    }
                    var inputValue = this._getInput().value,
                        date;
                    if ((!this.datePattern || this.datePattern.test(inputValue)) && !isNaN((date = new Date(inputValue)).getFullYear()) && !this._popoverElement.classList.contains('visible')) {
                        // HUI-4224: Create date based on provided format. Otherwise,
                        // date is based on mm/dd/yyyy which may be incorrect
                        if (this._dateFormat) {
                            date = new Date(timeUtils.formatDateAsPattern(date, this._dateFormat));
                        }
                        calendar.select(date, false, true);
                    }
                    this.showCalendar();
                }.bind(this));

                this.listenTo(input, 'input', function(event) {
                    var userInput = event.target.value,
                        date = timeUtils.parsePatternAsDate(this._dateFormat, userInput);
                    if (!isNaN(date.getTime()) && (!this.datePattern || userInput.match(this.datePattern))) {
                        this.value = userInput;
                        calendar.select(date, false, true);
                        this.emit('change', {
                            date: date
                        });
                    }
                }.bind(this));

                this.listenTo(input, 'keydown', function(event) {
                    if (popover.openOrOpening) {
                        calendar.handleKeyDown(event);
                    } else if (event.keyCode === keys.ENTER) {
                        this.showCalendar();
                    }
                    if (keys.isLetter(event.keyCode)) {
                        event.preventDefault();
                    }
                }.bind(this));

                // Since event.keyCode always equals 229 in Android browser, so this is polyfill for it.
                if (this._isAndroidWebView) {
                    this.listenTo(input, 'keyup', function(event) {
                        event.target.value = event.target.value.replace(/[a-zA-Z]+/g, '');
                    }.bind(this));

                    this.listenTo(input, 'blur', function() {
                        this.classList.remove('mobile-text-field-focused');
                    }.bind(this));
                }

                this._closeListener = eventUtil.on(popover, 'close', function() {
                    if (this._dontRefocusInput) {
                        this._dontRefocusInput = false;
                        return;
                    }
                    var input = this.querySelector('input');
                    if (input && document.activeElement !== input) {
                        this._dontOpenCalendar = true;
                        input.focus();
                    }
                }.bind(this));

                if (utils.validationRequired(this)) {
                    this.startValidation();
                }
            }
        },

        /**
         * Iterates through a component's validator functions, stopping if one is found that returns false,
         * and returns whether the component passed validation. Additional validation functions can be provided
         * by appending them to the component's `_validatorFunctions` array. Currently, this API is used only
         * internally and is therefore private.
         * @param {DatePicker} component - The component to validate
         * @returns {boolean} Whether the component passes validation
         * @private
         */
        _validator: function(component) {
            var passing = true,
                i = 0;
            while (i < component._validatorFunctions.length && (passing = component._validatorFunctions[i].call(this))) {
                i++;
            }

            return passing;
        },

        /**
         * Optional function that is used to format date values if provided
         *
         * @type {Function}
         */
        set dateFormatter(dateFormatter) {
            if (this._dateFormat) {
                console.warn('dateFormatter isn\'t available when using dateFormat');
                return;
            }

            this._dateFormatter = dateFormatter;
        },

        get dateFormatter() {
            return this._dateFormatter;
        },

        get monthAbbreviations() {
            if (this._isMobileNotAndroidWebView) {
                console.warn('monthAbbreviations API isn\'t supported on mobile devices');
                return undefined;
            }

            return this._getCalendar().monthAbbreviations;
        },

        /**
         * Month abbreviations for display in tooltips, passed through to
         * calendar(s)
         *
         * @param {Array} monthAbbreviations
         */
        set monthAbbreviations(monthAbbreviations) {
            if (this._isMobileNotAndroidWebView) {
                console.warn('monthAbbreviations API isn\'t supported on mobile devices');
                return;
            }

            this._getCalendar().monthAbbreviations = monthAbbreviations;
        },

        get monthLabels() {
            if (this._isMobileNotAndroidWebView) {
                console.warn('monthLabels API isn\'t supported on mobile devices');
                return undefined;
            }

            return this._getCalendar().monthLabels;
        },

        /**
         * Month labels for display in the navigation section of the calendars, passed through to
         * calendar(s)
         *
         * @param {Array} monthLabels
         */
        set monthLabels(monthLabels) {
            if (this._isMobileNotAndroidWebView) {
                console.warn('monthLabels API isn\'t supported on mobile devices');
                return;
            }

            this._getCalendar().monthLabels = monthLabels;
        },

        get dayOfWeekLabels() {
            if (this._isMobileNotAndroidWebView) {
                console.warn('dayOfWeekLabels API isn\'t supported on mobile devices');
                return undefined;
            }

            return this._getCalendar().dayOfWeekLabels;
        },

        /**
         * Labels for each day of the week, passed through to
         * calendar(s)
         *
         * @param {Array} dayOfWeekLabels
         */
        set dayOfWeekLabels(dayOfWeekLabels) {
            if (this._isMobileNotAndroidWebView) {
                console.warn('dayOfWeekLabels API isn\'t supported on mobile devices');
                return;
            }

            this._getCalendar().dayOfWeekLabels = dayOfWeekLabels;
        },

        /**
         * These dates have special blackout styling applied
         * and are not selectable
         *
         * @type {Array}
         */
        set blackoutDates(dates) {
            if (this._isMobileNotAndroidWebView) {
                console.warn('blackoutDates API isn\'t supported on mobile devices');
                return undefined;
            }

            this._getCalendar().blackoutDates = dates;
        },

        get blackoutDates() {
            if (this._isMobileNotAndroidWebView) {
                console.warn('blackoutDates API isn\'t supported on mobile devices');
                return;
            }

            return this._getCalendar().blackoutDates;
        },

        /**
         * These are dates that are not directly selected,
         * but are in the selected range or that should be  highlighted
         * for some other reason
         *
         * @type {Array}
         */
        set highlightedDates(dates) {
            if (this._isMobileNotAndroidWebView) {
                console.warn('highlightedDates API isn\'t supported on mobile devices');
                return;
            }

            this._getCalendar().highlightedDates = dates;
        },

        get highlightedDates() {
            if (this._isMobileNotAndroidWebView) {
                console.warn('highlightedDates API isn\'t supported on mobile devices');
                return undefined;
            }

            return this._getCalendar().highlightedDates;
        },

        /**
         * Notable dates are displayed with orange text, these are things like
         * holidays, birthdays, etc.
         *
         * @type {Array}
         */
        set notableDates(dates) {
            if (this._isMobileNotAndroidWebView) {
                console.warn('notableDates API isn\'t supported on mobile devices');
                return;
            }

            if (this._getCalendar()) {
                this._getCalendar().notableDates = dates;
            }
        },

        get notableDates() {
            if (this._isMobileNotAndroidWebView) {
                console.warn('notableDates API isn\'t supported on mobile devices');
                return undefined;
            }

            if (this._getCalendar()) {
                return this._getCalendar().notableDates;
            }
        },

        /**
         * The pattern that input dates should match. Note that accessing the value of
         * this component will always return an ISO date string; this pattern will be
         * used to validate the value of the text field itself.
         *
         * @type {RegExp | String}
         */
        set datePattern(pattern) {
            if (this._isMobileNotAndroidWebView) {
                console.warn('datePattern API isn\'t supported on mobile devices');
                return;
            }

            if (this._dateFormat) {
                console.warn('datePattern isn\'t available when using dateFormat');
                return;
            }

            var self = this;
            if (this._formatValidator) {
                this._validatorFunctions.splice(this._validatorFunctions.indexOf(this._formatValidator), 1);
            }

            if (pattern && typeof pattern === 'string') {
                this._pattern = new RegExp(pattern);
            } else {
                this._pattern = pattern;
            }

            if (pattern) {
                this._formatValidator = function() {
                    var valid = self._pattern.test(self._getInput().value);
                    if (!valid) {
                        this.errorMessage = 'Invalid date';
                    }
                    return valid;
                };
                this._validatorFunctions.push(this._formatValidator);
                this.startValidation();
            } else {
                this.stopValidation();
            }
        },

        get datePattern() {
            return this._pattern;
        },

        /**
         * A map of dates in string format(any format parseable to a date via new Date(string)
         * is acceptable) to tooltip text. The tooltip text will be displayed inside of an HATooltip when the
         * corresponding date is hovered.
         *
         * @type {Object}
         */
        set tooltips(tooltips) {
            if (this._isMobileNotAndroidWebView) {
                console.warn('tooltips API isn\'t supported on mobile devices');
                return;
            }

            if (this._getCalendar()) {
                this._getCalendar().tooltips = tooltips;
            }
        },

        get tooltips() {
            if (this._isMobileNotAndroidWebView) {
                console.warn('tooltips API isn\'t supported on mobile devices');
                return undefined;
            }

            if (this._getCalendar()) {
                return this._getCalendar().tooltips;
            }
        },

        /**
         * The value of this date picker: Can be passed as a string or Date object, but is always returned as an
         * ISO date string.
         *
         * @param {String | Date} value
         */
        set value(value) {
            // Value is an attribute so it gets set before we finish rendering it. That's bad,
            // so do nothing when that happens
            if (!this._rendered) {
                return;
            }

            var formatted,
                nativeFormat,
                date,
                input;
            if (typeof value === 'string' && value) {
                date = timeUtils.parseISODateString(value) || new Date(value);
            } else if (value) {
                date = value;
            }
            if (date) {
                if (isNaN(date.getTime())) {
                    console.error('ha-date-picker passed invalid date string');
                    return;
                }
                formatted = this.format(date, this.dateFormatter);
                nativeFormat = this._nativeDateInputFormat(date);

                this.select(date);
            } else {
                formatted = nativeFormat = '';
            }

            input = this._getInput();

            if (this._isMobileNotAndroidWebView) {
                if (nativeFormatRegExp.test(nativeFormat) && nativeFormat !== input.value) {
                    input.value = nativeFormat;
                }
            } else {
                if (formatted !== input.value) {
                    input.value = formatted;
                }
            }

            if (this.getAttribute('value') !== nativeFormat) {
                this.setAttribute('value', nativeFormat);
            }

            this._calculateMobileHeight(input.value);
        },

        get value() {
            var value = this._getInput().value,
                date = (this._isMobileNotAndroidWebView) ? (value ? timeUtils.parseISODateString(value) : new Date('')) : timeUtils.parsePatternAsDate(this._dateFormat, value);
            if (isNaN(date.getTime())) {
                return value;
            } else {
                return this._nativeDateInputFormat(date);
            }
        }
    });

    return register('ha-date-picker', HADatePicker);
});

define('hui/date-range-picker',[
    'register-component/v2/register',
    'register-component/v2/UIComponent',
    'object-utils/classes',
    './core/deviceUtils',
    './date-picker'
], function(register, UIComponent, classes, deviceUtils) {

    /**
     * This component allows the user to select a range of dates, delimited by a start date and an end date, on two
     * contained date picker components. DateRangePicker.md and DatePicker.md outline the provided API, which allows for
     * applying special styling to certain dates, validating entered dates, properly formatting selected dates for
     * display, limiting the range of dates that can be selected, etc.
     * @type {Object}
     */
    var HADateRangePicker = classes.createObject(UIComponent, {
        init: function _() {
            _.super(this);

            this.setupProperties({

                /**
                 * Message to be displayed when a required field is empty
                 * @type {String}
                 */
                requiredMessage: {
                    default: 'Required Field',
                    change: function(requiredMessage) {
                        this._passThrough('requiredMessage', requiredMessage);
                    },
                    type: String
                },

                /**
                 * Message to be displayed when a field is invalid
                 * @type {String}
                 */
                invalidMessage: {
                    default: 'Invalid Value',
                    change: function(invalidMessage) {
                        this._passThrough('invalidMessage', invalidMessage);
                    },
                    type: String
                },

                /**
                 * Label displayed over start date picker
                 *
                 * @type {String}
                 */
                startDateLabel: {
                    default: 'Start date',
                    change: function(label) {
                        var startDatePicker = this._getStartDatePicker();
                        if (startDatePicker) {
                            startDatePicker.label = label;
                        }
                    }
                },

                /**
                 * Label displayed over end date picker
                 *
                 * @type {String}
                 */
                endDateLabel: {
                    default: 'End date',
                    change: function(label) {
                        var endDatePicker = this._getEndDatePicker();
                        if (endDatePicker) {
                            endDatePicker.label = label;
                        }
                    }
                },

                /**
                 * Disabled indicates whether the field is disabled
                 * @type {Boolean}
                 */
                disabled: {
                    default: false,
                    type: Boolean,
                    change: function(newValue) {
                        this._passThrough('disabled', newValue);
                    }
                },

                required: {
                    default: false,
                    type: Boolean,
                    change: function(newValue) {
                        this._passThrough('required', newValue);
                    }
                },

                maxLength: {
                    default: 524288,
                    type: Number,
                    change: function(newvalue) {
                        this._passThrough('maxLength', newvalue);
                    }
                },

                optional: {
                    default: false,
                    type: Boolean,
                    change: function(newValue) {
                        this._passThrough('optional', newValue);
                    }
                },

                /**
                 * declares the text that will be used to describe optional fields
                 * @type {String}
                 */
                labelOptional: {
                    default: 'optional',
                    change: function(newValue) {
                        this._passThrough('labelOptional', newValue);
                    }
                },

                /**
                 * This sets the name for the starting datepicker
                 * @type {String}
                 */
                startDateName: {
                    default: '',
                    change: function(newValue) {
                        var startDatePicker = this._getStartDatePicker();
                        if (startDatePicker) {
                            startDatePicker.name = newValue;
                        }
                    }
                },

                /**
                 * This sets the name for the ending datepicker
                 * @type {String}
                 */
                endDateName: {
                    default: '',
                    change: function(newValue) {
                        var endDatePicker = this._getEndDatePicker();
                        if (endDatePicker) {
                            endDatePicker.name = newValue;
                        }
                    }
                },

                /**
                 * this sets the autoComplete for the text input
                 * @type {String}
                 */
                autoComplete: {
                    default: 'on',
                    change: function(newValue) {
                        this._passThrough('autoComplete', newValue);
                    }
                },

                /**
                 * this sets the size for the text input
                 * @type {Number}
                 */
                size: {
                    default: 20,
                    type: Number,
                    change: function(newValue) {
                        this._passThrough('size', newValue);
                    }
                },

                /**
                 * placeholder for the text-field control
                 * @type {String}
                 */
                placeholder: {
                    default: 'MM/DD/YYYY',
                    change: function(newValue) {
                        this._passThrough('placeholder', newValue);
                    }
                },

                /**
                 * This label is announced when the month/year navigation buttons
                 * are focused, indicating to the user that they need to focus the input
                 * to select a data.
                 *
                 * @type {String}
                 */
                navigationAriaDescription: {
                    default: 'shift focus to input to change calendar dates',
                    type: String,
                    change: function(text) {
                        this._passThrough('navigationAriaDescription', text);
                    }
                },

                /**
                 * Set the date format to one of the predefined date formats. Internally, this will set `dateFormatter`
                 * and `datePattern`. If this value is set to a non-blank value, you will not be allowed to set `dateFormatter` or
                 * `datePattern` manually. Predefined date formats are, `dd/mm/yyyy`, `mm/dd/yyyy`, `yyyy/mm/dd`, `dd-mm-yyyy`, `mm-dd-yyyy`, `yyyy-mm-dd`, `dd.mm.yyyy`, `mm.dd.yyyy`, `yyyy.mm.dd`.
                 *
                 * @type {String}
                 */
                dateFormat: {
                    default: '',
                    type: String,
                    change: function(text) {
                        this._passThrough('dateFormat', text);
                    }
                }
            });
        },

        postRender: function _() {
            _.super(this);

            var startDatePicker = this._getStartDatePicker(),
                endDatePicker = this._getEndDatePicker(),
                todaysDate = new Date(Date.now()),
                handheld = deviceUtils.isHandheld();
            if (startDatePicker) {
                startDatePicker.parentNode.removeChild(startDatePicker);
            }

            if (endDatePicker) {
                endDatePicker.parentNode.removeChild(endDatePicker);
            }
            startDatePicker = this.ownerDocument.createElement('ha-date-picker');
            endDatePicker = this.ownerDocument.createElement('ha-date-picker');

            if (!handheld) {
                startDatePicker.useDoubleCalendar = endDatePicker.useDoubleCalendar = true;
            }

            this.appendChild(startDatePicker);
            this.appendChild(endDatePicker);

            if (!handheld) {
                this._getEndDatePicker().select(new Date(
                    todaysDate.getFullYear(),
                    todaysDate.getMonth(),
                    todaysDate.getDate() + 1
                ));
            }

            this.setAttribute('role', 'group');
            if (!this.hasAttribute('aria-label')) {
                this.setAttribute('aria-label', 'Select date range');
            }
        },

        attachedCallback: function _() {
            _.super(this);

            var startDatePicker = this._getStartDatePicker(),
                endDatePicker = this._getEndDatePicker();

            this.listenTo(startDatePicker, 'change', function(event) {
                event.stopPropagation();

                if (!deviceUtils.isHandheld()) {
                    endDatePicker.preselect(event.date);
                }

                this.emit('change', {
                    date: event.date,
                    dateType: 'start'
                });
            }.bind(this));

            this.listenTo(endDatePicker, 'change', function(event) {
                event.stopPropagation();

                if (!deviceUtils.isHandheld()) {
                    startDatePicker.postselect(event.date);
                }

                this.emit('change', {
                    date: event.date,
                    dateType: 'end'
                });
            }.bind(this));
        },

        showNextMonth: function() {
            this._getStartDatePicker().showNextMonth();
            this._getEndDatePicker().showNextMonth();
        },

        showPreviousMonth: function() {
            this._getStartDatePicker().showPreviousMonth();
            this._getEndDatePicker().showPreviousMonth();
        },

        /**
         * Gets the range picker that selects the start date of the
         * range
         * @returns {Element}
         */
        _getStartDatePicker: function() {
            return this.querySelector('ha-date-picker');
        },

        /**
         * Gets the range picker that selects the end date of the range
         * @returns {Element}
         */
        _getEndDatePicker: function() {
            return this.querySelectorAll('ha-date-picker')[1];
        },

        /**
         * Passes the specified value through to both
         * range pickers
         *
         * @param {String} key
         * @param {*} value
         * @private
         */
        _passThrough: function(key, value) {
            var startDatePicker = this._getStartDatePicker(),
                endDatePicker =  this._getEndDatePicker();

            if (startDatePicker) {
                startDatePicker[key] = value;
            }
            if (endDatePicker) {
                endDatePicker[key] = value;
            }
        },

        /**
         * Returns the current aria-label
         *
         * @type {String}
         */
        get ariaLabel() {
            return this.getAttribute('aria-label');
        },

        /**
         * Allows the aria label to be set programmatically
         *
         * @param {String} label
         */
        set ariaLabel(label) {
            this.setAttribute('aria-label', label);
        },

        get monthAbbreviations() {
            return this._monthAbbreviations;
        },

        /**
         * Month abbreviations for display in tooltips, passed through to
         * date pickers
         *
         * @param {Array} monthAbbreviations
         */
        set monthAbbreviations(monthAbbreviations) {
            this._monthAbbreviations = monthAbbreviations;
            this._passThrough('monthAbbreviations', monthAbbreviations);
        },

        get monthLabels() {
            return this._monthLabels;
        },

        /**
         * Month labels for display in the navigation section of the calendars, passed through to
         * date pickers
         *
         * @param {Array} monthLabels
         */
        set monthLabels(monthLabels) {
            this._monthLabels = monthLabels;
            this._passThrough('monthLabels', monthLabels);
        },

        get dayOfWeekLabels() {
            return this._dayOfWeekLabels;
        },

        /**
         * Labels for each day of the week, passed through to
         * date pickers
         *
         * @param {Array} dayOfWeekLabels
         */
        set dayOfWeekLabels(dayOfWeekLabels) {
            this._dayOfWeekLabels = dayOfWeekLabels;
            this._passThrough('dayOfWeekLabels', dayOfWeekLabels);
        },

        /**
         * Blackout dates that cannot be selected, passed through to
         * date pickers
         *
         * @param {Array | Date | String} dates
         */
        set blackoutDates(dates) {
            this._blackoutDates = dates;
            this._passThrough('blackoutDates', dates);
        },

        get blackoutDates() {
            return this._blackoutDates;
        },

        /**
         * Notable dates that have special styling, passed through to
         * date pickers
         *
         * @param {Array | Date | String} dates
         */
        set notableDates(dates) {
            this._notableDates = dates;
            this._passThrough('notableDates', dates);
        },

        get notableDates() {
            return this._notableDates;
        },

        /**
         * Map of date strings to tooltips to display over date cells, passed through to
         * date pickers
         *
         * @param {Object} tooltips
         */
        set tooltips(tooltips) {
            this._tooltips = tooltips;
            this._passThrough('tooltips', tooltips);
        },

        get tooltips() {
            return this._tooltips;
        },

        /**
         * Specifies the pattern the value should match
         * @type {String}
         */
        set datePattern(newValue) {
            this._passThrough('datePattern', newValue);
        },

        get datePattern() {
            return this._getStartDatePicker().datePattern;
        },

        /**
         * Specifies the earliest date allowed
         */
        set minDate(newValue) {
            this._passThrough('minDate', newValue);
        },

        get minDate() {
            return this._getStartDatePicker().minDate;
        },

        /**
         * Specifies the latest date allowed
         */
        set maxDate(newValue) {
            this._passThrough('maxDate', newValue);
        },

        get maxDate() {
            return this._getStartDatePicker().maxDate;
        }
    });

    return register('ha-date-range-picker', HADateRangePicker);
});

define('hui/textfield-type-ahead',[
    'register-component/v2/register',
    'object-utils/classes',
    './typeahead-base',
    './core/icon',
    './core/deviceUtils'
], function(register, classes, typeaheadBase, icon, deviceUtils) {
    'use strict';

    var HATextfieldTypeAhead = classes.createObject(typeaheadBase, {

        init: function _() {

            _.super(this);

            /**
             * The element that the validator will use to get the values to validate
             * @type {HTMLElement}
             */
            this.validationTarget = this;

            this.setupProperties({
                /**
                 * Disabled indicates if the menu button is disabled.
                 * @type {Boolean}
                 */
                disabled: {
                    default: false,
                    type: Boolean,
                    change: function(newValue) {
                        this.querySelector('ha-text-field.search').disabled = newValue;
                        if (newValue) {
                            this.classList.add('disabled');
                        } else {
                            this.classList.remove('disabled');
                        }
                    }
                },

                /**
                 * The name of a Harmony icon to display within the component
                 * @type {string}
                 */
                icon: {
                    default: '',
                    type: String,
                    change: icon.onChangeIconProperty
                },

                /**
                 * Specifies the maximum number of characters that the user can enter.
                 * @type {Number}
                 */
                maxLength: {
                    default: 524288,
                    type: Number,
                    change: function(newValue) {
                        this.querySelector('ha-text-field.search').maxLength = newValue;
                    }
                },

                /**
                 * this sets the autoComplete for the text input
                 * @type {String}
                 */
                autoComplete: {
                    default: 'on',
                    change: function(newValue) {
                        this.querySelector('input').autocomplete = newValue;
                    }
                },

                /**
                 * this sets the size for the text input
                 * @type {Number}
                 */
                size: {
                    default: 20,
                    type: Number,
                    change: function(newValue) {
                        this.querySelector('ha-text-field.search').size = newValue;
                    }
                },

                /**
                 * Number of elements before showing a scrollbar.
                 * @type {Integer}
                 */
                menuSize: {
                    default: 7,
                    type: Number,
                    change: function(newValue) {
                        var menu = this._getMenuPopover().querySelector('ha-menu'),
                            isMenuRendered = !!menu.render;
                        if (isMenuRendered) {
                            menu.size = newValue;
                        } else {
                            menu.setAttribute('size', newValue);
                        }
                    }
                },

                /**
                 * A util for the root component tag name.
                 * @type {String}
                 */
                _ownerComponentName: {
                    default: 'HA-TEXT-FIELD-TYPE-AHEAD',
                    type: String
                },

                /**
                 * Property to ease with Automation Effort. When set with a value, the value
                 * would get as attribute for ha-popover as well.
                 * @type {String}
                 */
                automationId: {
                    default: '',
                    type: String,
                    change: function(newValue, oldValue) {
                        if (newValue !== oldValue) {
                            if (deviceUtils.isDesktop) {
                                var menuPopover = this.querySelector('ha-textfield-type-ahead ha-popover.popover-menu-items');
                                if (menuPopover && newValue) {
                                    menuPopover.setAttribute('automationId', newValue + '_popover');
                                } else if (menuPopover && !newValue) {
                                    menuPopover.removeAttribute('automationId');
                                }
                            }

                            if (deviceUtils.isHandheld) {
                                var adpativeModalMenu = this.querySelector('ha-textfield-type-ahead ha-modal');
                                if (adpativeModalMenu && newValue) {
                                    adpativeModalMenu.setAttribute('automationId', newValue + '_modal');
                                } else if (adpativeModalMenu && !newValue) {
                                    adpativeModalMenu.removeAttribute('automationId');
                                }
                            }
                        }
                    }
                }
            });
        },

        postRender: function _() {
            _.super(this);

            this.listenTo(this._textField, 'change', function(evt) {
                evt.stopPropagation();
                this.emit('change');
            }.bind(this));

            // HUI-4246: Set ownerTag on elements with a parent component
            var textfield = this.querySelector('ha-text-field');
            textfield.ownerTag = this._ownerComponentName;
        },

        /**
         * Gets the selected item from the list
         */
        get selectedItem() {
            return this._selectedItem;
        },

        _getTriggerElement: function() {
            return this._inputElement;
        }
    });

    return register('ha-textfield-type-ahead', HATextfieldTypeAhead);
});


define('text!hui/video/video.html',[],function () { return '<template>\n    <div class="ha-video-history-view ha-video-history-view-hidden hidden">\n        <h3 tabindex="-1" class="ha-video-history-title">{{historyTitleText}}</h3>\n        <div class="ha-video-links"></div>\n        <div class="ha-video-history-edit">\n            <button class="ha-video-history-edit-button no-button-style ha-video-focus-button">{{editHistoryText}}</button>\n        </div>\n        <div class="ha-video-history-controls hidden">\n            <button id="ha-video-clear-all-button{{componentId}}" class="no-button-style ha-video-focus-button">{{clearAllText}}</button>\n            <button class="ha-video-done-editing-button no-button-style ha-video-focus-button">{{doneEditingText}}</button>\n        </div>\n    </div>\n    <div class="ha-video-main-div">\n        <div class="ha-video-title-bar">\n            <div class="ha-video-history-option"><button aria-label="{{viewHistoryMessage}}" class="hi hi-list no-button-style"></button></div>\n            <h3>{{videoTitle}}</h3>\n            <div class="ha-video-size-options">\n                <button id="ha-video-restore{{componentId}}" aria-label="{{restoreSizeMessage}}" class="hi hi-vidresize-1 no-button-style hidden"></button>\n                <button id="ha-video-minimize{{componentId}}" aria-label="{{minimizeMessage}}" class="hi hi-vidresize-2 no-button-style"></button>\n                <button aria-label="{{closeMessage}}" class="hi hi-close no-button-style"></button>\n            </div>\n        </div>\n        <div id="ha-player{{componentId}}"></div>\n        <div class="ha-video-footer-bar"></div>\n   </div>\n    <div tabindex="0" aria-hidden="true"></div>\n    <section class="hidden"></section>\n</template>\n';});


var videoKeys = [],
    YT,
    youtubeA11y;

/**
 * Captures player state changes and displays the overlay when appropriate,
 * as well as tracking whether the video is paused so that it can be resumed
 * after being closed and reopened.
 *
 * @param {String} playerId The ID of the player element
 * @param {Event} event The event detailing the change in state
 */
function onPlayerStateChange(playerId, event) {
    var havideo = document.querySelector('[videokey="' + playerId + '"]'),
        overlayDiv,
        overlayContentDiv,
        mainVideoDiv,
        videoData;
    if (!havideo) {
        return;
    }
    havideo._ended = false;
    if (event.data === 0) {
        havideo._emitVideoEvent('video-completed');
        havideo._ended = true;
        if ((havideo._overlayDiv || havideo.section)) {
            mainVideoDiv = havideo.querySelector('.ha-video-main-div');
            if (havideo._overlayDiv) {
                mainVideoDiv.insertBefore(havideo._overlayDiv, mainVideoDiv.querySelector('iframe'));
            } else {
                overlayDiv = document.createElement('div');
                overlayDiv.classList.add('ha-video-overlay');
                overlayContentDiv = document.createElement('div');
                if (havideo.section) {
                    overlayContentDiv.appendChild(havideo.section);
                }
                overlayDiv.appendChild(overlayContentDiv);
                if (havideo.classList.contains('minimized')) {
                    overlayDiv.classList.add('hidden');
                }
                mainVideoDiv.insertBefore(overlayDiv, mainVideoDiv.querySelector('iframe'));
                havideo._overlayDiv = overlayDiv;
            }
            if (havideo.section) {
                havideo.section.focusContent();
            }
        }
    } else if (event.data === 1) {
        havideo._emitVideoEvent('video-started');
        if (havideo._overlayDiv && havideo._overlayDiv.parentNode) {
            havideo._overlayDiv.parentNode.removeChild(havideo._overlayDiv);
        }
    } else if (event.data === 2) {
        havideo._emitVideoEvent('video-paused');
    }
    videoData = event.target.getVideoData();
    if (videoData.title && !havideo.titleText) {
        havideo.querySelector('.ha-video-title-bar h3').textContent = videoData.title;
    }
}

/**
 * When the player has loaded a URL, this gets called and will set the title on the iframe
 * according to the title of the video.
 *
 * @param {String} playerId
 * @param {Event} event
 */
function onPlayerReady(playerId, event) {
    var havideo = document.querySelector('[videokey="' + playerId + '"]'),
        iframe;
    try {
        if (havideo.classList.contains('visible') && havideo._player && havideo._player.playVideo) {
            havideo._player.playVideo();
        }
        if (!havideo.titleText) {
            havideo.querySelector('.ha-video-title-bar h3').textContent = event.target.getVideoData().title;
        }
        iframe = havideo.querySelector('iframe');
        iframe.setAttribute('title', 'Video');
        iframe.setAttribute('tabindex', '0');
    } catch (ignore) {}
}

// Ignore jshint for this functions, it's used by the youtube API. The only warning that gets thrown is that
// it's defined but not used, but a single ignore line doesn't stop that so the entire function has to be ignored

// jshint ignore:start
/**
 * The function called by the youtube Iframe API when it has finished loading
 */
function onYouTubeIframeAPIReady() {
    videoKeys.forEach(function(key) {
        var havideo = document.querySelector('[videokey="' + key + '"]'),
            url;
        if (havideo) {
            url = havideo.url && havideo.url.split('embed/')[1];
            if (url) {
                url = url.split('?')[0];
            }
            havideo._player = new YT.Player(key, {
                videoId: url,
                playerVars: {
                    enablejsapi: 1,
                    showinfo: 0,
                    modestbranding: 1
                },
                events: {
                    'onStateChange': onPlayerStateChange.bind(null, key),
                    'onReady': onPlayerReady.bind(null, key)
                }
            });
        }
    });
}
// jshint ignore:end

define('hui/video',[
    'register-component/v2/register',
    'object-utils/classes',
    'register-component/template!./video/video.html',
    './popover',
    './core/contentNode',
    './core/keys',
    './core/position',
    './core/a11y'
],
function(register, classes, template, HAPopover, contentNode, keys, position, a11y) {
    youtubeA11y = a11y;

    /**
     * A Video player component. This component allows the user to view
     * youtube videos in an embedded frame with an optional history view that
     * displays their recently viewed videos.
     * @type {Object}
     */
    var HAVideo = classes.createObject(HAPopover.prototype, {
        init: function _() {
            _.super(this);

            this.contentSelectorMap = {
                section: 'section'
            };
            this.template = template;
            /**
             * The last xPosition of this popup in pixels
             *
             * @type {Number}
             */
            this._lastXPosition = null;

            /**
             * The last yPoision of this popup in pixels
             *
             * @type {Number}
             */
            this._lastYPosition = null;

            /**
             * Boolean flag keeping track of whether this popup is being dragged
             *
             * @type {boolean}
             * @private
             */
            this._isDragging = false;

            /**
             * The x and y coordinates relative to the video component of the mouse when it is beginning
             * to be dragged. This is used so that the dragging occurs from wherever the video component is
             * clicked as opposed to the top left corner.
             *
             * @type {Object}
             */
            this._draggingPosition = {};

            /**
             * An array containing the urls of up to the last 8 videos the user has watched.
             *
             * @type {Array}
             * @private
             */
            this._userHistory = [];

            //Set a unique attribute to find this by in the dom
            this.setAttribute('videokey', 'ha-player' + this.componentId);

            this.setupProperties({
                /**
                 * Label for screen readers for the history button
                 *
                 * @type {String}
                 */
                viewHistoryMessage: {
                    default: 'Toggle History View',
                    type: String,
                    change: function(message) {
                        this.querySelector('.ha-video-history-option button').setAttribute('aria-label', message);
                    }
                },

                /**
                 * Label for screen readers for the minimize button
                 *
                 * @type {String}
                 */
                minimizeMessage: {
                    default: 'Switch to compact view',
                    type: String,
                    change: function(message) {
                        this.querySelector('#' + 'ha-video-minimize' + this.componentId).setAttribute('aria-label', message);
                    }
                },

                /**
                 * Label for screen readers for the restore button
                 *
                 * @type {String}
                 */
                restoreSizeMessage: {
                    default: 'Return to full size view',
                    type: String,
                    change: function(message) {
                        this.querySelector('#' + 'ha-video-restore' + this.componentId).setAttribute('aria-label', message);
                    }
                },

                /**
                 * Label for screen readers for the close button
                 *
                 * @type {String}
                 */
                closeMessage: {
                    default: 'Close video player',
                    type: String,
                    change: function(message) {
                        this.querySelector('.ha-video-size-options .hi-close').setAttribute('aria-label', message);
                    }
                },

                /**
                 * The URL of the video to play
                 *
                 * @type {String}
                 */
                url: {
                    default: '',
                    type: String,
                    change: function(url) {
                        if (url) {
                            if (this._player && this._player.loadVideoByUrl) {
                                this._player.loadVideoByUrl(url);
                            }
                            this._exitEditMode();
                            if (this.open) {
                                this._updateHistory(url);
                            }
                        }
                    }
                },

                /**
                 * The ID of the logged in user, this needs to be set in order to track
                 * the viewers history while using this video player, as well as to recover
                 * their existing history
                 */
                userId: {
                    default: '',
                    type: String,
                    change: function() {
                        this._refreshHistory();
                        this._buildHistoryContent();
                    }
                },

                /**
                 * The text to display as the title of the history view
                 *
                 * @type {String}
                 */
                historyTitleText: {
                    default: 'Recently Watched',
                    type: String,
                    change: function(title) {
                        this.querySelector('.ha-video-history-title').textContent = title;
                    }
                },

                /**
                 * The text to display for the edit command in the history view
                 *
                 * @type {String}
                 */
                editHistoryText: {
                    default: 'Edit',
                    type: String,
                    change: function(editText) {
                        this.querySelector('.ha-video-history-edit-button').textContent = editText;
                    }
                },

                /**
                 * The text to display for the clear all command in the history view
                 *
                 * @type {String}
                 */
                clearAllText: {
                    default: 'Clear All',
                    type: String,
                    change: function(clearAllText) {
                        this.querySelector('#ha-video-clear-all-button' + this.componentId).textContent = clearAllText;
                    }
                },

                /**
                 * The text to display for the button to stop editing the history view
                 *
                 * @type {String}
                 */
                doneEditingText: {
                    default: 'Done',
                    type: String,
                    change: function(doneEditingText) {
                        this.querySelector('.ha-video-done-editing-button').textContent = doneEditingText;
                    }
                },

                /**
                 * Optional title string that overrides the youtube
                 * title
                 *
                 * @type {String}
                 */
                titleText: {
                    default: '',
                    type: String,
                    change: function(titleText) {
                        this.querySelector('.ha-video-title-bar h3').textContent = titleText;
                    }
                },

                /**
                 * Shows or hides the button to view history
                 *
                 * @{type} Boolesn
                 */
                enableHistoryView: {
                    type: Boolean,
                    change: function(enableHistoryView) {
                        if (enableHistoryView) {
                            this.querySelector('.ha-video-history-option button').classList.remove('hidden');
                            this.classList.remove('ha-video-no-history-view');
                        } else {
                            this.querySelector('.ha-video-history-option button').classList.add('hidden');
                            this.classList.add('ha-video-no-history-view');
                        }
                    }
                }
            });

            this.on('keydown', function(evt) {
                if (keys.ESCAPE !== evt.keyCode) {
                    a11y.keepFocusInsideListener(evt, this);
                }
            });
            contentNode.cacheInputContent(this, this.contentSelectorMap);
        },

        postRender: function _() {
            _.super(this);
            // Override section set by popover
            this._section = null;
            contentNode.storeCachedInput(this, this.contentSelectorMap);

            this._closeOnBlur = false;
        },

        _setupListeners: function() {
            this.listenTo(this, 'mousedown', function(event) {
                this._isDragging = true;
                this._draggingPosition = {
                    x: this.offsetLeft - event.pageX,
                    y: this.offsetTop - event.pageY
                };
                event.preventDefault();
            }.bind(this));

            this.listenTo(this.ownerDocument, 'mouseup', function() {
                this._isDragging = false;
            }.bind(this));

            this.listenTo(this.ownerDocument, 'mousemove', function(event) {
                if (this._isDragging) {
                    this.style.left = event.pageX + this._draggingPosition.x + 'px';
                    this.style.top = event.pageY + this._draggingPosition.y + 'px';
                }
            }.bind(this));

            this.listenTo(this, '#ha-video-minimize' + this.componentId + ':click', function() {
                this.minimize();
            }.bind(this));

            this.listenTo(this, '#ha-video-restore' + this.componentId + ':click', function() {
                this.maximize();
            }.bind(this));

            this.listenTo(this, '.hi-close:click', function() {
                this._emitVideoEvent('video-closed');
                this.close();
            }.bind(this));

            this.listenTo(this, '.hi-list:click', function() {
                this.toggleHistoryView();
            }.bind(this));

            this.listenTo(this, 'close', function() {
                this._saveState();
                this.toggleHistoryView(true);
            }.bind(this));

            this.listenTo(this, '.ha-video-overlay:click', function(event) {
                if (event.target === this.querySelector('.ha-video-overlay')) {
                    event.target.parentNode.removeChild(event.target);
                }
            }.bind(this));

            this.listenTo(this, '.ha-video-history-edit-button:click', function(event) {
                event.target.classList.add('hidden');
                this.querySelector('.ha-video-history-controls').classList.remove('hidden');
                Array.prototype.forEach.call(this.querySelectorAll('ha-video-launcher'), function(link) {
                    link._editMode = true;
                });
                this._focusOnHistory();
            }.bind(this));

            this.listenTo(this, '#ha-video-clear-all-button' + this.componentId + ':click', function() {
                this._clearHistory();
            }.bind(this));

            this.listenTo(this, '.ha-video-done-editing-button:click', function() {
                this._exitEditMode();
            }.bind(this));

            this.listenTo(this, 'video-launcher-dismiss', function(event) {
                this._refreshHistory();
                var url = event.link.url,
                    target = event.target,
                    index;
                while ((index = this._userHistory.indexOf(url)) > -1) {
                    this._userHistory.splice(index, 1);
                }

                window.localStorage.setItem(this.userId + 'haUserViewingHistory', JSON.stringify(this._userHistory));

                while (target && target.nodeName !== 'HA-VIDEO-LAUNCHER') {
                    target = target.parentNode;
                }

                if (target) {
                    target.parentNode.removeChild(target);
                }
                this._focusOnHistory();
            }.bind(this));
        },

        attachedCallback: function _() {
            _.super(this);
            var connector = this.querySelector('.connector'),
                tag = document.createElement('script'),
                firstScriptTag = document.getElementsByTagName('script')[0],
                url,
                id = this._uniqueIdentifier();
            videoKeys.push(id);

            // Check for existing youtube API
            if (!YT || !YT.Player) {
                tag.src = 'https://www.youtube.com/iframe_api';
                firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
            } else {
                url = this.url && this.url.split('embed/')[1];
                if (url) {
                    url = url.split('?')[0];
                }
                this._player = new YT.Player(id, {
                    videoId: url,
                    playerVars: {
                        enablejsapi: 1,
                        showinfo: 0,
                        modestbranding: 1
                    },
                    events: {
                        'onStateChange': onPlayerStateChange.bind(null, id),
                        'onReady': onPlayerReady.bind(null, id)
                    }
                });
            }

            if (connector) {
                connector.parentNode.removeChild(connector);
            }

            this._setupListeners();
        },

        detachedCallback: function() {
            var index = videoKeys.indexOf(this._uniqueIdentifier());
            if (index > -1) {
                videoKeys.splice(index, 1);
            }
            this._player = null;
            this.stopListening();
        },

        /**
         * Returns the unique identifier for this component,
         * defined by prepending 'ha-player' to its `componentId`.
         * @returns {string}
         * @private
         */
        _uniqueIdentifier: function() {
            return 'ha-player' + this.componentId;
        },

        /**
         * Adds the video links to the history view based on the current user history
         *
         * @private
         */
        _buildHistoryContent: function() {
            var historyView = this.querySelector('.ha-video-links');
            historyView.innerHTML = '';
            if (this._userHistory && this._userHistory.length) {
                this._userHistory.forEach(function(url) {
                    historyView.appendChild(this._buildHistoryEntry(url));
                }.bind(this));
            }
        },

        /**
         * Build the dom structure for a single video link in the
         * history tab.
         *
         * @param {String} url
         * @private
         */
        _buildHistoryEntry: function(url) {
            var entry = document.createElement('ha-video-launcher');
            entry.size = 'mini';
            entry.orientation = 'horizontal';
            entry.url = url;
            entry.standalone = false;
            entry.videoPlayer = this;
            return entry;
        },

        /**
         * Removes all entries from history and exits edit mode
         *
         * @private
         */
        _clearHistory: function() {
            this._userHistory = [];
            this._buildHistoryContent();
            window.localStorage.removeItem(this.userId + 'haUserViewingHistory');
            this._exitEditMode();
        },

        /**
         * Emits an event containing the time
         * and url of the current video
         *
         * @private
         */
        _emitVideoEvent: function(action) {
            if (this.userId) {
                this.emit(action, {
                    url: this.url,
                    time: (new Date()).valueOf(),
                    action: action,
                    userId: this.userId
                });
            }
        },

        /**
         * Exits edit mode, restoring the edit button and removing X's from
         * video links
         *
         * @private
         */
        _exitEditMode: function() {
            this.querySelector('.ha-video-history-controls').classList.add('hidden');
            this.querySelector('.ha-video-history-edit-button').classList.remove('hidden');
            Array.prototype.forEach.call(this.querySelectorAll('ha-video-launcher'), function(link) {
                link._editMode = false;
            });
            this._focusOnHistory();
        },

        /**
         * Focuses on the history title or the first video launch link if there is one
         *
         * @private
         */
        _focusOnHistory: function(historyView) {
            historyView = historyView || this.querySelector('.ha-video-history-view');
            var videoLauncher;

            if (!historyView.classList.contains('ha-video-history-view-hidden')) {
                if ((videoLauncher = historyView.querySelector('.ha-video-launcher-single'))) {
                    videoLauncher.focus();
                } else {
                    historyView.querySelector('.ha-video-history-title').focus();
                }
            }

        },

        /**
         * Gets the latest history entries in local storage for the user
         * and populates the history list with them.
         *
         * @private
         */
        _refreshHistory: function() {
            if (this.userId) {
                this._userHistory = [];
                try {
                    var history = JSON.parse(window.localStorage.getItem(this.userId + 'haUserViewingHistory'));
                    if (history && history.length) {
                        this._userHistory = history;
                    }
                } catch (ignore) {
                }
            }
        },

        /**
         * Captures the current position of the player so that it can be moved
         * there when it is reopened, and determines whether it should automatically
         * start playing the next time it's opened.
         *
         * @private
         */
        _saveState: function() {
            this._lastYPosition = this.style.top;
            this._lastXPosition = this.style.left;
            if (this._player && this._player.pauseVideo) {
                this._player.pauseVideo();
            }
        },

        /**
         * Adds the url to history, avoiding repeats and removing any
         * entries past the eighth
         *
         * @param {String} url - The URL of the video
         * @private
         */
        _updateHistory: function(url) {
            var index,
                historyView = this.querySelector('.ha-video-history-view');

            if (this.userId && url) {
                this._refreshHistory();
                if (this._userHistory) {
                    if (url !== this._userHistory[0]) {
                        while ((index = this._userHistory.indexOf(url)) > -1) {
                            this._userHistory.splice(index, 1);
                        }
                        this._userHistory.unshift(url);
                    }

                    if (this._userHistory.length > 8) {
                        this._userHistory.splice(8, Infinity);
                    }
                    window.localStorage.setItem(this.userId + 'haUserViewingHistory', JSON.stringify(this._userHistory));
                    this._buildHistoryContent();
                    this._focusOnHistory(historyView);
                }
            }
        },

        /**
         * Switches to the maximized view mode
         *
         * @private
         */
        maximize: function() {
            var minimizeButton = this.querySelector('#ha-video-minimize' + this.componentId);

            this.classList.remove('minimized');
            this.querySelector('#ha-video-restore' + this.componentId).classList.add('hidden');
            minimizeButton.classList.remove('hidden');
            if (this.enableHistoryView) {
                this.querySelector('.hi-list').classList.remove('hidden');
            }

            if (this._overlayDiv) {
                this._overlayDiv.classList.remove('hidden');
            }
            this.querySelector('.ha-video-title-bar h3').classList.remove('hidden');
            this.focus();
        },

        /**
         * Switches to the minimized view mode
         *
         * @private
         */
        minimize: function() {
            var restoreButton = this.querySelector('#ha-video-restore' + this.componentId);

            this.toggleHistoryView(true);
            this.classList.add('minimized');
            this.querySelector('#ha-video-minimize' + this.componentId).classList.add('hidden');
            restoreButton.classList.remove('hidden');
            this.querySelector('.hi-list').classList.add('hidden');
            this.querySelector('.ha-video-title-bar h3').classList.add('hidden');

            if (this._overlayDiv) {
                this._overlayDiv.classList.add('hidden');
            }
            this.focus();
        },

        /**
         * Enters or exits mobile view
         *
         * @param {Boolean} isMobile
         */
        switchView: function(isMobile) {
            if (isMobile) {
                this.classList.add('ha-video-mobile');
            } else {
                this.classList.remove('ha-video-mobile');
            }
        },

        /**
         * Displays the video player, either in the last location
         * is was in before being closed or in the center of the screen if it
         * hasn't been opened before.
         */
        show: function() {
            this.toggleHistoryView(true);
            if (!this.classList.contains('visible')) {
                var getOffsetString = function(offsetValue) {
                        if (offsetValue < 0) {
                            return ' + ' + (-1 * offsetValue);
                        } else {
                            return ' - ' + offsetValue;
                        }
                    },
                    yOffsetValue = getOffsetString(234 - (window.pageYOffset || window.scrollY || 0)),
                    xOffsetValue = getOffsetString(350 - (window.pageXOffset || window.scrollX || 0));

                position.bringToFront(this);
                this.style.top = this._lastYPosition !== null ? this._lastYPosition : 'calc(50%' + yOffsetValue + 'px)';
                this.style.left = this._lastXPosition !== null ? this._lastXPosition : 'calc(50%' + xOffsetValue + 'px)';
                this.lastFocus = this.ownerDocument.activeElement;

                this.classList.remove('leave');
                this.classList.add('enter');
                this.classList.add('visible');

                if (this.offsetTop < 0) {
                    this.style.top = '0px';
                }

                if (this.offsetLeft < 0) {
                    this.style.left = '0px';
                }
                this._updateHistory(this.url);
                this.focus();
                if (this._player && this._player.playVideo && !this._ended) {
                    this._player.playVideo();
                }
            }
        },

        /**
         * Hides the video player and saves location
         */
        close: function() {
            this._saveState();
            this.toggleHistoryView(false);
            this.classList.remove('enter');
            this.classList.remove('visible');
            this.classList.add('leave');
        },

        /**
         * Toggles the visibility of the history view. If close
         * is passed and true, the element will be hidden completely.
         * The other hidden class is still toggled so that the current setting
         * can be restored when opening or maximizing without additional logic.
         * This is useful when minimizing or closing
         * the video player
         *
         * @param {Boolean} close - Optional flag indicating that the component should
         * be closed instead of just toggled
         * @private
         */
        toggleHistoryView: function(close) {
            var historyView = this.querySelector('.ha-video-history-view');

            this._exitEditMode();
            if (close || !historyView.classList.contains('ha-video-history-view-hidden')) {
                historyView.classList.add('ha-video-history-view-hidden');
                // Wait for animation to play before hiding element to
                // remove it from the tabindex
                setTimeout(function() {
                    historyView.classList.add('hidden');
                }, 500);
                this.focus();
            } else {
                this._refreshHistory();
                this._buildHistoryContent();
                historyView.classList.remove('hidden');
                setTimeout(function() {
                    historyView.classList.remove('ha-video-history-view-hidden');
                    this._focusOnHistory(historyView);
                }.bind(this), 0);
            }
        },

        /**
         * The section can be used to declaratively provide a button
         * for the overlay
         *
         * @type {Array}
         */
        set section(section) {
            section = Array.isArray(section) ? section : [section];
            var overlayButton = section.filter(function(element) {
                    return element.nodeName === 'HA-VIDEO-OVERLAY-BUTTON';
                })[0],
                existingButton;
            this._section = overlayButton;
            if (this._overlayDiv) {
                existingButton = this._overlayDiv.querySelector('ha-video-overlay-button');
                if (existingButton) {
                    existingButton.parentNode.replaceChild(overlayButton, existingButton);
                } else {
                    this._overlayDiv.firstChild.appendChild(overlayButton);
                }
            }
            if (this._section && this._section === overlayButton) {
                this.querySelector('section').appendChild(overlayButton.cloneNode(true));
            }
        },

        get section() {
            return this._section;
        }
    });

    return register('ha-video', HAVideo);
});


define('text!hui/video-launcher/video-launcher.html',[],function () { return '<template>\n    <div class="ha-video-launcher-view">\n        <button class="ha-video-launcher-single no-button-style">\n            <div class="ha-video-launcher-preview">\n                <img alt="">\n                <div class="hi hi-vidplay" aria-hidden="true"></div>\n                <div class="ha-video-hover-div"></div>\n            </div>\n            <div class="ha-video-launcher-info">\n                <div class="ha-video-launcher-info-inner">\n                    <div class="ha-video-launcher-title"></div>\n                    <div class="ha-video-info-separator hidden">-</div>\n                    <div class="ha-video-launcher-time"></div>\n                </div>\n                <div class="ha-video-description hidden"></div>\n            </div>\n        </button>\n        <button aria-label="{{removeMessage}}" class="hi hi-close hidden no-button-style"></button>\n        </div>\n    </div>\n    <section class="hidden"></section>\n</template>\n';});


var youtubeDataApiCallbackMap = {};

define('hui/video/youtube',[],
function() {
    var cache = {},
        counter = 0,
        youtubeAPIKey = 'AIzaSyBjnMTlF9ou968qeDBc6LQpN860jJ0Juj0';

    return {
        get: function(url, callback, errorCallback) {
            var match = url.match(/^.*(?:youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|\&v=)([^#\&\?]*)/),
                id,
                script,
                firstScriptTag,
                captureCounter;

            if (!match) {
                if (errorCallback) {
                    errorCallback(new Error('Unrecognized YouTube URL'));
                }
                return;
            }

            id = match[1];
            if (cache[id]) {
                callback(cache[id]);
            } else {
                script = document.createElement('script');
                firstScriptTag = document.getElementsByTagName('script')[0];
                captureCounter = counter;
                // Append a letter so that this will always be a valid property name
                youtubeDataApiCallbackMap['a' + id + counter] = function(data) {
                    cache[id] = data.items[0] || 'no data found';
                    callback(cache[id]);
                    script.parentNode.removeChild(script);
                    delete youtubeDataApiCallbackMap['' + id + captureCounter];
                };
                script.src = 'https://www.googleapis.com/youtube/v3/videos?callback=youtubeDataApiCallbackMap.a' + id + counter +
                '&request.preventCache=' + (+(new Date())) +
                '&key=' + youtubeAPIKey +
                '&part=contentDetails,snippet' +
                '&id=' + id;
                counter++;

                firstScriptTag.parentNode.insertBefore(script, firstScriptTag);
            }
        },

        set apiKey(key) {
            youtubeAPIKey = key;
        },

        get apiKey() {
            return youtubeAPIKey;
        }
    };
});
define('hui/video-launcher',[
    'register-component/v2/register',
    'register-component/v2/UIComponent',
    'object-utils/classes',
    './core/keys',
    './core/contentNode',
    './core/ellipsis',
    'register-component/template!./video-launcher/video-launcher.html',
    './video/youtube',
    './video'
],
function(register, UIComponent, classes, keys, contentNode, ellipsis, template, youtube) {
    // In history view, when one element is removed by clicking space or enter on the remove button,
    // a click event is triggered for the next element as focus shifts to it and the key is still held down.
    // This prevents that second event from triggering.
    var preventDoubleTrigger, HAVideoLauncher;

    /**
     * A launcher component that displays a preview and title of a video, and can
     * be activated to watch the video. The launcher has multiple available display formats.
     * @type {Object}
     */
    HAVideoLauncher = classes.createObject(UIComponent, {
        init: function _() {
            _.super(this);

            this.contentSelectorMap = {
                'section': 'section'
            };

            this.template = template;

            /**
             * Cache the existing video player instead of creating a new one each
             * time.
             *
             * @type {HAVideo}
             * @private
             */
            this._videoPlayer = null;

            /**
             * Used to differentiate between a link that should
             * clean up its own video player, and a link that is part
             * of a video history display and should not modify the existing
             * player.
             *
             * @type {boolean}
             * @private
             */
            this.standalone = true;

            /**
             * Used to prevent another keydown event from being triggered
             * immediately after removing a row in the history view
             *
             * @type {boolean}
             * @private
             */
            this._keyDownPause = false;

            this.setupProperties({
                /**
                 * Used to enable the history view on the video player created
                 * by this component
                 *
                 * @type {boolean}
                 */
                enableHistoryView: {
                    type: Boolean
                },

                /**
                 * The size of the launcher: mini, large, giant
                 *
                 * @type {String}
                 */
                size: {
                    default: 'mini',
                    type: String,
                    change: function(size) {
                        this.querySelector('.ha-video-launcher-view').classList[size === 'mini' ? 'add' : 'remove']('ha-video-launcher-mini');
                        this.querySelector('.ha-video-launcher-view').classList[size === 'giant' ? 'add' : 'remove']('ha-video-launcher-giant');
                        this.querySelector('.ha-video-launcher-view').classList[size === 'large' ? 'add' : 'remove']('ha-video-launcher-large');
                        this.querySelector('.ha-video-info-separator').classList[size === 'giant' ? 'remove' : 'add']('hidden');
                        this.querySelector('.ha-video-description').classList[((size === 'giant' && this.show) || size === 'large') ? 'remove' : 'add']('hidden');
                        if (size === 'giant' || size === 'large') {
                            this._changeFocusConfiguration(true);
                        } else {
                            this._changeFocusConfiguration(false);
                        }
                    }
                },

                /**
                 * The flexible area of the launcher: vertical, horizontal.
                 * Used for the mini size.
                 *
                 * @type {String}
                 */
                orientation: {
                    default: 'horizontal',
                    type: String,
                    change: function(orientation) {
                        this.querySelector('.ha-video-launcher-view').classList[orientation === 'horizontal' ? 'add' : 'remove']('horizontal');
                        this.querySelector('.ha-video-launcher-view').classList[orientation === 'vertical' ? 'add' : 'remove']('vertical');
                    }
                },

                /**
                 * The link to the YouTube video being shown
                 *
                 * @type {String}
                 */
                url: {
                    default: '',
                    type: String,
                    change: function(url) {
                        youtube.get(url, function(data) {
                            var launcherTitle = this.querySelector('.ha-video-launcher-title');

                            if (this.size === 'mini') {
                                this.querySelector('.ha-video-launcher-preview img').src = data.snippet.thumbnails.medium.url;
                            } else if (this.size === 'giant' || this.size === 'large') {
                                if (data.snippet.thumbnails.maxres && data.snippet.thumbnails.maxres.url) {
                                    this.querySelector('.ha-video-launcher-preview img').src = data.snippet.thumbnails.maxres.url;
                                } else {
                                    this.querySelector('.ha-video-launcher-preview img').src = data.snippet.thumbnails.medium.url;
                                }
                            }

                            launcherTitle.textContent = this.titleText || data.snippet.title;

                            ellipsis(launcherTitle, {
                                lines: 2
                            });

                            if (this.size === 'giant' || this.size === 'large') {
                                this.querySelector('.ha-video-launcher-preview img').setAttribute('alt', data.snippet.title);
                            }

                            // ISO 8601
                            // PT#M#S, PT#H#M#S
                            var duration = '0s',
                                minutes,
                                seconds,
                                match = data.contentDetails.duration.match(/^PT(?:(\d+)H)?(\d+)M(\d+)S$/),
                                description = data.snippet.description;
                            if (match) {
                                minutes = match[2];
                                if (match[1]) {
                                    minutes = String(parseInt(minutes, 10) + (parseInt(match[1], 10) * 60));
                                }
                                seconds = match[3];
                                duration = minutes + ':' + seconds + 's';
                            }
                            this.querySelector('.ha-video-launcher-time').textContent = duration;
                            if (this.useYoutubeDescription) {
                                var desc = this.querySelector('.ha-video-description');
                                desc.textContent = description;
                                if (!desc.classList.contains('hidden')) {
                                    ellipsis(desc, {lines: 5});
                                }
                            }
                            this._youtubeDescription = description;
                        }.bind(this));
                    }
                },

                /**
                 * Used to optionally override the title from YouTube.
                 *
                 * @type {string}
                 */
                titleText: {
                    type: String,
                    default: '',
                    change: function(newTitle) {
                        // Don't use this for a grid
                        var titleTag = this.querySelector('.ha-video-launcher-title');
                        if (titleTag && newTitle) {
                            titleTag.textContent = newTitle;
                        }
                    }
                },

                /**
                 * Optional parameter to use the description provided by
                 * youtube
                 */
                useYoutubeDescription: {
                    type: Boolean,
                    change: function(useYoutubeDescription) {
                        var videoDescription = this.querySelector('.ha-video-description');
                        if (useYoutubeDescription) {
                            videoDescription.textContent = this._youtubeDescription || '';
                        } else if (this.description) {
                            videoDescription.textContent = this.description;
                        }
                        if (this.size === 'giant') {
                            var addOrRemove = (useYoutubeDescription || this.description) ? 'remove' : 'add';
                            videoDescription.classList[addOrRemove]('hidden');
                        }

                        if (!videoDescription.classList.contains('hidden')) {
                            ellipsis(videoDescription, {lines: 5});
                        }
                    }
                },

                /**
                 * Overrides the youtube video description for display in
                 * the link
                 *
                 * @type {String}
                 */
                description: {
                    type: String,
                    default: '',
                    change: function(description) {
                        var desc = this.querySelector('.ha-video-description');
                        desc.textContent = description;
                        if (this.size === 'giant') {
                            var addOrRemove = (description || this.useYoutubeDescription) ? 'remove' : 'add';
                            desc.classList[addOrRemove]('hidden');
                        }

                        if (!desc.classList.contains('hidden')) {
                            ellipsis(desc, {lines: 5});
                        }
                    }
                },

                /**
                 * The text to be read by a screen reader focusing the
                 * close icon
                 *
                 * @type {String}
                 */
                removeMessage: {
                    type: String,
                    default: 'Remove video link',
                    change: function(message) {
                        Array.prototype.forEach.call(this.querySelectorAll('button.hi-close'), function(element) {
                            element.setAttribute('aria-label', message);
                        });
                    }
                },

                /**
                 * Flag indicating whether this should enter edit mode, and display the close
                 * icon
                 *
                 * @type {Boolean}
                 */
                _editMode: {
                    type: Boolean,
                    change: function(inEditMode) {
                        Array.prototype.forEach.call(this.querySelectorAll('button.hi-close'), function(element) {
                            element.classList[inEditMode ? 'remove' : 'add']('hidden');
                        });
                    }
                }
            });
            contentNode.cacheInputContent(this, this.contentSelectorMap);
        },

        postRender: function _() {
            _.super(this);
            contentNode.storeCachedInput(this, this.contentSelectorMap);

            this.listenTo(this, '.hi-close:click', function(event) {
                event.stopPropagation();
                this._emitRemoveEvent(event);
            }.bind(this));

            this.listenTo(this, '.ha-video-launcher-single:click', function(event) {
                if (!preventDoubleTrigger && event.target !== this.querySelector('.hi-close') &&
                    !event.target.classList.contains('ha-video-description')) {
                    event.stopPropagation();
                    this.launchVideo();
                }
            }.bind(this));

            this.listenTo(this, 'keydown', function(event) {
                if (event.keyCode === keys.ENTER || event.keyCode === keys.SPACEBAR) {
                    if (event.target === this.querySelector('.hi-close')) {
                        preventDoubleTrigger = true;
                        setTimeout(function() {
                            preventDoubleTrigger = false;
                        }, 100);
                        this._emitRemoveEvent(event);
                    } else if (event.target === this.querySelector('.ha-video-launcher-single')) {
                        event.preventDefault();
                        this.launchVideo();
                    }
                }
            }.bind(this));
        },

        detachedCallback: function() {
            if (this.standalone && this._videoPlayer && this._videoPlayer.parentNode) {
                this._videoPlayer.parentNode.removeChild(this._videoPlayer);
            }
        },

        /**
         * The video player corresponding to this link
         *
         * @private
         * @param {HAVideo} videoPlayer
         */
        set videoPlayer(videoPlayer) {
            if (this.standalone && this._videoPlayer && this._videoPlayer.parentNode) {
                this._videoPlayer.parentNode.removeChild(this._videoPlayer);
            }
            this._videoPlayer = videoPlayer;
        },

        get videoPlayer() {
            return this._videoPlayer;
        },

        /**
         * Emits an event to notify any containing elements that this video link
         * should be removed. Intended primarily to be consumed by a video player
         * which will then remove this instance from history.
         *
         * @param {Event} event
         * @private
         */
        _emitRemoveEvent: function(event) {
            event.stopPropagation();
            this.emit('video-launcher-dismiss', {
                link: this
            });
        },

        /**
         * Creates and/or updates the video player component corresponding to this
         * launcher and displays it.
         *
         */
        launchVideo: function() {
            var video,
                section;
            if (this._videoPlayer) {
                if (this._videoPlayer.url !== this.url) {
                    this._videoPlayer.url = this.url;
                }
            } else {
                video = this.ownerDocument.createElement('ha-video');
                video.url = this.url;
                document.body.appendChild(video);
                this._videoPlayer = video;
                section = this.section;
                if (section) {
                    this._videoPlayer.section = section;
                }
            }

            if (window.innerWidth <= 800 && window.innerHeight <= 600) {
                this._videoPlayer.switchView(true);
            }
            // Only standalone links should be able to alter the settings of the player
            if (this.standalone) {
                this._videoPlayer.enableHistoryView = this.enableHistoryView;
                if (this.titleText) {
                    this._videoPlayer.titleText = this.titleText;
                }
            }

            this._videoPlayer.show();
        },

        /**
         * For different sizes of launchers, focus is handled differently.
         * Specifically, for large and giant links, only the title link is focusable,
         * but for mini links the entire component is focused as a single entity.
         * This function handles modifying the dom to handle both cases appropriately.
         * @param {Boolean} isLargeOrGiantLink
         * @private
         */
        _changeFocusConfiguration: function(isLargeOrGiantLink) {
            var launcherButton,
                launcherDiv,
                textLinkButton,
                textLinkDiv,
                img;
            if (isLargeOrGiantLink) {
                while ((launcherButton = this.querySelector('button.ha-video-launcher-single'))) {
                    launcherDiv = document.createElement('div');
                    textLinkButton = document.createElement('button');
                    launcherDiv.innerHTML = launcherButton.innerHTML;
                    launcherDiv.classList.add('ha-video-launcher-single');
                    if (launcherButton.classList.contains('hidden')) {
                        launcherDiv.classList.add('hidden');
                    }
                    textLinkDiv = launcherDiv.querySelector('.ha-video-launcher-info-inner');
                    textLinkButton.innerHTML = textLinkDiv.innerHTML;
                    textLinkButton.classList.add('ha-video-launcher-info-inner');
                    textLinkButton.classList.add('no-button-style');
                    textLinkDiv.parentNode.replaceChild(textLinkButton, textLinkDiv);
                    launcherButton.parentNode.replaceChild(launcherDiv, launcherButton);
                    img = launcherDiv.querySelector('.ha-video-launcher-preview img');
                    img.setAttribute('alt', textLinkButton.querySelector('.ha-video-launcher-title').textContent);
                    img.setAttribute('tabindex', '-1');
                }
            } else {
                while ((launcherDiv = this.querySelector('div.ha-video-launcher-single'))) {
                    launcherButton = document.createElement('button');
                    textLinkDiv = document.createElement('div');
                    launcherButton.innerHTML = launcherDiv.innerHTML;
                    launcherButton.classList.add('ha-video-launcher-single');
                    launcherButton.classList.add('no-button-style');
                    if (launcherDiv.classList.contains('hidden')) {
                        launcherButton.classList.add('hidden');
                    }
                    textLinkButton = launcherButton.querySelector('.ha-video-launcher-info-inner');
                    textLinkDiv.innerHTML = textLinkButton.innerHTML;
                    textLinkDiv.classList.add('ha-video-launcher-info-inner');
                    textLinkButton.parentNode.replaceChild(textLinkDiv, textLinkButton);
                    launcherDiv.parentNode.replaceChild(launcherButton, launcherDiv);
                    img = launcherButton.querySelector('.ha-video-launcher-preview img');
                    img.setAttribute('alt', '');
                    img.removeAttribute('tabindex');
                }
            }
        },

        set section(section) {
            section = Array.isArray(section) ? section : [section];
            var overlayButton = section.filter(function(node) {
                return node.nodeName === 'HA-VIDEO-OVERLAY-BUTTON';
            })[0];
            if (overlayButton) {
                this.querySelector('section').appendChild(overlayButton);
                this._section = overlayButton;
                if (this._videoPlayer) {
                    this._videoPlayer.section = overlayButton;
                }
            }
        },

        get section() {
            return this._section;
        }
    });

    return register('ha-video-launcher', HAVideoLauncher);
});

define('hui/video/video-overlay-button',[
    'register-component/v2/register',
    'register-component/v2/UIComponent',
    'object-utils/classes'
], function(register, UIComponent, classes) {
    'use strict';

    var HAVideoOverlayButton = classes.createObject(UIComponent, {
        init: function _() {
            _.super(this);

            this.setupProperties({
                /**
                 * This is the label property for the button.
                 * @type {String}
                 * @default ''
                 */
                label: {
                    default: '',
                    change: function(newValue) {
                        var label = this.querySelector('div');
                        if (label) {
                            label.textContent = newValue;
                            if (!newValue) {
                                this.removeAttribute('label');
                            }
                        }
                    }
                },

                /**
                 * Type of button to set, can be 'primary', 'default' or ''
                 * @type {String}
                 * @default ''
                 */
                type: {
                    default: '',
                    change: function(newValue) {
                        var button = this.querySelector('button');
                        if (button) {
                            if (newValue === 'primary') {
                                button.className = 'ha-button ha-button-primary';
                            } else if (!newValue || newValue === 'default') {
                                button.className = 'ha-button';
                            }
                        }
                    }
                }
            });
        },

        postRender: function _() {
            _.super(this);

            if (!this.children.length) {
                var textContent = this.textContent,
                    button = document.createElement('button');
                this.textContent = '';
                this.appendChild(document.createElement('div'));
                this.appendChild(button);
                button.type = 'button';
                button.textContent = textContent;
            }

            Object.defineProperty(this, 'textContent', {
                get: function() {
                    var button = this.querySelector('button');
                    return button.textContent;
                },
                set: function(textContent) {
                    var button = this.querySelector('button');
                    button.textContent = textContent;
                }
            });
        },

        focusContent: function() {
            var button = this.querySelector('button'),
                text = this.querySelector('div');
            if (button) {
                button.focus();
            } else if (text) {
                text.setAttribute('tabindex', '-1');
                text.focus();
            }
        }
    });

    return register('ha-video-overlay-button', HAVideoOverlayButton);
});


define('text!hui/card/card-discovery-large.html',[],function () { return '<template>\n    <div class="card-discovery-large-container" aria-labelledby="card-discovery-large-title-{{componentId}}" aria-describedby="card-discovery-large-text-{{componentId}}">\n        <header>\n            <button class="btn hi hi-close pull-right" aria-label="Close"></button>\n            <div class="card-discovery-large-title">\n            </div>\n        </header>\n        <section id="card-discovery-large-text-{{componentId}}"></section>\n        <footer></footer>\n    </div>\n</template>';});


define('hui/card-discovery-large',[
    'object-utils/classes',
    'register-component/v2/register',
    'register-component/v2/UIComponent',
    'register-component/template!./card/card-discovery-large.html',
    './core/a11y',
    './core/contentNode',
    './core/keys',
    './core/utils'
], function(classes, register, UIComponent, template, a11y, contentNode, keys, utils) {

    /**
     * Sets the footer buttons class for <ha-footer-buttons> based on the number of children
     * @param {HTMLElement} haFooterButtonsNode The node.
     */
    function setFooterButtonsClass(haFooterButtonsNode) {
        var footerBtnsClass,
            btnsLength = haFooterButtonsNode.children.length;

        if (btnsLength === 1) {
            footerBtnsClass = 'one-btn';
        } else if (btnsLength === 2) {
            footerBtnsClass = 'two-btn';
        } else if (btnsLength === 3) {
            footerBtnsClass = 'three-btn';
        }

        if (footerBtnsClass) {
            haFooterButtonsNode.classList.add(footerBtnsClass);
        }
    }

    /**
     * Map that says where to insert the content that the consumer sends on the initialization.
     * @type {Object}
     */
    var contentPropertyMap = {
            'section': 'section',
            'footer': 'footer'
        },

        HaCardDiscoveryLarge = classes.createObject(UIComponent, {

            /**
             * Initialize the Card properties.
             */
            init: function _() {

                _.super(this);

                this.template = template;

                contentNode.cacheInputContent(this, contentPropertyMap);

                /**
                 * Property to set focus back to show button after close
                 * @type {HTMLElement}
                 */
                this._lastFocus = null;

                /**
                 * Property to set the footer of the Card.
                 * @type {HTMLElement}
                 */
                this._footer = null;

                /**
                 * Property to set the text that provides additional details about the reason for the alert.
                 * @type {HTMLElement}
                 */
                this._section = null;

                this.setupProperties({
                    /**
                     * Property to set if the Card shows the close button (true / false).
                     * @type {Boolean}
                     */
                    dismissible: {
                        default: false,
                        type: Boolean,
                        change: function(newValue) {
                            var closeButton = this.querySelector('header button');

                            if (newValue) {
                                closeButton.classList.remove('hidden');
                                closeButton.classList.add('show');
                            } else {
                                closeButton.classList.add('hidden');
                                closeButton.classList.remove('show');
                            }
                        }
                    },

                    /**
                     * Property to set the title of the Card.
                     * @type {String}
                     */
                    titleText: {
                        default: '',
                        type: String,
                        change: function(newValue) {
                            var cardTitle = this.querySelector('.card-discovery-large-title');

                            if (cardTitle) {
                                cardTitle.textContent = newValue;
                            }
                        }
                    },

                    /**
                     * When present, it specifies that the Card component is active and that
                     * the user can interact with it.
                     * @type {Boolean}
                     */
                    open: {
                        default: false,
                        type: Boolean,
                        change: function(newValue) {
                            var sectionInputElement, footerPrimaryButton, closeButton, firstFocusable,
                                self = this;

                            if (newValue && !this.classList.contains('show')) {
                                // show
                                this.classList.add('show');
                                this._lastFocus = document.activeElement;

                                // focus on the first possible input elements, then primary footer buttons, then dimissibe button
                                sectionInputElement = this.querySelector('section').querySelector('input, textarea, select, button');
                                footerPrimaryButton = this.querySelector('footer .ha-button-primary');
                                closeButton = this.querySelector('header button');
                                firstFocusable = sectionInputElement || footerPrimaryButton || closeButton;

                                if (firstFocusable) {
                                    firstFocusable.focus();
                                } else {
                                    this.focus();
                                }

                                /**
                                 * @emits dismiss
                                 */
                                this.on('keydown', function(evt) {
                                    if (evt.keyCode === keys.ESCAPE) {
                                        utils.stopEvent(evt);
                                        self.emit('dismiss');
                                        self.close();
                                    }

                                    a11y.keepFocusInsideListener(evt, self);
                                });

                                this.emit('show');
                            } else if (!newValue && this.classList.contains('show')) {
                                // hide
                                if (this._lastFocus) {
                                    this._lastFocus.focus();
                                }
                                this.classList.remove('show');
                                this.off('keydown');
                                this.emit('close');
                            }
                        }
                    }
                });

                /**
                 * Executed when the user click on close button.
                 * @emits CardDiscoveryLarge#

                 */
                this.on('header button:click', function() {
                    this.emit('dismiss');
                    this.close();
                }.bind(this));
            },

            /**
             * Shows the discovery card.
             * @emits CardDiscoveryLarge#show
             */
            show: function() {
                this.open = true;
            },

            /**
             * Hides the discovery card.
             * @emits CardDiscoveryLarge#close
             */
            close: function() {
                this.open = false;
            },

            /**
             * The set of elements to show as the footer for the card. Accepts a string, a
             * single node or an array of nodes. Use <ha-footer-buttons> if you need
             * buttons.
             * @param {String|HTMLElement|[HTMLElement]} newValue The value to process.
             */
            set footer(newValue) {
                var cardFooter = this.querySelector('footer');

                while (cardFooter.firstChild) {
                    cardFooter.removeChild(cardFooter.firstChild);
                }

                if (newValue) {
                    if (typeof newValue === 'string') {
                        cardFooter.textContent = newValue;
                    } else if (Array.isArray(newValue)) {
                        [].forEach.call(newValue, function(node) {
                            if (node.nodeName === 'HA-FOOTER-BUTTONS') {
                                setFooterButtonsClass(node);
                            }
                            cardFooter.appendChild(node);
                        });
                    } else if (newValue.nodeType) {
                        if (newValue.nodeName === 'HA-FOOTER-BUTTONS') {
                            setFooterButtonsClass(newValue);
                        }
                        cardFooter.appendChild(newValue);
                    }
                }
                this._footer = newValue;
            },

            get footer() {
                return this._footer;
            },

            /**
             * The set of elements to show as the main content of the card. Accepts a
             * string, a single node or an array of nodes.
             * @param {String|HTMLElement|[HTMLElement]} newValue The section param to process.
             */
            set section(newValue) {
                var cardSection = this.querySelector('section');

                while (cardSection.firstChild) {
                    cardSection.removeChild(cardSection.firstChild);
                }

                if (newValue) {
                    if (typeof newValue === 'string') {
                        cardSection.textContent = newValue;
                    } else if (Array.isArray(newValue)) {
                        [].forEach.call(newValue, function(node) {
                            if (node && node.nodeType) {
                                cardSection.appendChild(node);
                            }
                        });
                    } else if (newValue.nodeType) {
                        cardSection.appendChild(newValue);
                    }
                }
                this._section = newValue;
            },

            get section() {
                return this._section;
            },

            /**
             * Callback attached after the Component render
             * Creates a card based on the attributes that were passed.
             */
            postRender: function _() {
                _.super(this);
                a11y.addA11yFocus(this);
                contentNode.storeCachedInput(this, contentPropertyMap);
            }
        });
    return register('ha-card-discovery-large', HaCardDiscoveryLarge);
});

define('hui/message',[
    'object-utils/classes',
    'register-component/v2/register',
    'register-component/v2/UIComponent'
], function(classes, register, UIComponent) {
    'use strict';

    var HaMessage = classes.createObject(UIComponent, {});

    return register('ha-message', HaMessage);
});

define('hui/text',[
    'object-utils/classes',
    'register-component/v2/register',
    'register-component/v2/UIComponent'
], function(classes, register, UIComponent) {
    'use strict';

    var HaText = classes.createObject(UIComponent, {});

    return register('ha-text', HaText);
});

define('hui/info-link',[
    'object-utils/classes',
    'register-component/v2/UIComponent',
    'register-component/v2/register',
    './core/utils',
    './core/keys',
    './core/a11y',
    './tooltip',
    './message',
    './text'
], function(classes, UIComponent, register, utils, keys, a11y) {
    'use strict';

    var getFirstRemovedNode = function(that, selector) {
            var nodes = that.querySelectorAll(selector),
                removed,
                first,
                content = '';

            if (nodes) {
                removed = utils.removeNodesSafe(that, nodes);
                first = removed[0];
            }

            if (first && first instanceof HTMLElement) {
                content = first;
            }

            return content;
        },
        createLinkTextNode = function() {
            return utils.createElement('span', {
                className: 'link-text'
            });
        },
        createTooltipNode = function() {
            return utils.createElement('ha-tooltip', {
                position: 'bottom top',
                dismissible: true,
                trigger: 'custom'
            });
        },
        HaInfoLink;

    HaInfoLink = classes.createObject(UIComponent, {

        init: function _() {

            _.super(this);

            /**
             * The textual portion of the info linkText
             * @type {String|HTMLElement}
             */
            this._linkText = '';

            /**
             * String for the tooltip to display.
             * @type {String|HTMLElement}
             */
            this._message = '';

            this.initializeLinkText();

            this.initializeMessage();
        },

        initializeLinkText: function() {
            var clonedLinkText = this.querySelector('.link-text'),
                linkText = this.getAttribute('linktext'),
                haText = getFirstRemovedNode(this, 'ha-text'),
                newLinkText = linkText || haText || '';

            // Fixes issue with Chrome's `cloneNode`
            if (clonedLinkText && !newLinkText) {
                newLinkText = Array.prototype.slice.call(clonedLinkText.childNodes);
            }

            this.linkText = newLinkText;
        },

        initializeMessage: function() {
            var message = this.getAttribute('message'),
                haMessage = getFirstRemovedNode(this, 'ha-message'),
                newMessage = message || haMessage || '';

            this.message = newMessage;
        },

        /**
         * The textual portion of the info linkText
         * @param {String|HTMLElement|[HTMLElement]} newValue
         */
        set linkText(newValue) {
            var linkTextNode = this.querySelector('.link-text');

            if (!linkTextNode) {
                linkTextNode = createLinkTextNode();
                this.insertBefore(linkTextNode, this.firstChild);
            }
            if (newValue) {
                if (typeof newValue === 'string') {
                    this.setAttribute('linktext', newValue);
                } else {
                    this.removeAttribute('linktext');
                }
                while (linkTextNode.firstChild) {
                    linkTextNode.removeChild(linkTextNode.firstChild);
                }
                utils.attachContentToNode(newValue, linkTextNode);
                this._linkText = newValue;
            }
        },

        /**
         * The textual portion of the info linkText
         * @return {String|HTMLElement}
         */
        get linkText() {
            return this._linkText;
        },

        /**
         * Set the message of the tooltip
         * @param {String|HTMLElement|[HTMLElement]} newValue
         */
        set message(newValue) {
            var htmlWrapper = this.ownerDocument.createElement('span'),
                tooltip = this.querySelector('ha-tooltip');
            newValue = (typeof newValue === 'string') ? newValue.trim() : newValue;

            if (!tooltip) {
                tooltip = createTooltipNode();
                this.appendChild(tooltip);
            }
            if (newValue) {
                if (typeof newValue === 'string') {
                    this.setAttribute('message', newValue);
                } else {
                    this.removeAttribute('message');
                }
                utils.attachContentToNode(newValue, htmlWrapper);

                this._message = newValue;

                tooltip.message = htmlWrapper;
            }
        },

        /**
         * The message portion of the tooltip
         * @return {String|HTMLElement}
         */
        get message() {
            return this._message;
        },

        attributeChangedCallback: function _(attrName, oldValue, newValue) {
            if (attrName === 'linktext') {
                this.linkText = newValue;
            } else if (attrName === 'message') {
                this.message = newValue;
            } else {
                _.super(this, attrName, oldValue, newValue);
            }
        },

        postRender: function _() {
            var tooltip = this.querySelector('ha-tooltip'),
                linkText = this.querySelector('.link-text');

            if (!tooltip) {
                tooltip = createTooltipNode();
                this.appendChild(tooltip);
            }
            this.tooltip = tooltip;

            this.tooltip.on('keydown', function(evt) {
                if (evt.keyCode === keys.ESCAPE) {
                    this.tooltip.close();
                }
            }.bind(this));

            _.super(this);

            this.tabIndex = '0';

            this.setAttribute('role', 'link');
            this.setAttribute('aria-haspopup', 'true');

            this.on('keydown', function(evt) {
                if (evt.keyCode === keys.SPACEBAR || evt.keyCode === keys.ENTER) {
                    linkText.classList.add('active');
                    tooltip.show();
                    tooltip.tabIndex = -1;
                    tooltip.focus();
                } else if (evt.keyCode === keys.ESCAPE) {
                    this.tooltip.close();
                }
            }.bind(this));

            this.on('.link-text:click', function(evt) {
                evt.stopImmediatePropagation();
                evt.preventDefault();

                linkText.classList.add('active');

                tooltip.show();
                tooltip.tabIndex = -1;
                this.emit('click');
            }.bind(this));

            this.listenTo(this.tooltip, 'dismiss', function(evt) {
                var target = evt.target;

                evt.stopImmediatePropagation();

                if (target && target.tagName === 'HA-TOOLTIP') {
                    target.close();
                    this.focus();
                }
            }.bind(this));

            this.listenTo(this.tooltip, 'close', function(evt) {
                evt.stopImmediatePropagation();
                linkText.classList.remove('active');
                this.tooltip.removeAttribute('tabindex');
                this.focus();
            }.bind(this));

            this.listenTo(this.tooltip, 'show', function(evt) {
                evt.stopImmediatePropagation();
            });

            a11y.addA11yFocus(this);
        },

        get tooltip() {
            return this._tooltip || this.querySelector('ha-tooltip');
        },

        set tooltip(tooltip) {
            this._tooltip = tooltip;
        },

        detachedCallback: function() {
            if (this.tooltip && this.tooltip.parentElement) {
                this.tooltip.parentElement.removeChild(this.tooltip);
            }
        }
    });

    return register('ha-info-link', HaInfoLink);
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

(function (global, factory) {
    if (typeof define === "function" && define.amd) {
        define('hui-react/HAAside',["exports", "react", "react-dom"], factory);
    } else if (typeof exports !== "undefined") {
        factory(exports, require("react"), require("react-dom"));
    } else {
        var mod = {
            exports: {}
        };
        factory(mod.exports, global.react, global.reactDom);
        global.HAAside = mod.exports;
    }
})(this, function (exports, _react, _reactDom) {
    "use strict";

    Object.defineProperty(exports, "__esModule", {
        value: true
    });

    var _react2 = _interopRequireDefault(_react);

    var _reactDom2 = _interopRequireDefault(_reactDom);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }

    var _createClass = function () {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }

        return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();

    function _possibleConstructorReturn(self, call) {
        if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
    }

    function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }

    var HAAside = function (_React$Component) {
        _inherits(HAAside, _React$Component);

        function HAAside(props) {
            _classCallCheck(this, HAAside);

            return _possibleConstructorReturn(this, (HAAside.__proto__ || Object.getPrototypeOf(HAAside)).call(this, props));
        }

        _createClass(HAAside, [{
            key: "render",
            value: function render() {
                /* jshint ignore:start */
                return _react2.default.createElement(
                    "aside",
                    this.props,
                    this.props.children
                );
                /* jshint ignore:end */
            }
        }]);

        return HAAside;
    }(_react2.default.Component);

    exports.default = HAAside;
});
//# sourceMappingURL=HAAside.js.map
;
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

(function (global, factory) {
    if (typeof define === "function" && define.amd) {
        define('hui-react/HASection',["exports", "react", "react-dom"], factory);
    } else if (typeof exports !== "undefined") {
        factory(exports, require("react"), require("react-dom"));
    } else {
        var mod = {
            exports: {}
        };
        factory(mod.exports, global.react, global.reactDom);
        global.HASection = mod.exports;
    }
})(this, function (exports, _react, _reactDom) {
    "use strict";

    Object.defineProperty(exports, "__esModule", {
        value: true
    });

    var _react2 = _interopRequireDefault(_react);

    var _reactDom2 = _interopRequireDefault(_reactDom);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }

    var _createClass = function () {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }

        return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();

    function _possibleConstructorReturn(self, call) {
        if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
    }

    function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }

    var HASection = function (_React$Component) {
        _inherits(HASection, _React$Component);

        function HASection(props) {
            _classCallCheck(this, HASection);

            return _possibleConstructorReturn(this, (HASection.__proto__ || Object.getPrototypeOf(HASection)).call(this, props));
        }

        _createClass(HASection, [{
            key: "render",
            value: function render() {
                /* jshint ignore:start */
                return _react2.default.createElement(
                    "section",
                    this.props,
                    this.props.children
                );
                /* jshint ignore:end */
            }
        }]);

        return HASection;
    }(_react2.default.Component);

    exports.default = HASection;
});
//# sourceMappingURL=HASection.js.map
;
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

(function (global, factory) {
    if (typeof define === "function" && define.amd) {
        define('hui-react/HAFooter',["exports", "react", "react-dom"], factory);
    } else if (typeof exports !== "undefined") {
        factory(exports, require("react"), require("react-dom"));
    } else {
        var mod = {
            exports: {}
        };
        factory(mod.exports, global.react, global.reactDom);
        global.HAFooter = mod.exports;
    }
})(this, function (exports, _react, _reactDom) {
    "use strict";

    Object.defineProperty(exports, "__esModule", {
        value: true
    });

    var _react2 = _interopRequireDefault(_react);

    var _reactDom2 = _interopRequireDefault(_reactDom);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }

    var _createClass = function () {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }

        return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();

    function _possibleConstructorReturn(self, call) {
        if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
    }

    function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }

    var HAFooter = function (_React$Component) {
        _inherits(HAFooter, _React$Component);

        function HAFooter(props) {
            _classCallCheck(this, HAFooter);

            return _possibleConstructorReturn(this, (HAFooter.__proto__ || Object.getPrototypeOf(HAFooter)).call(this, props));
        }

        _createClass(HAFooter, [{
            key: "render",
            value: function render() {
                /* jshint ignore:start */
                return _react2.default.createElement(
                    "footer",
                    this.props,
                    this.props.children
                );
                /* jshint ignore:end */
            }
        }]);

        return HAFooter;
    }(_react2.default.Component);

    exports.default = HAFooter;
});
//# sourceMappingURL=HAFooter.js.map
;
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

(function (global, factory) {
    if (typeof define === "function" && define.amd) {
        define('hui-react/HACardDiscoveryLarge',["exports", "react", "./HASection", "./HAFooter", "hui/core/utils", "hui/card-discovery-large"], factory);
    } else if (typeof exports !== "undefined") {
        factory(exports, require("react"), require("./HASection"), require("./HAFooter"), require("hui/core/utils"), require("hui/card-discovery-large"));
    } else {
        var mod = {
            exports: {}
        };
        factory(mod.exports, global.react, global.HASection, global.HAFooter, global.utils, global.cardDiscoveryLarge);
        global.HACardDiscoveryLarge = mod.exports;
    }
})(this, function (exports, _react, _HASection, _HAFooter, _utils) {
    "use strict";

    Object.defineProperty(exports, "__esModule", {
        value: true
    });

    var _react2 = _interopRequireDefault(_react);

    var _HASection2 = _interopRequireDefault(_HASection);

    var _HAFooter2 = _interopRequireDefault(_HAFooter);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }

    var _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];

            for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }

        return target;
    };

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }

    var _createClass = function () {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }

        return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();

    function _possibleConstructorReturn(self, call) {
        if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
    }

    function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }

    var HACardDiscoveryLarge = function (_React$Component) {
        _inherits(HACardDiscoveryLarge, _React$Component);

        function HACardDiscoveryLarge(props) {
            _classCallCheck(this, HACardDiscoveryLarge);

            var _this = _possibleConstructorReturn(this, (HACardDiscoveryLarge.__proto__ || Object.getPrototypeOf(HACardDiscoveryLarge)).call(this, props));

            _initialiseProps.call(_this);

            _this._cardDiscoveryLarge = null; // cardDiscoveryLarge DOM reference, set after render()
            // keep track if we have set any event listeners on cardDiscoveryLarge
            _this._listeners = {};
            return _this;
        }

        // check that the only children passed to this component are a HASection or HAFooter

        _createClass(HACardDiscoveryLarge, [{
            key: "componentDidMount",
            value: function componentDidMount() {
                // handle React 15 partial rewrite
                this.fixRenderedChildren();
                this.mountCardDiscoveryLarge();
            }
        }, {
            key: "componentDidUpdate",
            value: function componentDidUpdate(prevProps) {
                this.mountCardDiscoveryLarge(prevProps);
            }
        }, {
            key: "fixRenderedChildren",
            value: function fixRenderedChildren() {

                var cardContainer = this._cardDiscoveryLarge.querySelector('.card-discovery-large-container'),
                    siblingSection = cardContainer.nextElementSibling;

                // short circuit if already been amended
                if (!siblingSection) {
                    return;
                }

                this._cardDiscoveryLarge.section = siblingSection;

                // if no children, only update textContent
                // otherwise, move children back under original section
                var underlyingSection = cardContainer.querySelector('section > section'),
                    underlyingSectionChildren = Array.prototype.slice.call(underlyingSection.children);

                if (underlyingSectionChildren.length < 1) {
                    this._cardDiscoveryLarge.section = siblingSection.textContent;
                } else {
                    var outerSection = this._cardDiscoveryLarge.querySelector('section');
                    underlyingSectionChildren.forEach(function (sectionElement) {
                        outerSection.appendChild(sectionElement);
                    });
                }

                // move rendered footer into empty footer container
                var renderedFooter = cardContainer.nextElementSibling;
                cardContainer.removeChild(cardContainer.querySelector('footer'));

                // update footer if not empty
                if (renderedFooter) {
                    cardContainer.appendChild(renderedFooter);
                    this._cardDiscoveryLarge.footer = Array.prototype.slice.call(renderedFooter.children);
                }
            }
        }, {
            key: "mountCardDiscoveryLarge",
            value: function mountCardDiscoveryLarge() {
                var _this2 = this;

                var prevProps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

                if (this._cardDiscoveryLarge && this.props.open !== prevProps.open) {
                    if (this.props.open) {
                        var sectionInputElement, footerPrimaryButton, closeButton, firstFocusable;
                        this.setupListeners();
                        if (this._cardDiscoveryLarge.show) {
                            this._cardDiscoveryLarge.show(); // show card discvoery large in DOM using hui/card-discovery-large
                        } else {
                                // on browsers that doesn't support custom elements natively,
                                // the component is not upgraded yet so show is not available, wait for event
                                var componentUpgraded = function componentUpgraded(event) {
                                    event.stopPropagation();
                                    _this2._cardDiscoveryLarge.show(); // show card discvoery large in DOM using hui/card-discovery-large
                                };
                                this._listeners.componentUpgraded = componentUpgraded.bind(this);
                                this._cardDiscoveryLarge.addEventListener("component-upgraded", this._listeners.componentUpgraded);
                            }
                        // focus on the first possible input elements, then primary footer buttons, then dimissibe button
                        // necessary to do again because react is overriding focus
                        sectionInputElement = this._cardDiscoveryLarge.querySelector('section').querySelector('input, textarea, select, button');
                        footerPrimaryButton = this._cardDiscoveryLarge.querySelector('footer .ha-button-primary');
                        closeButton = this._cardDiscoveryLarge.querySelector('header button');
                        firstFocusable = sectionInputElement || footerPrimaryButton || closeButton;

                        if (firstFocusable) {
                            firstFocusable.focus();
                        } else {
                            this.focus();
                        }
                    } else if (prevProps.show) {
                        // remove Card from DOM using hui/card-discovery-large
                        this._cardDiscoveryLarge.close();
                    }
                }
            }
        }, {
            key: "setupListeners",
            value: function setupListeners() {
                var _this3 = this;

                if (Object.keys(this._listeners).length === 0) {
                    var onShow = function onShow(event) {
                        event.stopPropagation();
                        if (_this3.props.onShow) {
                            _this3.props.onShow(event);
                        }
                    };
                    this._listeners.onShow = onShow.bind(this);
                    this._cardDiscoveryLarge.addEventListener("show", this._listeners.onShow);

                    var onClose = function onClose(event) {
                        event.stopPropagation();
                        if (_this3.props.onClose) {
                            _this3.props.onClose(event);
                        }
                    };
                    this._listeners.onClose = onClose.bind(this);
                    this._cardDiscoveryLarge.addEventListener("close", this._listeners.onClose);

                    var onDismiss = function onDismiss(event) {
                        event.stopPropagation();
                        if (_this3.props.onDismiss) {
                            _this3.props.onDismiss(event);
                        }
                    };
                    this._listeners.onDismiss = onDismiss.bind(this);
                    this._cardDiscoveryLarge.addEventListener("dismiss", this._listeners.onDismiss);
                }
            }
        }, {
            key: "componentWillUnmount",
            value: function componentWillUnmount() {
                this._cardDiscoveryLarge.removeEventListener("show", this._listeners.onShow, false); // clean up show listener
                this._cardDiscoveryLarge.removeEventListener("close", this._listeners.onClose, false); // clean up close listener
                this._cardDiscoveryLarge.removeEventListener("dismiss", this._listeners.onDismiss, false); // clean up dismiss listener
                this._cardDiscoveryLarge.removeEventListener("component-upgraded", this._listeners.componentUpgraded, false); // clean up component-upgraded listener
                this._listeners = {};
            }
        }, {
            key: "render",
            value: function render() {
                /* jshint ignore:start */
                return _react2.default.createElement(
                    "ha-card-discovery-large",
                    _extends({
                        ref: this.handleRef,
                        "class": this.props.className
                    }, this.props),
                    this.props.children
                );
                /* jshint ignore:end */
            }
        }]);

        return HACardDiscoveryLarge;
    }(_react2.default.Component);

    HACardDiscoveryLarge.propTypes = {
        children: function children(props, propName, componentName) {
            var error = (0, _utils.checkReactChildrenType)(props[propName], componentName, [_HASection2.default, _HAFooter2.default], "HASection,HAFooter");
            if (error) {
                return error;
            }
        },
        className: _react2.default.PropTypes.string,
        titleText: _react2.default.PropTypes.string,
        dismissible: _react2.default.PropTypes.bool,
        open: _react2.default.PropTypes.bool,
        onShow: _react2.default.PropTypes.func,
        onClose: _react2.default.PropTypes.func,
        onDismiss: _react2.default.PropTypes.func
    };

    var _initialiseProps = function _initialiseProps() {
        var _this4 = this;

        this.handleRef = function (c) {
            _this4._cardDiscoveryLarge = c;
        };
    };

    exports.default = HACardDiscoveryLarge;
});
//# sourceMappingURL=HACardDiscoveryLarge.js.map
;
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

(function (global, factory) {
    if (typeof define === "function" && define.amd) {
        define('hui-react/HACheckbox',["exports", "react", "hui/checkbox"], factory);
    } else if (typeof exports !== "undefined") {
        factory(exports, require("react"), require("hui/checkbox"));
    } else {
        var mod = {
            exports: {}
        };
        factory(mod.exports, global.react, global.checkbox);
        global.HACheckbox = mod.exports;
    }
})(this, function (exports, _react) {
    "use strict";

    Object.defineProperty(exports, "__esModule", {
        value: true
    });

    var _react2 = _interopRequireDefault(_react);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }

    var _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];

            for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }

        return target;
    };

    function _objectWithoutProperties(obj, keys) {
        var target = {};

        for (var i in obj) {
            if (keys.indexOf(i) >= 0) continue;
            if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
            target[i] = obj[i];
        }

        return target;
    }

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }

    var _createClass = function () {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }

        return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();

    function _possibleConstructorReturn(self, call) {
        if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
    }

    function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }

    var HACheckbox = function (_React$Component) {
        _inherits(HACheckbox, _React$Component);

        function HACheckbox(props) {
            _classCallCheck(this, HACheckbox);

            var _this = _possibleConstructorReturn(this, (HACheckbox.__proto__ || Object.getPrototypeOf(HACheckbox)).call(this, props));

            _this.handleRef = function (c) {
                _this._huiComponent = c;
            };

            _this._huiComponent = null;
            _this._listeners = {};
            return _this;
        }

        _createClass(HACheckbox, [{
            key: "componentDidMount",
            value: function componentDidMount() {
                var _this2 = this;

                // With es6 syntax we have to bind the events to the react component instance
                // https://facebook.github.io/react/docs/reusable-components.html#no-autobinding
                // Event handler for change
                var onChange = function onChange(event) {
                    event.stopPropagation();
                    if (_this2.props.onChange) {
                        _this2.props.onChange(event);
                    }
                };
                this._listeners.onChange = onChange.bind(this);
                this._huiComponent.addEventListener("change", this._listeners.onChange);

                // Event handler for click
                var onClick = function onClick(event) {
                    event.stopPropagation();
                    if (_this2.props.onClick) {
                        _this2.props.onClick(event);
                    }
                };
                this._listeners.onClick = onClick.bind(this);
                this._huiComponent.addEventListener("click", this._listeners.onClick);
            }
        }, {
            key: "componentWillUnmount",
            value: function componentWillUnmount() {
                this._huiComponent.removeEventListener("change", this._listeners.onChange, false);
                this._huiComponent.removeEventListener("click", this._listeners.onClick, false);
            }
        }, {
            key: "render",
            value: function render() {
                var _props = this.props,

                /* jshint ignore:start */
                disabled = _props.disabled,
                    props = _objectWithoutProperties(_props, ["disabled"]);

                // polyfill for IE 11, ref: https://github.com/facebook/react/issues/961
                return disabled === true || disabled === "true" ? _react2.default.createElement("ha-checkbox", _extends({ ref: this.handleRef, "class": this.props.className, disabled: true }, props)) : _react2.default.createElement("ha-checkbox", _extends({ ref: this.handleRef, "class": this.props.className }, props));
                /* jshint ignore:end */
            }
        }]);

        return HACheckbox;
    }(_react2.default.Component);

    HACheckbox.propTypes = {
        className: _react2.default.PropTypes.string,
        label: _react2.default.PropTypes.string,
        value: _react2.default.PropTypes.string,
        name: _react2.default.PropTypes.string,
        checked: _react2.default.PropTypes.bool,
        disabled: _react2.default.PropTypes.bool,
        indeterminate: _react2.default.PropTypes.bool,
        onChange: _react2.default.PropTypes.func,
        onClick: _react2.default.PropTypes.func
    };
    exports.default = HACheckbox;
});
//# sourceMappingURL=HACheckbox.js.map
;
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

(function (global, factory) {
    if (typeof define === "function" && define.amd) {
        define('hui-react/HACheckboxGroup',["exports", "react", "hui/checkbox-group"], factory);
    } else if (typeof exports !== "undefined") {
        factory(exports, require("react"), require("hui/checkbox-group"));
    } else {
        var mod = {
            exports: {}
        };
        factory(mod.exports, global.react, global.checkboxGroup);
        global.HACheckboxGroup = mod.exports;
    }
})(this, function (exports, _react) {
    "use strict";

    Object.defineProperty(exports, "__esModule", {
        value: true
    });

    var _react2 = _interopRequireDefault(_react);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }

    var _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];

            for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }

        return target;
    };

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }

    var _createClass = function () {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }

        return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();

    function _possibleConstructorReturn(self, call) {
        if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
    }

    function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }

    var HACheckboxGroup = function (_React$Component) {
        _inherits(HACheckboxGroup, _React$Component);

        function HACheckboxGroup(props) {
            _classCallCheck(this, HACheckboxGroup);

            var _this = _possibleConstructorReturn(this, (HACheckboxGroup.__proto__ || Object.getPrototypeOf(HACheckboxGroup)).call(this, props));

            _this.handleRef = function (c) {
                _this._huiComponent = c;
            };

            _this._huiComponent = null;
            _this._listeners = {};
            return _this;
        }

        _createClass(HACheckboxGroup, [{
            key: "testValidity",
            value: function testValidity() {
                if (this.props.onValidityChange) {
                    var valid = undefined;
                    if (this._huiComponent.checkValidity) {
                        valid = this._huiComponent.checkValidity();
                    }
                    if (this._lastValidity !== valid) {
                        this._lastValidity = valid;
                        this.props.onValidityChange(valid);
                    }
                }
            }
        }, {
            key: "componentDidMount",
            value: function componentDidMount() {
                var _this2 = this;

                // With es6 syntax we have to bind the events to the react component instance
                // https://facebook.github.io/react/docs/reusable-components.html#no-autobinding
                // Event handler for change
                var onChange = function onChange(event) {
                    event.stopPropagation();
                    if (_this2.props.onChange) {
                        _this2.props.onChange(event);
                    }
                    _this2.testValidity();
                };

                // Update react components to the web component
                this.removeWebRenderComp();
                this.updateCheckboxes();
                this._huiComponent._setCheckboxHandle();

                this._listeners.onChange = onChange.bind(this);
                this._huiComponent.addEventListener("change", this._listeners.onChange);

                // Event handler for click
                var onClick = function onClick(event) {
                    event.stopPropagation();
                    if (_this2.props.onClick) {
                        _this2.props.onClick(event);
                    }
                };
                this._listeners.onClick = onClick.bind(this);
                this._huiComponent.addEventListener("click", this._listeners.onClick);

                // Stop validation tooltip show event propagation
                var onShow = function onShow(event) {
                    event.stopPropagation();
                };
                this._listeners.onShow = onShow.bind(this);
                this._huiComponent.addEventListener("show", this._listeners.onShow);

                // Stop validation tooltip close event propagation
                var onClose = function onClose(event) {
                    event.stopPropagation();
                };
                this._listeners.onClose = onClose.bind(this);
                this._huiComponent.addEventListener("close", this._listeners.onClose);

                // Stop validation tooltip dismiss event propagation
                var onDismiss = function onDismiss(event) {
                    event.stopPropagation();
                };
                this._listeners.onDismiss = onDismiss.bind(this);
                this._huiComponent.addEventListener("dismiss", this._listeners.onDismiss);

                window.setTimeout(function () {
                    // We need the timeout so h-ui component checkValidity function is initialized
                    if (_this2.props.validator) {
                        _this2._huiComponent.validator = _this2.props.validator;
                    }
                    if (_this2.props.alwaysRenderValidity) {
                        _this2._huiComponent.reportValidity();
                    }
                    _this2.testValidity(); // We need to do initial notification of validity state.
                }, 0);
            }
        }, {
            key: "componentWillUnmount",
            value: function componentWillUnmount() {
                this._huiComponent.removeEventListener("change", this._listeners.onChange, false);
                this._huiComponent.removeEventListener("click", this._listeners.onClick, false);
                this._huiComponent.removeEventListener("show", this._listeners.onShow, false);
                this._huiComponent.removeEventListener("close", this._listeners.onClose, false);
                this._huiComponent.removeEventListener("dismiss", this._listeners.onDismiss, false);
            }
        }, {
            key: "componentDidUpdate",
            value: function componentDidUpdate() {
                if (this.props.validator) {
                    this._huiComponent.validator = this.props.validator;
                }
                this.testValidity();
                if (this.props.alwaysRenderValidity) {
                    this._huiComponent.reportValidity();
                }
            }
        }, {
            key: "removeWebRenderComp",
            value: function removeWebRenderComp() {
                var fieldChild = this._huiComponent.querySelectorAll("fieldset");
                if (fieldChild && fieldChild.length > 1) {
                    this._huiComponent.removeChild(fieldChild[0]);
                }
            }
        }, {
            key: "updateCheckboxes",
            value: function updateCheckboxes() {
                var checkboxes = this._huiComponent.querySelectorAll("ha-checkbox");
                if (checkboxes) {
                    this._huiComponent.checkboxes = Array.prototype.slice.call(checkboxes);
                }
            }
        }, {
            key: "render",
            value: function render() {
                /* jshint ignore:start */
                return _react2.default.createElement(
                    "ha-checkbox-group",
                    _extends({
                        ref: this.handleRef,
                        "class": this.props.className
                    }, this.props),
                    _react2.default.createElement(
                        "fieldset",
                        null,
                        this.props.label ? _react2.default.createElement(
                            "div",
                            { className: "label-container" },
                            _react2.default.createElement(
                                "legend",
                                null,
                                this.props.label
                            )
                        ) : null,
                        this.props.children
                    )
                );
                /* jshint ignore:end */
            }
        }]);

        return HACheckboxGroup;
    }(_react2.default.Component);

    HACheckboxGroup.propTypes = {
        className: _react2.default.PropTypes.string,
        name: _react2.default.PropTypes.string,
        label: _react2.default.PropTypes.string,
        value: _react2.default.PropTypes.array,
        checkboxes: _react2.default.PropTypes.array,
        selectedItems: _react2.default.PropTypes.array,
        minRequired: _react2.default.PropTypes.number,
        required: _react2.default.PropTypes.bool,
        noRequiredIndicator: _react2.default.PropTypes.bool,
        min: _react2.default.PropTypes.number,
        max: _react2.default.PropTypes.number,
        requiredMessage: _react2.default.PropTypes.string,
        invalidMessage: _react2.default.PropTypes.string,
        validator: _react2.default.PropTypes.func,
        onValidityChange: _react2.default.PropTypes.func,
        alwaysRenderValidity: _react2.default.PropTypes.bool,
        onChange: _react2.default.PropTypes.func,
        onClick: _react2.default.PropTypes.func
    };
    exports.default = HACheckboxGroup;
});
//# sourceMappingURL=HACheckboxGroup.js.map
;
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

(function (global, factory) {
    if (typeof define === "function" && define.amd) {
        define('hui-react/HAItem',["exports", "react", "hui/item"], factory);
    } else if (typeof exports !== "undefined") {
        factory(exports, require("react"), require("hui/item"));
    } else {
        var mod = {
            exports: {}
        };
        factory(mod.exports, global.react, global.item);
        global.HAItem = mod.exports;
    }
})(this, function (exports, _react) {
    "use strict";

    Object.defineProperty(exports, "__esModule", {
        value: true
    });

    var _react2 = _interopRequireDefault(_react);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }

    var _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];

            for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }

        return target;
    };

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }

    var _createClass = function () {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }

        return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();

    function _possibleConstructorReturn(self, call) {
        if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
    }

    function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }

    var HAItem = function (_React$Component) {
        _inherits(HAItem, _React$Component);

        function HAItem(props) {
            _classCallCheck(this, HAItem);

            return _possibleConstructorReturn(this, (HAItem.__proto__ || Object.getPrototypeOf(HAItem)).call(this, props));
        }

        _createClass(HAItem, [{
            key: "render",
            value: function render() {
                /* jshint ignore:start */
                return _react2.default.createElement(
                    "ha-item",
                    _extends({ "class": this.props.className }, this.props),
                    this.props.children
                );
                /* jshint ignore:end */
            }
        }]);

        return HAItem;
    }(_react2.default.Component);

    HAItem.propTypes = {
        className: _react2.default.PropTypes.string,
        value: _react2.default.PropTypes.string,
        disabled: _react2.default.PropTypes.oneOfType([_react2.default.PropTypes.bool, _react2.default.PropTypes.string])
    };
    exports.default = HAItem;
});
//# sourceMappingURL=HAItem.js.map
;
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

(function (global, factory) {
    if (typeof define === "function" && define.amd) {
        define('hui-react/HAComboButton',["exports", "react", "./HAItem", "hui/core/utils", "hui/combo-button"], factory);
    } else if (typeof exports !== "undefined") {
        factory(exports, require("react"), require("./HAItem"), require("hui/core/utils"), require("hui/combo-button"));
    } else {
        var mod = {
            exports: {}
        };
        factory(mod.exports, global.react, global.HAItem, global.utils, global.comboButton);
        global.HAComboButton = mod.exports;
    }
})(this, function (exports, _react, _HAItem, _utils) {
    "use strict";

    Object.defineProperty(exports, "__esModule", {
        value: true
    });

    var _react2 = _interopRequireDefault(_react);

    var _HAItem2 = _interopRequireDefault(_HAItem);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }

    var _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];

            for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }

        return target;
    };

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }

    var _createClass = function () {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }

        return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();

    function _possibleConstructorReturn(self, call) {
        if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
    }

    function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }

    var HAComboButton = function (_React$Component) {
        _inherits(HAComboButton, _React$Component);

        function HAComboButton(props) {
            _classCallCheck(this, HAComboButton);

            var _this = _possibleConstructorReturn(this, (HAComboButton.__proto__ || Object.getPrototypeOf(HAComboButton)).call(this, props));

            _initialiseProps.call(_this);

            _this._huiComponent = null;
            _this._listeners = {};
            return _this;
        }

        _createClass(HAComboButton, [{
            key: "componentDidMount",
            value: function componentDidMount() {
                var _this2 = this;

                // With es6 syntax we have to bind the events to the react component instance
                // https://facebook.github.io/react/docs/reusable-components.html#no-autobinding
                // Event handler for click
                var onClick = function onClick(event) {
                    event.stopPropagation();
                    if (_this2.props.onClick) {
                        _this2.props.onClick(event);
                    }
                };
                this._listeners.onClick = onClick.bind(this);
                this._huiComponent.addEventListener("click", this._listeners.onClick);

                // Event handler for items-close
                var onItemsClose = function onItemsClose(event) {
                    event.stopPropagation();
                    if (_this2.props.onItemsClose) {
                        _this2.props.onItemsClose(event);
                    }
                };
                this._listeners.onItemsClose = onItemsClose.bind(this);
                this._huiComponent.addEventListener("items-close", this._listeners.onItemsClose);

                // Event handler for items-show
                var onItemsShow = function onItemsShow(event) {
                    event.stopPropagation();
                    if (_this2.props.onItemsShow) {
                        _this2.props.onItemsShow(event);
                    }
                };
                this._listeners.onItemsShow = onItemsShow.bind(this);
                this._huiComponent.addEventListener("items-show", this._listeners.onItemsShow);

                // Event handler for select
                var onSelect = function onSelect(event) {
                    event.stopPropagation();
                    if (_this2.props.onSelect) {
                        _this2.props.onSelect(event);
                    }
                };
                this._listeners.onSelect = onSelect.bind(this);
                this._huiComponent.addEventListener("select", this._listeners.onSelect);
            }
        }, {
            key: "componentWillUnmount",
            value: function componentWillUnmount() {
                this._huiComponent.removeEventListener("click", this._listeners.onClick, false);
                this._huiComponent.removeEventListener("items-close", this._listeners.onItemsClose, false);
                this._huiComponent.removeEventListener("items-show", this._listeners.onItemsShow, false);
                this._huiComponent.removeEventListener("select", this._listeners.onSelect, false);
            }
        }, {
            key: "render",
            value: function render() {
                /* jshint ignore:start */
                return _react2.default.createElement(
                    "ha-combo-button",
                    _extends({
                        ref: this.handleRef,
                        "class": this.props.className
                    }, this.props),
                    this.props.children
                );
                /* jshint ignore:end */
            }
        }]);

        return HAComboButton;
    }(_react2.default.Component);

    HAComboButton.propTypes = {
        children: function anonymous(props, propName, componentName) {
            var error = (0, _utils.checkReactChildrenType)(props[propName], componentName, _HAItem2.default, "HAItem");
            if (error) {
                return error;
            }
        },
        className: _react2.default.PropTypes.string,
        label: _react2.default.PropTypes.string,
        disabled: _react2.default.PropTypes.bool,
        selectedIndex: _react2.default.PropTypes.number,
        selectedItem: _react2.default.PropTypes.object,
        items: _react2.default.PropTypes.array,
        onClick: _react2.default.PropTypes.func,
        onItemsClose: _react2.default.PropTypes.func,
        onItemsShow: _react2.default.PropTypes.func,
        onSelect: _react2.default.PropTypes.func
    };

    var _initialiseProps = function _initialiseProps() {
        var _this3 = this;

        this.handleRef = function (c) {
            _this3._huiComponent = c;
        };
    };

    exports.default = HAComboButton;
});
//# sourceMappingURL=HAComboButton.js.map
;
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

(function (global, factory) {
    if (typeof define === "function" && define.amd) {
        define('hui-react/HAComboLink',["exports", "react", "./HAItem", "hui/core/utils", "hui/combo-link"], factory);
    } else if (typeof exports !== "undefined") {
        factory(exports, require("react"), require("./HAItem"), require("hui/core/utils"), require("hui/combo-link"));
    } else {
        var mod = {
            exports: {}
        };
        factory(mod.exports, global.react, global.HAItem, global.utils, global.comboLink);
        global.HAComboLink = mod.exports;
    }
})(this, function (exports, _react, _HAItem, _utils) {
    "use strict";

    Object.defineProperty(exports, "__esModule", {
        value: true
    });

    var _react2 = _interopRequireDefault(_react);

    var _HAItem2 = _interopRequireDefault(_HAItem);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }

    var _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];

            for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }

        return target;
    };

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }

    var _createClass = function () {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }

        return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();

    function _possibleConstructorReturn(self, call) {
        if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
    }

    function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }

    var HAComboLink = function (_React$Component) {
        _inherits(HAComboLink, _React$Component);

        function HAComboLink(props) {
            _classCallCheck(this, HAComboLink);

            var _this = _possibleConstructorReturn(this, (HAComboLink.__proto__ || Object.getPrototypeOf(HAComboLink)).call(this, props));

            _initialiseProps.call(_this);

            _this._huiComponent = null;
            _this._listeners = {};
            return _this;
        }

        _createClass(HAComboLink, [{
            key: "componentDidMount",
            value: function componentDidMount() {
                var _this2 = this;

                // With es6 syntax we have to bind the events to the react component instance
                // https://facebook.github.io/react/docs/reusable-components.html#no-autobinding
                // Event handler for click
                var onClick = function onClick(event) {
                    event.stopPropagation();
                    if (_this2.props.onClick) {
                        _this2.props.onClick(event);
                    }
                };
                this._listeners.onClick = onClick.bind(this);
                this._huiComponent.addEventListener("click", this._listeners.onClick);

                // Event handler for items-close
                var onItemsClose = function onItemsClose(event) {
                    event.stopPropagation();
                    if (_this2.props.onItemsClose) {
                        _this2.props.onItemsClose(event);
                    }
                };
                this._listeners.onItemsClose = onItemsClose.bind(this);
                this._huiComponent.addEventListener("items-close", this._listeners.onItemsClose);

                // Event handler for items-show
                var onItemsShow = function onItemsShow(event) {
                    event.stopPropagation();
                    if (_this2.props.onItemsShow) {
                        _this2.props.onItemsShow(event);
                    }
                };
                this._listeners.onItemsShow = onItemsShow.bind(this);
                this._huiComponent.addEventListener("items-show", this._listeners.onItemsShow);

                // Event handler for select
                var onSelect = function onSelect(event) {
                    event.stopPropagation();
                    if (_this2.props.onSelect) {
                        _this2.props.onSelect(event);
                    }
                };
                this._listeners.onSelect = onSelect.bind(this);
                this._huiComponent.addEventListener("select", this._listeners.onSelect);

                // will re-render HA-ITEMS as HA-MENU-ITEMS for IE 11 fix
                this.updateWebComponent();
            }
        }, {
            key: "updateWebComponent",
            value: function updateWebComponent() {
                var items = this._huiComponent.querySelectorAll("ha-item");
                if (items) {
                    this._huiComponent.items = Array.prototype.slice.call(items);
                }
            }
        }, {
            key: "componentWillUnmount",
            value: function componentWillUnmount() {
                this._huiComponent.removeEventListener("click", this._listeners.onClick, false);
                this._huiComponent.removeEventListener("items-close", this._listeners.onItemsClose, false);
                this._huiComponent.removeEventListener("items-show", this._listeners.onItemsShow, false);
                this._huiComponent.removeEventListener("select", this._listeners.onSelect, false);
            }
        }, {
            key: "render",
            value: function render() {
                /* jshint ignore:start */
                return _react2.default.createElement(
                    "ha-combo-link",
                    _extends({
                        ref: this.handleRef,
                        "class": this.props.className
                    }, this.props),
                    this.props.children
                );
                /* jshint ignore:end */
            }
        }]);

        return HAComboLink;
    }(_react2.default.Component);

    HAComboLink.propTypes = {
        children: function anonymous(props, propName, componentName) {
            var error = (0, _utils.checkReactChildrenType)(props[propName], componentName, _HAItem2.default, "HAItem");
            if (error) {
                return error;
            }
        },
        className: _react2.default.PropTypes.string,
        label: _react2.default.PropTypes.string,
        disabled: _react2.default.PropTypes.bool,
        selectedIndex: _react2.default.PropTypes.number,
        selectedItem: _react2.default.PropTypes.object,
        items: _react2.default.PropTypes.array,
        onClick: _react2.default.PropTypes.func,
        onItemsClose: _react2.default.PropTypes.func,
        onItemsShow: _react2.default.PropTypes.func,
        onSelect: _react2.default.PropTypes.func
    };

    var _initialiseProps = function _initialiseProps() {
        var _this3 = this;

        this.handleRef = function (c) {
            _this3._huiComponent = c;
        };
    };

    exports.default = HAComboLink;
});
//# sourceMappingURL=HAComboLink.js.map
;
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

(function (global, factory) {
    if (typeof define === "function" && define.amd) {
        define('hui-react/HADatePicker',["exports", "react", "hui/core/utils", "hui/date-picker"], factory);
    } else if (typeof exports !== "undefined") {
        factory(exports, require("react"), require("hui/core/utils"), require("hui/date-picker"));
    } else {
        var mod = {
            exports: {}
        };
        factory(mod.exports, global.react, global.utils, global.datePicker);
        global.HADatePicker = mod.exports;
    }
})(this, function (exports, _react, _utils) {
    "use strict";

    Object.defineProperty(exports, "__esModule", {
        value: true
    });

    var _react2 = _interopRequireDefault(_react);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }

    var _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];

            for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }

        return target;
    };

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }

    var _createClass = function () {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }

        return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();

    function _possibleConstructorReturn(self, call) {
        if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
    }

    function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }

    var HADatePicker = function (_React$Component) {
        _inherits(HADatePicker, _React$Component);

        function HADatePicker(props) {
            _classCallCheck(this, HADatePicker);

            var _this = _possibleConstructorReturn(this, (HADatePicker.__proto__ || Object.getPrototypeOf(HADatePicker)).call(this, props));

            _this.handleRef = function (c) {
                _this._huiComponent = c;
            };

            _this._huiComponent = null;
            _this._listeners = {}; // keep track if we have set any event listeners on date picker
            _this._huiMethodsCalled = []; // keep track of hui methods called so we do not call them again
            _this.state = {
                classAttributes: null
            };
            return _this;
        }

        _createClass(HADatePicker, [{
            key: "componentDidMount",
            value: function componentDidMount() {
                this.mountDatePicker();
            }
        }, {
            key: "componentDidUpdate",
            value: function componentDidUpdate(prevProps) {
                this.mountDatePicker(prevProps);
            }
        }, {
            key: "mountDatePicker",
            value: function mountDatePicker() {
                var _this2 = this;

                var prevProps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

                if (this._huiComponent) {

                    this.setupListeners();

                    if (this.props.validator) {
                        this._huiComponent.validator = this.props.validator;
                    }

                    this._testValidity();

                    if (this._huiComponent.showCalendar) {
                        //Check to see if browser supports custom elements. Currently only chrome
                        this.addHUIMethods();
                    } else {
                        // For browsers that don't support custom elements i.e IE, FF
                        var componentUpgraded = function componentUpgraded(event) {
                            event.stopPropagation();
                            _this2.addHUIMethods();
                        };
                        this._listeners.componentUpgraded = componentUpgraded.bind(this);
                        this._huiComponent.addEventListener("component-upgraded", this._listeners.componentUpgraded);
                    }

                    // handle className props being passed to custom element
                    if (this.props.className !== prevProps.className) {
                        this.updateElementClasses();
                    }
                }
            }
        }, {
            key: "updateElementClasses",
            value: function updateElementClasses() {
                var mergedClassString = (0, _utils.updateClassWithProps)(this._huiComponent, this.props.className);
                if (mergedClassString) {
                    this.setState({
                        classAttributes: mergedClassString
                    });
                }
            }
        }, {
            key: "setupListeners",
            value: function setupListeners() {
                var _this3 = this;

                var onInput = function onInput(event) {
                    event.stopPropagation();
                    if (_this3.props.onInput) {
                        _this3.props.onInput(event);
                    }
                    _this3._testValidity();
                };
                this._listeners.onInput = onInput.bind(this);

                if (this._huiComponent) {
                    this._huiComponent.addEventListener("input", this._listeners.onInput);
                }

                var onChange = function onChange(event) {
                    event.stopPropagation();
                    if (_this3.props.onChange) {
                        _this3.props.onChange(event);
                    }
                };
                this._listeners.onChange = onChange.bind(this);
                if (this._huiComponent) {
                    this._huiComponent.addEventListener("change", this._listeners.onChange);
                }
            }
        }, {
            key: "componentWillUnmount",
            value: function componentWillUnmount() {
                this._huiComponent.removeEventListener("change", this._listeners.onChange, false);
                this._huiComponent.removeEventListener("input", this._listeners.onInput, false);
                this._huiComponent.removeEventListener("component-upgraded", this._listeners.componentUpgraded, false); // clean up component-upgraded listener
                this._listeners = {};
                this._huiMethodsCalled = [];
            }
        }, {
            key: "addHUIMethods",
            value: function addHUIMethods() {
                if (this.props.showCalendar) {
                    this._huiComponent.showCalendar();
                }

                if (this.props.closeCalendar) {
                    this._huiComponent.closeCalendar();
                }

                if (this.props.format) {
                    this._huiComponent.format(new Date(this.props.value), this.props.format);
                }

                if (this.props.showNextMonth) {
                    if (!this._huiMethodsCalled.showNextMonth) {
                        //showNextMonth should be called only once
                        this._huiComponent.showNextMonth();
                        this._huiMethodsCalled.showNextMonth = true;
                    }
                }

                if (this.props.showPreviousMonth) {
                    //showPreviousMonth should be called only once
                    if (!this._huiMethodsCalled.showPreviousMonth) {
                        this._huiComponent.showPreviousMonth();
                        this._huiMethodsCalled.showPreviousMonth = true;
                    }
                }

                if (this.props.preselect) {
                    this._huiComponent.preselect(this.props.preselect);
                }

                if (this.props.postselect) {
                    this._huiComponent.postselect(this.props.postselect);
                }

                if (this.props.alwaysRenderValidity) {
                    this._huiComponent.reportValidity();
                }
            }
        }, {
            key: "_testValidity",
            value: function _testValidity() {
                if (this.props.onValidityChange) {
                    var valid = undefined;
                    if (this._huiComponent.checkValidity) {
                        valid = this._huiComponent.checkValidity();
                    }
                    if (this._lastValidity !== valid) {
                        this._lastValidity = valid;
                        this.props.onValidityChange(valid);
                    }
                }
            }
        }, {
            key: "render",
            value: function render() {
                /* jshint ignore:start */
                return _react2.default.createElement("ha-date-picker", _extends({
                    ref: this.handleRef,
                    "class": this.state.classAttributes
                }, this.props));
                /* jshint ignore:end */
            }
        }]);

        return HADatePicker;
    }(_react2.default.Component);

    HADatePicker.propTypes = {
        className: _react2.default.PropTypes.string,
        id: _react2.default.PropTypes.string,
        disabled: _react2.default.PropTypes.bool,
        label: _react2.default.PropTypes.string,
        labelOptional: _react2.default.PropTypes.string,
        monthLabels: _react2.default.PropTypes.array,
        monthAbbreviations: _react2.default.PropTypes.array,
        dayOfWeekLabels: _react2.default.PropTypes.array,
        showYearNavigation: _react2.default.PropTypes.bool,
        tooltips: _react2.default.PropTypes.object,
        blackoutDates: _react2.default.PropTypes.array,
        notableDates: _react2.default.PropTypes.array,
        useDoubleCalendar: _react2.default.PropTypes.bool,
        navigationAriaDescription: _react2.default.PropTypes.string,
        dateFormatter: _react2.default.PropTypes.func,
        dateFormat: _react2.default.PropTypes.string,
        datePattern: _react2.default.PropTypes.string,
        name: _react2.default.PropTypes.string,
        icon: _react2.default.PropTypes.string,
        maxLength: _react2.default.PropTypes.number,
        minLength: _react2.default.PropTypes.number,
        optional: _react2.default.PropTypes.bool,
        placeholder: _react2.default.PropTypes.string,
        pattern: _react2.default.PropTypes.string,
        size: _react2.default.PropTypes.number,
        value: _react2.default.PropTypes.string,
        autoComplete: _react2.default.PropTypes.string,
        required: _react2.default.PropTypes.bool,
        noRequiredIndicator: _react2.default.PropTypes.bool,
        min: _react2.default.PropTypes.number,
        max: _react2.default.PropTypes.number,
        requiredMessage: _react2.default.PropTypes.string,
        invalidMessage: _react2.default.PropTypes.string,
        validator: _react2.default.PropTypes.func,
        onValidityChange: _react2.default.PropTypes.func,
        alwaysRenderValidity: _react2.default.PropTypes.bool,
        onInput: _react2.default.PropTypes.func,
        onChange: _react2.default.PropTypes.func
    };
    exports.default = HADatePicker;
});
//# sourceMappingURL=HADatePicker.js.map
;
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define('hui-react/HAPortal',['exports', 'react', 'react-dom', 'hui/core/position'], factory);
  } else if (typeof exports !== "undefined") {
    factory(exports, require('react'), require('react-dom'), require('hui/core/position'));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod.exports, global.react, global.reactDom, global.position);
    global.HAPortal = mod.exports;
  }
})(this, function (exports, _react, _reactDom, _position) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _react2 = _interopRequireDefault(_react);

  var _reactDom2 = _interopRequireDefault(_reactDom);

  var _position2 = _interopRequireDefault(_position);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && ((typeof call === 'undefined' ? 'undefined' : _typeof(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var shallowCompare = _react2.default.addons.shallowCompare;
  var underlayZIndex = [];

  var Portal = function (_React$Component) {
    _inherits(Portal, _React$Component);

    function Portal() {
      _classCallCheck(this, Portal);

      var _this = _possibleConstructorReturn(this, (Portal.__proto__ || Object.getPrototypeOf(Portal)).call(this));

      _this.potral = null;
      _this.container = null;
      return _this;
    }

    _createClass(Portal, [{
      key: 'componentDidMount',
      value: function componentDidMount() {
        this.potral = document.createElement('div');
        document.body.appendChild(this.potral);
        // use unstable_renderSubtreeIntoContainer to pass relay context
        this.container = _reactDom2.default.unstable_renderSubtreeIntoContainer(this, this.props.children, this.potral);
      }
    }, {
      key: 'componentWillUpdate',
      value: function componentWillUpdate(nextProps) {
        if (nextProps.show) {
          // use unstable_renderSubtreeIntoContainer to pass relay context
          this.container = _reactDom2.default.unstable_renderSubtreeIntoContainer(this, nextProps.children, this.potral);

          // if the container does not have a z-index we need to calculate one for it
          // this can happen if it's a new container, or a container we hid that has not been unmounted yet
          // if a drawer does not have a background, noUnderlay is true and we do not have to modify the underlay
          if (!this.container.style.zIndex && !this.props.noUnderlay) {
            // underlay must get moved first to it's z-index is less than the container's
            this.moveUnderlay(_position2.default.getTopZindex());
          }
          if (!this.container.style.zIndex) {
            this.container.style.zIndex = _position2.default.getTopZindex();
          }
        } else if (nextProps.show === false && this.container && this.container.style.zIndex) {
          // move underlay (or remove it)
          this.removeUnderlay();

          // remove z-index so we can determine new z-index if we show it again before unmounting it
          this.container.style.zIndex = null;
        }
      }
    }, {
      key: 'shouldComponentUpdate',
      value: function shouldComponentUpdate(nextProps, nextState) {
        return shallowCompare(this, nextProps, nextState);
      }
    }, {
      key: 'componentWillUnmount',
      value: function componentWillUnmount() {
        // even if show prop hasn't been updated - still clean up underlay
        this.removeUnderlay();

        if (this.potral) {
          _reactDom2.default.unmountComponentAtNode(this.potral);
          document.body.removeChild(this.potral);
        }
        this.potral = null;
        this.container = null;
      }
    }, {
      key: 'removeUnderlay',
      value: function removeUnderlay() {
        // if a drawer doesn't have a background, noUnderlay is true and we don't have to modify the underlay
        if (!this.props.noUnderlay) {
          var underlay = document.body.querySelector(".ha-underlay");

          // if there are multiple layers, pop the top one and move the underlay down a layer.
          // else there aren't any more layers so just remove underlay from the DOM
          if (underlayZIndex.pop() && underlayZIndex.length) {
            underlay.style.zIndex = underlayZIndex[underlayZIndex.length - 1];
          } else if (underlay) {
            document.body.removeChild(underlay);
          }
        }
      }
    }, {
      key: 'moveUnderlay',
      value: function moveUnderlay(zIndex) {
        var underlay = document.body.querySelector(".ha-underlay");

        // if there is no underlay div, create one and append to the body
        if (!underlay) {
          underlay = document.createElement('div');
          underlay.classList.add('ha-underlay');
          underlay.tabIndex = -1;
          document.body.appendChild(underlay);
        }
        underlay.style.zIndex = zIndex;
        underlayZIndex.push(zIndex);
      }
    }, {
      key: 'render',
      value: function render() {
        return null;
      }
    }]);

    return Portal;
  }(_react2.default.Component);

  Portal.propTypes = {
    children: _react2.default.PropTypes.element.isRequired
  };
  exports.default = Portal;
});
//# sourceMappingURL=HAPortal.js.map
;
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

(function (global, factory) {
    if (typeof define === "function" && define.amd) {
        define('hui-react/HADrawerLarge',["exports", "react", "./HAPortal", "./HASection", "./HAFooter", "hui/core/utils", "hui/drawer-large"], factory);
    } else if (typeof exports !== "undefined") {
        factory(exports, require("react"), require("./HAPortal"), require("./HASection"), require("./HAFooter"), require("hui/core/utils"), require("hui/drawer-large"));
    } else {
        var mod = {
            exports: {}
        };
        factory(mod.exports, global.react, global.HAPortal, global.HASection, global.HAFooter, global.utils, global.drawerLarge);
        global.HADrawerLarge = mod.exports;
    }
})(this, function (exports, _react, _HAPortal, _HASection, _HAFooter, _utils) {
    "use strict";

    Object.defineProperty(exports, "__esModule", {
        value: true
    });

    var _react2 = _interopRequireDefault(_react);

    var _HAPortal2 = _interopRequireDefault(_HAPortal);

    var _HASection2 = _interopRequireDefault(_HASection);

    var _HAFooter2 = _interopRequireDefault(_HAFooter);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }

    var _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];

            for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }

        return target;
    };

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }

    var _createClass = function () {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }

        return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();

    function _possibleConstructorReturn(self, call) {
        if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
    }

    function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }

    var HADrawerLarge = function (_React$Component) {
        _inherits(HADrawerLarge, _React$Component);

        function HADrawerLarge(props) {
            _classCallCheck(this, HADrawerLarge);

            var _this = _possibleConstructorReturn(this, (HADrawerLarge.__proto__ || Object.getPrototypeOf(HADrawerLarge)).call(this, props));

            _initialiseProps.call(_this);

            _this._drawerLarge = null; // drawerLarge DOM reference, set after render()
            _this._listeners = {};
            _this.compId = "";
            return _this;
        }

        // check that the only children passed to this component are a HASection, or HAFooter

        _createClass(HADrawerLarge, [{
            key: "componentDidMount",
            value: function componentDidMount() {
                var _this2 = this;

                if (this._drawerLarge) {
                    this.removeWebRenderComp();
                    this.setState(function () {
                        _this2.compId = _this2._drawerLarge.componentId;
                    });
                }
                this.mountDrawerLarge();
            }
        }, {
            key: "componentDidUpdate",
            value: function componentDidUpdate(prevProps) {
                this.mountDrawerLarge(prevProps);
            }
        }, {
            key: "mountDrawerLarge",
            value: function mountDrawerLarge() {
                var _this3 = this;

                var prevProps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

                // if we have added the drawer to the dom and we are changing show state
                if (this._drawerLarge && this.props.show !== prevProps.show) {
                    if (this.props.show) {
                        this.setupListeners();
                        if (this._drawerLarge.show) {
                            this._drawerLarge.show();
                        } else {
                            // on browsers that doesn't support custom elements natively,
                            // the component is not upgraded yet so show is not available, wait for event
                            var componentUpgraded = function componentUpgraded(event) {
                                event.stopPropagation();
                                _this3._drawerLarge.show();
                            };
                            this._listeners.componentUpgraded = componentUpgraded.bind(this);
                            this._drawerLarge.addEventListener("component-upgraded", this._listeners.componentUpgraded);
                        }
                    } else if (prevProps.show) {
                        this._drawerLarge.close(); // remove drawer-large from DOM using hui/drawer-large
                    }
                }
            }
        }, {
            key: "removeWebRenderComp",
            value: function removeWebRenderComp() {
                var asideChild = this._drawerLarge.querySelectorAll('aside');
                if (asideChild && asideChild.length > 1) {
                    this._drawerLarge.removeChild(asideChild[0]);
                }
            }
        }, {
            key: "setupListeners",
            value: function setupListeners() {
                var _this4 = this;

                if (Object.keys(this._listeners).length === 0) {
                    var onShow = function onShow(event) {
                        event.stopPropagation();
                        if (_this4.props.onShow) {
                            _this4.props.onShow(event);
                        }
                    };
                    this._listeners.onShow = onShow.bind(this);
                    this._drawerLarge.addEventListener("show", this._listeners.onShow);

                    var onClose = function onClose(event) {
                        event.stopPropagation();
                        if (_this4.props.onClose) {
                            _this4.props.onClose(event);
                        }
                        _this4.cleanUpListeners();
                    };
                    this._listeners.onClose = onClose.bind(this);
                    this._drawerLarge.addEventListener("close", this._listeners.onClose);

                    var onDismiss = function onDismiss(event) {
                        event.stopPropagation();
                        if (_this4.props.onDismiss) {
                            _this4.props.onDismiss(event);
                        }
                        // onDismiss emits a onClose so listener cleanup is handled there
                    };
                    this._listeners.onDismiss = onDismiss.bind(this);
                    this._drawerLarge.addEventListener("dismiss", this._listeners.onDismiss);
                }
            }
        }, {
            key: "componentWillUnmount",
            value: function componentWillUnmount() {
                // we might need a unmountPortal here depending on how applications handle dom rendering & routing
                this.cleanUpListeners();
            }
        }, {
            key: "cleanUpListeners",
            value: function cleanUpListeners() {
                // if we do not have a _drawerLarge then HAUnderlay destroys the event listeners
                if (this._drawerLarge) {
                    this._drawerLarge.removeEventListener("show", this._listeners.onShow, false); // clean up show listener
                    this._drawerLarge.removeEventListener("close", this._listeners.onClose, false); // clean up close listener
                    this._drawerLarge.removeEventListener("dismiss", this._listeners.onDismiss, false); // clean up dismiss listener
                }
                this._listeners = {};
            }
        }, {
            key: "render",
            value: function render() {
                var _this5 = this;

                return _react2.default.createElement(
                    _HAPortal2.default,
                    { show: this.props.show, noUnderlay: !this.props.backdrop },
                    _react2.default.createElement(
                        "ha-drawer-large",
                        _extends({
                            ref: this.handleRef,
                            "class": this.props.className,
                            reactLayering: true
                        }, this.props),
                        _react2.default.createElement(
                            "aside",
                            { className: "drawer-panel", "aria-labelledby": "drawer-large-title-" + this.compId, tabIndex: "-1" },
                            _react2.default.createElement(
                                "header",
                                { className: "header" },
                                _react2.default.createElement(
                                    "button",
                                    { className: "drawer-close first-focus", "aria-label": "close" },
                                    _react2.default.createElement("span", { className: "hi hi-close" })
                                )
                            ),
                            _react2.default.Children.map(this.props.children, function (child) {
                                if (child.type === _HASection2.default) {
                                    return _react2.default.createElement(
                                        "section",
                                        { key: "1", className: "content", tabIndex: "-1" },
                                        _react2.default.createElement(
                                            "h3",
                                            { id: "drawer-large-title-" + _this5.compId },
                                            _this5.props.titleText
                                        ),
                                        _react2.default.createElement(
                                            "div",
                                            { className: "inner-content" },
                                            child
                                        )
                                    );
                                } else if (child.type === _HAFooter2.default) {
                                    return _react2.default.createElement(
                                        "footer",
                                        { key: "2", className: "footer", tabIndex: "-1" },
                                        child
                                    );
                                }
                            })
                        )
                    )
                );
            }
        }]);

        return HADrawerLarge;
    }(_react2.default.Component);

    HADrawerLarge.propTypes = {
        children: function children(props, propName, componentName) {
            var error = (0, _utils.checkReactChildrenType)(props[propName], componentName, [_HASection2.default, _HAFooter2.default], "HASection,HAFooter");
            if (error) {
                return error;
            }
        },
        className: _react2.default.PropTypes.string,
        show: _react2.default.PropTypes.bool.isRequired,
        titleText: _react2.default.PropTypes.string,
        onShow: _react2.default.PropTypes.func,
        onClose: _react2.default.PropTypes.func,
        noCloseOnDismiss: _react2.default.PropTypes.bool,
        onDismiss: _react2.default.PropTypes.func
    };

    var _initialiseProps = function _initialiseProps() {
        var _this6 = this;

        this.handleRef = function (c) {
            _this6._drawerLarge = c;
        };
    };

    exports.default = HADrawerLarge;
});
//# sourceMappingURL=HADrawerLarge.js.map
;
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

(function (global, factory) {
    if (typeof define === "function" && define.amd) {
        define('hui-react/HAFlowConfirmation',["exports", "react", "hui/step-flow/flow-confirmation"], factory);
    } else if (typeof exports !== "undefined") {
        factory(exports, require("react"), require("hui/step-flow/flow-confirmation"));
    } else {
        var mod = {
            exports: {}
        };
        factory(mod.exports, global.react, global.flowConfirmation);
        global.HAFlowConfirmation = mod.exports;
    }
})(this, function (exports, _react) {
    "use strict";

    Object.defineProperty(exports, "__esModule", {
        value: true
    });

    var _react2 = _interopRequireDefault(_react);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }

    var _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];

            for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }

        return target;
    };

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }

    var _createClass = function () {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }

        return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();

    function _possibleConstructorReturn(self, call) {
        if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
    }

    function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }

    var HAFlowConfirmation = function (_React$Component) {
        _inherits(HAFlowConfirmation, _React$Component);

        function HAFlowConfirmation(props) {
            _classCallCheck(this, HAFlowConfirmation);

            return _possibleConstructorReturn(this, (HAFlowConfirmation.__proto__ || Object.getPrototypeOf(HAFlowConfirmation)).call(this, props));
        }

        _createClass(HAFlowConfirmation, [{
            key: "render",
            value: function render() {
                /* jshint ignore:start */
                return _react2.default.createElement(
                    "ha-flow-confirmation",
                    _extends({ "class": this.props.className }, this.props),
                    this.props.children
                );
                /* jshint ignore:end */
            }
        }]);

        return HAFlowConfirmation;
    }(_react2.default.Component);

    HAFlowConfirmation.propTypes = {
        className: _react2.default.PropTypes.string,
        titleText: _react2.default.PropTypes.string,
        subtitleText: _react2.default.PropTypes.string
    };
    exports.default = HAFlowConfirmation;
});
//# sourceMappingURL=HAFlowConfirmation.js.map
;
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

(function (global, factory) {
    if (typeof define === "function" && define.amd) {
        define('hui-react/HAFlowLanding',["exports", "react", "hui/step-flow/flow-landing"], factory);
    } else if (typeof exports !== "undefined") {
        factory(exports, require("react"), require("hui/step-flow/flow-landing"));
    } else {
        var mod = {
            exports: {}
        };
        factory(mod.exports, global.react, global.flowLanding);
        global.HAFlowLanding = mod.exports;
    }
})(this, function (exports, _react) {
    "use strict";

    Object.defineProperty(exports, "__esModule", {
        value: true
    });

    var _react2 = _interopRequireDefault(_react);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }

    var _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];

            for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }

        return target;
    };

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }

    var _createClass = function () {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }

        return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();

    function _possibleConstructorReturn(self, call) {
        if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
    }

    function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }

    var HAFlowLanding = function (_React$Component) {
        _inherits(HAFlowLanding, _React$Component);

        function HAFlowLanding(props) {
            _classCallCheck(this, HAFlowLanding);

            return _possibleConstructorReturn(this, (HAFlowLanding.__proto__ || Object.getPrototypeOf(HAFlowLanding)).call(this, props));
        }

        _createClass(HAFlowLanding, [{
            key: "render",
            value: function render() {
                /* jshint ignore:start */
                return _react2.default.createElement(
                    "ha-flow-landing",
                    _extends({ "class": this.props.className }, this.props),
                    this.props.children
                );
                /* jshint ignore:end */
            }
        }]);

        return HAFlowLanding;
    }(_react2.default.Component);

    HAFlowLanding.propTypes = {
        className: _react2.default.PropTypes.string
    };
    exports.default = HAFlowLanding;
});
//# sourceMappingURL=HAFlowLanding.js.map
;
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

(function (global, factory) {
    if (typeof define === "function" && define.amd) {
        define('hui-react/HAFlowStep',["exports", "react", "hui/core/utils", "hui/step-flow/flow-step"], factory);
    } else if (typeof exports !== "undefined") {
        factory(exports, require("react"), require("hui/core/utils"), require("hui/step-flow/flow-step"));
    } else {
        var mod = {
            exports: {}
        };
        factory(mod.exports, global.react, global.utils, global.flowStep);
        global.HAFlowStep = mod.exports;
    }
})(this, function (exports, _react, _utils) {
    "use strict";

    Object.defineProperty(exports, "__esModule", {
        value: true
    });

    var _react2 = _interopRequireDefault(_react);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }

    var _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];

            for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }

        return target;
    };

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }

    var _createClass = function () {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }

        return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();

    function _possibleConstructorReturn(self, call) {
        if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
    }

    function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }

    var HAFlowStep = function (_React$Component) {
        _inherits(HAFlowStep, _React$Component);

        function HAFlowStep(props) {
            _classCallCheck(this, HAFlowStep);

            var _this = _possibleConstructorReturn(this, (HAFlowStep.__proto__ || Object.getPrototypeOf(HAFlowStep)).call(this, props));

            _this.handleRef = function (c) {
                _this._huiComponent = c;
            };

            _this._huiComponent = null;
            _this.state = {
                classAttributes: null
            };
            return _this;
        }

        _createClass(HAFlowStep, [{
            key: "componentDidMount",
            value: function componentDidMount() {
                this.setHuiProperties();
                this.updateSection();

                // merge pre-existing custom element classes with props
                if (this.props.className) {
                    this.updateElementClasses();
                }
            }
        }, {
            key: "componentDidUpdate",
            value: function componentDidUpdate(prevProps) {
                this.setHuiProperties(prevProps);
            }
        }, {
            key: "updateSection",
            value: function updateSection() {
                var flowSection = undefined;
                if (this._huiComponent) {
                    flowSection = this._huiComponent.querySelectorAll('section');
                }
                if (flowSection && flowSection.length > 1) {
                    var children = Array.prototype.slice.call(flowSection[1].childNodes);
                    children.forEach(function (child) {
                        flowSection[0].appendChild(child);
                    });
                    this._huiComponent.removeChild(flowSection[1]);
                }
            }
        }, {
            key: "setHuiProperties",
            value: function setHuiProperties() {
                var prevProps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

                if (this.props.validator) {
                    this._huiComponent.validator = this.props.validator;
                }
                if (this.props.beforeShowPromise) {
                    this._huiComponent.beforeShowPromise = this.props.beforeShowPromise;
                }
            }
        }, {
            key: "updateElementClasses",
            value: function updateElementClasses() {
                var mergedClassString = (0, _utils.updateClassWithProps)(this._huiComponent, this.props.className);
                if (mergedClassString) {
                    this.setState({
                        classAttributes: mergedClassString
                    });
                }
            }
        }, {
            key: "componentWillReceiveProps",
            value: function componentWillReceiveProps(nextProps) {
                // confirm that H-UI supported classes aren't erased on a props change
                var existingClasses = this.state.classAttributes;
                if (existingClasses !== nextProps.className) {
                    this.updateElementClasses();
                }
            }
        }, {
            key: "render",
            value: function render() {
                /* jshint ignore:start */
                return _react2.default.createElement(
                    "ha-flow-step",
                    _extends({
                        ref: this.handleRef,
                        "class": this.state.classAttributes
                    }, this.props),
                    this.props.children
                );
                /* jshint ignore:end */
            }
        }]);

        return HAFlowStep;
    }(_react2.default.Component);

    HAFlowStep.propTypes = {
        className: _react2.default.PropTypes.string,
        id: _react2.default.PropTypes.string,
        stepId: _react2.default.PropTypes.string,
        showSaveForLaterButton: _react2.default.PropTypes.bool,
        saveForLaterButtonText: _react2.default.PropTypes.string,
        nextButtonText: _react2.default.PropTypes.string,
        previousButtonText: _react2.default.PropTypes.string,
        titleText: _react2.default.PropTypes.string,
        subtitleText: _react2.default.PropTypes.string,
        progressIndicatorText: _react2.default.PropTypes.string,
        stepComplete: _react2.default.PropTypes.bool,
        stepAvailable: _react2.default.PropTypes.bool,
        hideProgressIndicator: _react2.default.PropTypes.bool,
        hideProgressIndicatorItem: _react2.default.PropTypes.bool,
        hideStepButtons: _react2.default.PropTypes.bool,
        useCustomButtons: _react2.default.PropTypes.bool,
        content: _react2.default.PropTypes.object,
        validator: _react2.default.PropTypes.func,
        beforeShowPromise: _react2.default.PropTypes.func
    };
    exports.default = HAFlowStep;
});
//# sourceMappingURL=HAFlowStep.js.map
;
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

(function (global, factory) {
    if (typeof define === "function" && define.amd) {
        define('hui-react/HAFooterCenter',["exports", "react"], factory);
    } else if (typeof exports !== "undefined") {
        factory(exports, require("react"));
    } else {
        var mod = {
            exports: {}
        };
        factory(mod.exports, global.react);
        global.HAFooterCenter = mod.exports;
    }
})(this, function (exports, _react) {
    "use strict";

    Object.defineProperty(exports, "__esModule", {
        value: true
    });

    var _react2 = _interopRequireDefault(_react);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }

    var _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];

            for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }

        return target;
    };

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }

    var _createClass = function () {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }

        return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();

    function _possibleConstructorReturn(self, call) {
        if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
    }

    function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }

    var FooterCenter = function (_React$Component) {
        _inherits(FooterCenter, _React$Component);

        function FooterCenter(props) {
            _classCallCheck(this, FooterCenter);

            return _possibleConstructorReturn(this, (FooterCenter.__proto__ || Object.getPrototypeOf(FooterCenter)).call(this, props));
        }

        _createClass(FooterCenter, [{
            key: "render",
            value: function render() {
                /* jshint ignore:start */
                return _react2.default.createElement(
                    "span",
                    _extends({ className: "footer-center" }, this.props),
                    this.props.children
                );
                /* jshint ignore:end */
            }
        }]);

        return FooterCenter;
    }(_react2.default.Component);

    exports.default = FooterCenter;
});
//# sourceMappingURL=HAFooterCenter.js.map
;
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

(function (global, factory) {
    if (typeof define === "function" && define.amd) {
        define('hui-react/HAFooterLeft',["exports", "react"], factory);
    } else if (typeof exports !== "undefined") {
        factory(exports, require("react"));
    } else {
        var mod = {
            exports: {}
        };
        factory(mod.exports, global.react);
        global.HAFooterLeft = mod.exports;
    }
})(this, function (exports, _react) {
    "use strict";

    Object.defineProperty(exports, "__esModule", {
        value: true
    });

    var _react2 = _interopRequireDefault(_react);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }

    var _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];

            for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }

        return target;
    };

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }

    var _createClass = function () {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }

        return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();

    function _possibleConstructorReturn(self, call) {
        if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
    }

    function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }

    var FooterLeft = function (_React$Component) {
        _inherits(FooterLeft, _React$Component);

        function FooterLeft(props) {
            _classCallCheck(this, FooterLeft);

            return _possibleConstructorReturn(this, (FooterLeft.__proto__ || Object.getPrototypeOf(FooterLeft)).call(this, props));
        }

        _createClass(FooterLeft, [{
            key: "render",
            value: function render() {
                /* jshint ignore:start */
                return _react2.default.createElement(
                    "span",
                    _extends({ className: "footer-left" }, this.props),
                    this.props.children
                );
                /* jshint ignore:end */
            }
        }]);

        return FooterLeft;
    }(_react2.default.Component);

    exports.default = FooterLeft;
});
//# sourceMappingURL=HAFooterLeft.js.map
;
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

(function (global, factory) {
    if (typeof define === "function" && define.amd) {
        define('hui-react/HAFooterRight',["exports", "react"], factory);
    } else if (typeof exports !== "undefined") {
        factory(exports, require("react"));
    } else {
        var mod = {
            exports: {}
        };
        factory(mod.exports, global.react);
        global.HAFooterRight = mod.exports;
    }
})(this, function (exports, _react) {
    "use strict";

    Object.defineProperty(exports, "__esModule", {
        value: true
    });

    var _react2 = _interopRequireDefault(_react);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }

    var _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];

            for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }

        return target;
    };

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }

    var _createClass = function () {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }

        return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();

    function _possibleConstructorReturn(self, call) {
        if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
    }

    function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }

    var FooterRight = function (_React$Component) {
        _inherits(FooterRight, _React$Component);

        function FooterRight(props) {
            _classCallCheck(this, FooterRight);

            return _possibleConstructorReturn(this, (FooterRight.__proto__ || Object.getPrototypeOf(FooterRight)).call(this, props));
        }

        _createClass(FooterRight, [{
            key: "render",
            value: function render() {
                /* jshint ignore:start */
                return _react2.default.createElement(
                    "span",
                    _extends({ className: "footer-right" }, this.props),
                    this.props.children
                );
                /* jshint ignore:end */
            }
        }]);

        return FooterRight;
    }(_react2.default.Component);

    exports.default = FooterRight;
});
//# sourceMappingURL=HAFooterRight.js.map
;
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

(function (global, factory) {
    if (typeof define === "function" && define.amd) {
        define('hui-react/HAHeader',["exports", "react", "react-dom"], factory);
    } else if (typeof exports !== "undefined") {
        factory(exports, require("react"), require("react-dom"));
    } else {
        var mod = {
            exports: {}
        };
        factory(mod.exports, global.react, global.reactDom);
        global.HAHeader = mod.exports;
    }
})(this, function (exports, _react, _reactDom) {
    "use strict";

    Object.defineProperty(exports, "__esModule", {
        value: true
    });

    var _react2 = _interopRequireDefault(_react);

    var _reactDom2 = _interopRequireDefault(_reactDom);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }

    var _createClass = function () {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }

        return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();

    function _possibleConstructorReturn(self, call) {
        if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
    }

    function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }

    var HAHeader = function (_React$Component) {
        _inherits(HAHeader, _React$Component);

        function HAHeader(props) {
            _classCallCheck(this, HAHeader);

            return _possibleConstructorReturn(this, (HAHeader.__proto__ || Object.getPrototypeOf(HAHeader)).call(this, props));
        }

        _createClass(HAHeader, [{
            key: "render",
            value: function render() {
                /* jshint ignore:start */
                return _react2.default.createElement(
                    "header",
                    this.props,
                    this.props.children
                );
                /* jshint ignore:end */
            }
        }]);

        return HAHeader;
    }(_react2.default.Component);

    exports.default = HAHeader;
});
//# sourceMappingURL=HAHeader.js.map
;
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

(function (global, factory) {
    if (typeof define === "function" && define.amd) {
        define('hui-react/HAMessage',["exports", "react", "hui/message"], factory);
    } else if (typeof exports !== "undefined") {
        factory(exports, require("react"), require("hui/message"));
    } else {
        var mod = {
            exports: {}
        };
        factory(mod.exports, global.react, global.message);
        global.HAMessage = mod.exports;
    }
})(this, function (exports, _react) {
    "use strict";

    Object.defineProperty(exports, "__esModule", {
        value: true
    });

    var _react2 = _interopRequireDefault(_react);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }

    var _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];

            for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }

        return target;
    };

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }

    var _createClass = function () {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }

        return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();

    function _possibleConstructorReturn(self, call) {
        if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
    }

    function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }

    var HAMessage = function (_React$Component) {
        _inherits(HAMessage, _React$Component);

        function HAMessage(props) {
            _classCallCheck(this, HAMessage);

            return _possibleConstructorReturn(this, (HAMessage.__proto__ || Object.getPrototypeOf(HAMessage)).call(this, props));
        }

        _createClass(HAMessage, [{
            key: "render",
            value: function render() {
                /* jshint ignore:start */
                return _react2.default.createElement(
                    "ha-message",
                    _extends({ "class": this.props.className }, this.props),
                    this.props.children
                );
                /* jshint ignore:end */
            }
        }]);

        return HAMessage;
    }(_react2.default.Component);

    HAMessage.propTypes = {
        className: _react2.default.PropTypes.string
    };
    exports.default = HAMessage;
});
//# sourceMappingURL=HAMessage.js.map
;
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

(function (global, factory) {
    if (typeof define === "function" && define.amd) {
        define('hui-react/HAText',["exports", "react", "hui/text"], factory);
    } else if (typeof exports !== "undefined") {
        factory(exports, require("react"), require("hui/text"));
    } else {
        var mod = {
            exports: {}
        };
        factory(mod.exports, global.react, global.text);
        global.HAText = mod.exports;
    }
})(this, function (exports, _react) {
    "use strict";

    Object.defineProperty(exports, "__esModule", {
        value: true
    });

    var _react2 = _interopRequireDefault(_react);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }

    var _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];

            for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }

        return target;
    };

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }

    var _createClass = function () {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }

        return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();

    function _possibleConstructorReturn(self, call) {
        if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
    }

    function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }

    var HAText = function (_React$Component) {
        _inherits(HAText, _React$Component);

        function HAText(props) {
            _classCallCheck(this, HAText);

            return _possibleConstructorReturn(this, (HAText.__proto__ || Object.getPrototypeOf(HAText)).call(this, props));
        }

        _createClass(HAText, [{
            key: "render",
            value: function render() {
                /* jshint ignore:start */
                return _react2.default.createElement(
                    "ha-text",
                    _extends({ "class": this.props.className }, this.props),
                    this.props.children
                );
                /* jshint ignore:end */
            }
        }]);

        return HAText;
    }(_react2.default.Component);

    HAText.propTypes = {
        className: _react2.default.PropTypes.string
    };
    exports.default = HAText;
});
//# sourceMappingURL=HAText.js.map
;
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

(function (global, factory) {
    if (typeof define === "function" && define.amd) {
        define('hui-react/HAInfoLink',["exports", "react", "./HAMessage", "./HAText", "hui/core/utils", "hui/info-link"], factory);
    } else if (typeof exports !== "undefined") {
        factory(exports, require("react"), require("./HAMessage"), require("./HAText"), require("hui/core/utils"), require("hui/info-link"));
    } else {
        var mod = {
            exports: {}
        };
        factory(mod.exports, global.react, global.HAMessage, global.HAText, global.utils, global.infoLink);
        global.HAInfoLink = mod.exports;
    }
})(this, function (exports, _react, _HAMessage, _HAText, _utils) {
    "use strict";

    Object.defineProperty(exports, "__esModule", {
        value: true
    });

    var _react2 = _interopRequireDefault(_react);

    var _HAMessage2 = _interopRequireDefault(_HAMessage);

    var _HAText2 = _interopRequireDefault(_HAText);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }

    var _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];

            for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }

        return target;
    };

    function _objectWithoutProperties(obj, keys) {
        var target = {};

        for (var i in obj) {
            if (keys.indexOf(i) >= 0) continue;
            if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
            target[i] = obj[i];
        }

        return target;
    }

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }

    var _createClass = function () {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }

        return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();

    function _possibleConstructorReturn(self, call) {
        if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
    }

    function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }

    var HAInfoLink = function (_React$Component) {
        _inherits(HAInfoLink, _React$Component);

        function HAInfoLink(props) {
            _classCallCheck(this, HAInfoLink);

            var _this = _possibleConstructorReturn(this, (HAInfoLink.__proto__ || Object.getPrototypeOf(HAInfoLink)).call(this, props));

            _initialiseProps.call(_this);

            _this._huiComponent = null;
            _this._listeners = {};
            return _this;
        }

        _createClass(HAInfoLink, [{
            key: "componentDidMount",
            value: function componentDidMount() {
                var _this2 = this;

                // Update react components to the web component
                this.updateReactComponent();

                // With es6 syntax we have to bind the events to the react component instance
                // https://facebook.github.io/react/docs/reusable-components.html#no-autobinding
                // Event handler for click
                var onClick = function onClick(event) {
                    event.stopPropagation();
                    if (_this2.props.onClick) {
                        _this2.props.onClick(event);
                    }
                };
                this._listeners.onClick = onClick.bind(this);
                this._huiComponent.addEventListener("click", this._listeners.onClick);

                // Event handler for close
                var onClose = function onClose(event) {
                    event.stopPropagation();
                    if (_this2.props.onClose) {
                        _this2.props.onClose(event);
                    }
                };
                this._listeners.onClose = onClose.bind(this);
                this._huiComponent.addEventListener("close", this._listeners.onClose);

                // Event handler for dismiss
                var onDismiss = function onDismiss(event) {
                    event.stopPropagation();
                    if (_this2.props.onDismiss) {
                        _this2.props.onDismiss(event);
                    }
                };
                this._listeners.onDismiss = onDismiss.bind(this);
                this._huiComponent.addEventListener("dismiss", this._listeners.onDismiss);

                // Event handler for show
                var onShow = function onShow(event) {
                    event.stopPropagation();
                    if (_this2.props.onShow) {
                        _this2.props.onShow(event);
                    }
                };
                this._listeners.onShow = onShow.bind(this);
                this._huiComponent.addEventListener("show", this._listeners.onShow);
            }
        }, {
            key: "componentWillUnmount",
            value: function componentWillUnmount() {
                this._huiComponent.removeEventListener("click", this._listeners.onClick, false);
                this._huiComponent.removeEventListener("close", this._listeners.onClose, false);
                this._huiComponent.removeEventListener("dismiss", this._listeners.onDismiss, false);
                this._huiComponent.removeEventListener("show", this._listeners.onShow, false);
            }
        }, {
            key: "updateReactComponent",
            value: function updateReactComponent() {
                var _this3 = this;

                if (this.props.children) {
                    _react2.default.Children.forEach(this.props.children, function (child) {
                        if (child.type === _HAText2.default) {
                            _this3._huiComponent.initializeLinkText();
                        }
                        if (child.type === _HAMessage2.default) {
                            _this3._huiComponent.initializeMessage();
                        }
                    });
                }
            }
        }, {
            key: "render",
            value: function render() {
                var _props = this.props,

                /* jshint ignore:start */
                linkText = _props.linkText,
                    otherProps = _objectWithoutProperties(_props, ["linkText"]);

                // since IE11 preserve case sensitive of attributes, so convert linkText to lowercase when declarative
                return _react2.default.createElement(
                    "ha-info-link",
                    _extends({ ref: this.handleRef, linktext: linkText }, otherProps),
                    this.props.children
                );
                /* jshint ignore:end */
            }
        }]);

        return HAInfoLink;
    }(_react2.default.Component);

    HAInfoLink.propTypes = {
        className: _react2.default.PropTypes.string,
        children: function anonymous(props, propName, componentName) {
            var error = (0, _utils.checkReactChildrenType)(props[propName], componentName, [_HAMessage2.default, _HAText2.default], "HAMessage,HAText");
            if (error) {
                return error;
            }
        },
        onClick: _react2.default.PropTypes.func,
        onClose: _react2.default.PropTypes.func,
        onDismiss: _react2.default.PropTypes.func,
        onShow: _react2.default.PropTypes.func
    };

    var _initialiseProps = function _initialiseProps() {
        var _this4 = this;

        this.handleRef = function (c) {
            _this4._huiComponent = c;
        };
    };

    exports.default = HAInfoLink;
});
//# sourceMappingURL=HAInfoLink.js.map
;
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

(function (global, factory) {
    if (typeof define === "function" && define.amd) {
        define('hui-react/HALabel',["exports", "react", "hui/label"], factory);
    } else if (typeof exports !== "undefined") {
        factory(exports, require("react"), require("hui/label"));
    } else {
        var mod = {
            exports: {}
        };
        factory(mod.exports, global.react, global.label);
        global.HALabel = mod.exports;
    }
})(this, function (exports, _react) {
    "use strict";

    Object.defineProperty(exports, "__esModule", {
        value: true
    });

    var _react2 = _interopRequireDefault(_react);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }

    var _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];

            for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }

        return target;
    };

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }

    var _createClass = function () {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }

        return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();

    function _possibleConstructorReturn(self, call) {
        if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
    }

    function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }

    var HALabel = function (_React$Component) {
        _inherits(HALabel, _React$Component);

        function HALabel(props) {
            _classCallCheck(this, HALabel);

            return _possibleConstructorReturn(this, (HALabel.__proto__ || Object.getPrototypeOf(HALabel)).call(this, props));
        }

        _createClass(HALabel, [{
            key: "render",
            value: function render() {
                /* jshint ignore:start */
                return _react2.default.createElement(
                    "ha-label",
                    _extends({ "class": this.props.className }, this.props),
                    this.props.children
                );
                /* jshint ignore:end */
            }
        }]);

        return HALabel;
    }(_react2.default.Component);

    HALabel.propTypes = {
        className: _react2.default.PropTypes.string
    };
    exports.default = HALabel;
});
//# sourceMappingURL=HALabel.js.map
;
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

(function (global, factory) {
    if (typeof define === "function" && define.amd) {
        define('hui-react/HAList',["exports", "react", "hui/simple-list"], factory);
    } else if (typeof exports !== "undefined") {
        factory(exports, require("react"), require("hui/simple-list"));
    } else {
        var mod = {
            exports: {}
        };
        factory(mod.exports, global.react, global.simpleList);
        global.HAList = mod.exports;
    }
})(this, function (exports, _react) {
    "use strict";

    Object.defineProperty(exports, "__esModule", {
        value: true
    });

    var _react2 = _interopRequireDefault(_react);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }

    var _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];

            for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }

        return target;
    };

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }

    var _createClass = function () {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }

        return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();

    function _possibleConstructorReturn(self, call) {
        if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
    }

    function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }

    var HAList = function (_React$Component) {
        _inherits(HAList, _React$Component);

        function HAList(props) {
            _classCallCheck(this, HAList);

            var _this = _possibleConstructorReturn(this, (HAList.__proto__ || Object.getPrototypeOf(HAList)).call(this, props));

            _this.handleRef = function (c) {
                _this.list = c;
            };

            _this.list = null;
            return _this;
        }

        _createClass(HAList, [{
            key: "componentDidMount",
            value: function componentDidMount() {
                var items = this.list.querySelectorAll("li");
                if (items) {
                    this.list.items = Array.prototype.slice.call(items);
                }
            }
        }, {
            key: "render",
            value: function render() {
                /* jshint ignore:start */
                return _react2.default.createElement(
                    "ha-list",
                    _extends({ ref: this.handleRef, "class": this.props.className }, this.props),
                    this.props.children
                );
                /* jshint ignore:end */
            }
        }]);

        return HAList;
    }(_react2.default.Component);

    HAList.propTypes = {
        className: _react2.default.PropTypes.string,
        titleText: _react2.default.PropTypes.string,
        selectedIndex: _react2.default.PropTypes.oneOfType([_react2.default.PropTypes.string, _react2.default.PropTypes.number]),
        complexity: _react2.default.PropTypes.string,
        size: _react2.default.PropTypes.oneOfType([_react2.default.PropTypes.string, _react2.default.PropTypes.number])
    };
    exports.default = HAList;
});
//# sourceMappingURL=HAList.js.map
;
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

(function (global, factory) {
    if (typeof define === "function" && define.amd) {
        define('hui-react/HAMenuButton',["exports", "react", "./HAItem", "hui/core/utils", "hui/menu-button"], factory);
    } else if (typeof exports !== "undefined") {
        factory(exports, require("react"), require("./HAItem"), require("hui/core/utils"), require("hui/menu-button"));
    } else {
        var mod = {
            exports: {}
        };
        factory(mod.exports, global.react, global.HAItem, global.utils, global.menuButton);
        global.HAMenuButton = mod.exports;
    }
})(this, function (exports, _react, _HAItem, _utils) {
    "use strict";

    Object.defineProperty(exports, "__esModule", {
        value: true
    });

    var _react2 = _interopRequireDefault(_react);

    var _HAItem2 = _interopRequireDefault(_HAItem);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }

    var _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];

            for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }

        return target;
    };

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }

    var _createClass = function () {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }

        return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();

    function _possibleConstructorReturn(self, call) {
        if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
    }

    function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }

    var HAMenuButton = function (_React$Component) {
        _inherits(HAMenuButton, _React$Component);

        function HAMenuButton(props) {
            _classCallCheck(this, HAMenuButton);

            var _this = _possibleConstructorReturn(this, (HAMenuButton.__proto__ || Object.getPrototypeOf(HAMenuButton)).call(this, props));

            _initialiseProps.call(_this);

            _this._huiComponent = null;
            _this._listeners = {};
            return _this;
        }

        _createClass(HAMenuButton, [{
            key: "componentDidMount",
            value: function componentDidMount() {
                var _this2 = this;

                // With es6 syntax we have to bind the events to the react component instance
                // https://facebook.github.io/react/docs/reusable-components.html#no-autobinding
                // Event handler for items-close
                var onItemsClose = function onItemsClose(event) {
                    event.stopPropagation();
                    if (_this2.props.onItemsClose) {
                        _this2.props.onItemsClose(event);
                    }
                };
                this._listeners.onItemsClose = onItemsClose.bind(this);
                this._huiComponent.addEventListener("items-close", this._listeners.onItemsClose);

                // Event handler for items-show
                var onItemsShow = function onItemsShow(event) {
                    event.stopPropagation();
                    if (_this2.props.onItemsShow) {
                        _this2.props.onItemsShow(event);
                    }
                };
                this._listeners.onItemsShow = onItemsShow.bind(this);
                this._huiComponent.addEventListener("items-show", this._listeners.onItemsShow);

                // Event handler for select
                var onSelect = function onSelect(event) {
                    event.stopPropagation();
                    if (_this2.props.onSelect) {
                        _this2.props.onSelect(event);
                    }
                };
                this._listeners.onSelect = onSelect.bind(this);
                this._huiComponent.addEventListener("select", this._listeners.onSelect);
            }
        }, {
            key: "componentWillUnmount",
            value: function componentWillUnmount() {
                this._huiComponent.removeEventListener("items-close", this._listeners.onItemsClose, false);
                this._huiComponent.removeEventListener("items-show", this._listeners.onItemsShow, false);
                this._huiComponent.removeEventListener("select", this._listeners.onSelect, false);
            }
        }, {
            key: "render",
            value: function render() {
                /* jshint ignore:start */
                return _react2.default.createElement(
                    "ha-menu-button",
                    _extends({
                        ref: this.handleRef,
                        "class": this.props.className
                    }, this.props),
                    this.props.children
                );
                /* jshint ignore:end */
            }
        }]);

        return HAMenuButton;
    }(_react2.default.Component);

    HAMenuButton.propTypes = {
        children: function anonymous(props, propName, componentName) {
            var error = (0, _utils.checkReactChildrenType)(props[propName], componentName, _HAItem2.default, "HAItem");
            if (error) {
                return error;
            }
        },
        className: _react2.default.PropTypes.string,
        label: _react2.default.PropTypes.string,
        disabled: _react2.default.PropTypes.bool,
        selectedIndex: _react2.default.PropTypes.number,
        selectedItem: _react2.default.PropTypes.object,
        items: _react2.default.PropTypes.array,
        onItemsClose: _react2.default.PropTypes.func,
        onItemsShow: _react2.default.PropTypes.func,
        onSelect: _react2.default.PropTypes.func
    };

    var _initialiseProps = function _initialiseProps() {
        var _this3 = this;

        this.handleRef = function (c) {
            _this3._huiComponent = c;
        };
    };

    exports.default = HAMenuButton;
});
//# sourceMappingURL=HAMenuButton.js.map
;
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

(function (global, factory) {
    if (typeof define === "function" && define.amd) {
        define('hui-react/HAModal',["exports", "react", "./HAPortal", "./HASection", "./HAAside", "./HAFooter", "hui/core/utils", "hui/modal"], factory);
    } else if (typeof exports !== "undefined") {
        factory(exports, require("react"), require("./HAPortal"), require("./HASection"), require("./HAAside"), require("./HAFooter"), require("hui/core/utils"), require("hui/modal"));
    } else {
        var mod = {
            exports: {}
        };
        factory(mod.exports, global.react, global.HAPortal, global.HASection, global.HAAside, global.HAFooter, global.utils, global.modal);
        global.HAModal = mod.exports;
    }
})(this, function (exports, _react, _HAPortal, _HASection, _HAAside, _HAFooter, _utils) {
    "use strict";

    Object.defineProperty(exports, "__esModule", {
        value: true
    });

    var _react2 = _interopRequireDefault(_react);

    var _HAPortal2 = _interopRequireDefault(_HAPortal);

    var _HASection2 = _interopRequireDefault(_HASection);

    var _HAAside2 = _interopRequireDefault(_HAAside);

    var _HAFooter2 = _interopRequireDefault(_HAFooter);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }

    var _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];

            for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }

        return target;
    };

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }

    var _createClass = function () {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }

        return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();

    function _possibleConstructorReturn(self, call) {
        if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
    }

    function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }

    var HAModal = function (_React$Component) {
        _inherits(HAModal, _React$Component);

        function HAModal(props) {
            _classCallCheck(this, HAModal);

            var _this = _possibleConstructorReturn(this, (HAModal.__proto__ || Object.getPrototypeOf(HAModal)).call(this, props));

            _initialiseProps.call(_this);

            _this._modal = null; // modal DOM reference, set after render()
            _this._listeners = {}; // keep track if we have set any event listeners on modal
            _this.compID = "";
            return _this;
        }

        // check that the only children passed to this component are a HASection, HAAside, or HAFooter

        _createClass(HAModal, [{
            key: "componentDidMount",
            value: function componentDidMount() {
                var _this2 = this;

                if (this._modal) {
                    this.removeWebRenderComp();
                    this.setState(function () {
                        _this2.compID = _this2._modal.componentId;
                    });
                }
                this.mountModal();
            }
        }, {
            key: "componentDidUpdate",
            value: function componentDidUpdate(prevProps) {
                this.mountModal(prevProps);
                this.removeWebRenderComp();
            }
        }, {
            key: "mountModal",
            value: function mountModal() {
                var _this3 = this;

                var prevProps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

                if (this._modal && this.props.show !== prevProps.show) {
                    if (this.props.show) {
                        this.setupListeners();
                        if (this._modal.show) {
                            this._modal.show();
                        } else {
                            // on browsers that doesn't support custom elements natively,
                            // the component is not upgraded yet so show is not available, wait for event
                            var componentUpgraded = function componentUpgraded(event) {
                                event.stopPropagation();
                                _this3._modal.show();
                            };
                            this._listeners.componentUpgraded = componentUpgraded.bind(this);
                            this._modal.addEventListener("component-upgraded", this._listeners.componentUpgraded);
                        }
                    } else if (prevProps.show) {
                        this._modal.close(); // remove modal from DOM using hui/modal
                    }
                }
            }
        }, {
            key: "removeWebRenderComp",
            value: function removeWebRenderComp() {
                var modalChild = this._modal.querySelectorAll('.modal');
                if (modalChild && modalChild.length > 1) {
                    this._modal.removeChild(modalChild[0]);
                } else {
                    // on Safari mobile, updated compID state hasn't been set
                    // before component's type change callback fires - this fixes dupe header
                    var modalTitles = this._modal.querySelectorAll(".modal-title h2");
                    if (modalTitles && modalTitles.length > 1) {
                        modalTitles[0].parentElement.removeChild(modalTitles[0]);
                    }
                }
            }
        }, {
            key: "setupListeners",
            value: function setupListeners() {
                var _this4 = this;

                if (Object.keys(this._listeners).length === 0) {
                    var onShow = function onShow(event) {
                        event.stopPropagation();
                        if (_this4.props.onShow) {
                            _this4.props.onShow(event);
                        }
                    };
                    this._listeners.onShow = onShow.bind(this);
                    this._modal.addEventListener("show", this._listeners.onShow);

                    var onClose = function onClose(event) {
                        event.stopPropagation();
                        if (_this4.props.onClose) {
                            _this4.props.onClose(event);
                        }
                        _this4.cleanUpListeners();
                    };
                    this._listeners.onClose = onClose.bind(this);
                    this._modal.addEventListener("close", this._listeners.onClose);

                    var onDismiss = function onDismiss(event) {
                        event.stopPropagation();
                        if (_this4.props.onDismiss) {
                            _this4.props.onDismiss(event);
                        }
                        // onDismiss emits a onClose so listener cleanup is handled there
                    };
                    this._listeners.onDismiss = onDismiss.bind(this);
                    this._modal.addEventListener("dismiss", this._listeners.onDismiss);
                }
            }
        }, {
            key: "componentWillUnmount",
            value: function componentWillUnmount() {
                // we might need a unmountPortal here depending on how applications handle dom rendering & routing
                this.cleanUpListeners();
            }
        }, {
            key: "cleanUpListeners",
            value: function cleanUpListeners() {
                // if we do not have a _modal then HAUnderlay destroys the event listeners
                if (this._modal) {
                    this._modal.removeEventListener("show", this._listeners.onShow, false); // clean up show listener
                    this._modal.removeEventListener("close", this._listeners.onClose, false); // clean up close listener
                    this._modal.removeEventListener("dismiss", this._listeners.onDismiss, false); // clean up dismiss listener
                    this._modal.removeEventListener("component-upgraded", this._listeners.componentUpgraded, false); // clean up component-upgraded listener
                }
                this._listeners = {};
            }
        }, {
            key: "getModalTitleIcon",
            value: function getModalTitleIcon(type) {
                switch (type) {
                    case "confirm":
                    case "endflow":
                        return _react2.default.createElement("i", { className: "hi hi-circle-check" });
                        break;
                    case "info":
                        return _react2.default.createElement("i", { className: "hi hi-circle-info" });
                        break;
                    case "error":
                    case "warn":
                    case "alert":
                        return _react2.default.createElement("i", { className: "hi hi-circle-alert" });
                        break;
                    default:
                        break;
                }
            }
        }, {
            key: "getModalClass",
            value: function getModalClass(type, size) {
                var dialogClass = "modal-dialog " + size + " ",
                    titleClass = "modal-title ";
                if (type === "error" || type === "alert" || type === "endflow") {
                    dialogClass += type + " ";

                    if (type === "error" || type === "alert") {
                        if (type === 'alert') {
                            console.warn('DEPRECATION WARNING: Type "alert" is deprecated, take care using this type for futures releases');
                        }
                        dialogClass = dialogClass.replace("message-icon", "");
                        titleClass += "hi-" + type;
                    } else if (type === "endflow") {
                        dialogClass += "message-icon";
                        titleClass += "hi-confirm";
                    }
                } else {
                    dialogClass += "message-icon";
                    titleClass += "hi-" + type;
                }

                return {
                    "dialog": dialogClass,
                    "title": titleClass
                };
            }
        }, {
            key: "render",
            value: function render() {
                var _this5 = this;

                /* jshint ignore:start */
                var countClassMap = {
                    1: "one-btn",
                    2: "two-btn",
                    3: "three-btn"
                },
                    classes = this.getModalClass(this.props.type, this.props.size);

                return(
                    // renders .ha-underlay and modal outside of parent react DOM tree
                    _react2.default.createElement(
                        _HAPortal2.default,
                        { show: this.props.show },
                        _react2.default.createElement(
                            "ha-modal",
                            _extends({
                                ref: this.handleRef,
                                "class": this.props.className,
                                reactLayering: true
                            }, this.props),
                            _react2.default.createElement(
                                "div",
                                { className: "modal", tabIndex: "-1", "aria-labelledby": "modal-title-" + this.compID, "aria-describedby": "modal-text-" + this.compID },
                                _react2.default.createElement(
                                    "div",
                                    { className: classes["dialog"] },
                                    _react2.default.createElement(
                                        "div",
                                        { className: "modal-content" },
                                        _react2.default.createElement(
                                            "header",
                                            null,
                                            this.props.dismissible ? _react2.default.createElement("button", { type: "button", className: "btn btn-link hi hi-close medium pull-right", "aria-label": "Close" }) : null,
                                            _react2.default.createElement(
                                                "div",
                                                { className: classes["title"] },
                                                this.getModalTitleIcon(this.props.type),
                                                this.props.size === 'small' && this.props.type === 'error' || this.props.size === 'small' && this.props.type === 'alert' ? _react2.default.createElement(
                                                    "h4",
                                                    { id: "modal-title-" + this.compID },
                                                    this.props.titleText
                                                ) : _react2.default.createElement(
                                                    "h2",
                                                    { id: "modal-title-" + this.compID },
                                                    this.props.titleText
                                                )
                                            )
                                        ),
                                        _react2.default.Children.map(this.props.children, function (child) {
                                            if (child.type === _HASection2.default) {
                                                return _react2.default.cloneElement(child, { id: "modal-text-" + _this5.compID, key: "1" });
                                            } else if (child.type === _HAFooter2.default) {
                                                var footClassName = countClassMap[_react2.default.Children.count(child.props.children)];
                                                footClassName = child.props.className ? footClassName + " " + child.props.className : footClassName;
                                                return _react2.default.cloneElement(child, { className: footClassName, key: "2" });
                                            } else if (child.type === _HAAside2.default) {
                                                return _react2.default.cloneElement(child, { key: "3" });
                                            }
                                        })
                                    )
                                )
                            )
                        )
                    )
                );
                /* jshint ignore:end */
            }
        }]);

        return HAModal;
    }(_react2.default.Component);

    HAModal.propTypes = {
        children: function children(props, propName, componentName) {
            var error = (0, _utils.checkReactChildrenType)(props[propName], componentName, [_HASection2.default, _HAFooter2.default, _HAAside2.default], "HASection,HAFooter,HAAside");
            if (error) {
                return error;
            }
        },
        className: _react2.default.PropTypes.string,
        show: _react2.default.PropTypes.bool.isRequired,
        titleText: _react2.default.PropTypes.string,
        type: _react2.default.PropTypes.string,
        size: _react2.default.PropTypes.string,
        dismissible: _react2.default.PropTypes.bool,
        onShow: _react2.default.PropTypes.func,
        onClose: _react2.default.PropTypes.func,
        onDismiss: _react2.default.PropTypes.func
    };

    var _initialiseProps = function _initialiseProps() {
        var _this6 = this;

        this.handleRef = function (c) {
            _this6._modal = c;
        };
    };

    exports.default = HAModal;
});
//# sourceMappingURL=HAModal.js.map
;
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

(function (global, factory) {
    if (typeof define === "function" && define.amd) {
        define('hui-react/HAMoneyBar',["exports", "react"], factory);
    } else if (typeof exports !== "undefined") {
        factory(exports, require("react"));
    } else {
        var mod = {
            exports: {}
        };
        factory(mod.exports, global.react);
        global.HAMoneyBar = mod.exports;
    }
})(this, function (exports, _react) {
    "use strict";

    Object.defineProperty(exports, "__esModule", {
        value: true
    });

    var _react2 = _interopRequireDefault(_react);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }

    var _createClass = function () {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }

        return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();

    function _possibleConstructorReturn(self, call) {
        if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
    }

    function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }

    var HAMoneyBar = function (_React$Component) {
        _inherits(HAMoneyBar, _React$Component);

        function HAMoneyBar() {
            _classCallCheck(this, HAMoneyBar);

            return _possibleConstructorReturn(this, (HAMoneyBar.__proto__ || Object.getPrototypeOf(HAMoneyBar)).apply(this, arguments));
        }

        _createClass(HAMoneyBar, [{
            key: "getTitle",
            value: function getTitle(props) {
                if (props.showTitle) {
                    return _react2.default.createElement(
                        "h3",
                        { className: "title" },
                        props.title
                    );
                }
            }
        }, {
            key: "getAlert",
            value: function getAlert(props) {

                var layout = _react2.default.createElement(
                    "div",
                    null,
                    _react2.default.createElement(
                        "span",
                        { className: "alertText" },
                        props.alertText
                    ),
                    _react2.default.createElement(
                        "span",
                        { className: "alertAmount" },
                        props.alertAmount
                    )
                );
                /*
                  If the view switches to mobile the XD wants a different
                  positioning of the alert message.
                  verticleLayout prop lets the component know if it has to
                  render for mobile layout (also used for homepage card layout)
                 */
                if (props.verticleLayout) {
                    layout = _react2.default.createElement(
                        "div",
                        null,
                        _react2.default.createElement(
                            "span",
                            { className: "alertAmount" },
                            props.alertAmount
                        ),
                        _react2.default.createElement(
                            "span",
                            { className: "alertText" },
                            props.alertText
                        )
                    );
                }

                if (props.showAlert && (props.alertText || props.alertAmount)) {
                    return _react2.default.createElement(
                        "div",
                        { className: "ha-money-bar-alert", onClick: props.handleAlertClick },
                        _react2.default.createElement("i", { className: "hi navigation hi-circle-alert", "aria-hidden": true }),
                        layout
                    );
                }
            }
        }, {
            key: "render",
            value: function render() {
                return _react2.default.createElement(
                    "section",
                    { className: (this.props.verticleLayout ? "layout-320" : "") + " ha-money-bar2" },
                    this.getTitle(this.props),
                    this.getAlert(this.props),
                    _react2.default.createElement(
                        "div",
                        { className: "ha-money-bar-sections" },
                        this.props.children
                    )
                );
            }
        }]);

        return HAMoneyBar;
    }(_react2.default.Component);

    exports.default = HAMoneyBar;

    HAMoneyBar.displayName = "HAMoneyBar";
    HAMoneyBar.propTypes = {
        alertText: _react2.default.PropTypes.object,
        showTitle: _react2.default.PropTypes.bool,
        alertAmount: _react2.default.PropTypes.object,
        showAlert: _react2.default.PropTypes.bool,
        handleAlertClick: _react2.default.PropTypes.func,
        verticleLayout: _react2.default.PropTypes.bool, // type of layout - true for homepage card and mobile
        title: _react2.default.PropTypes.object, // Title to be shown in dashboard card layout
        children: function children(comp, propName) {

            var children = comp[propName];
            if (children.length === undefined) {
                children = [children];
            }

            children.forEach(function (child) {
                if (child.type.displayName !== "HAMoneyBarSection") {
                    throw new Error("Cannot have " + child.type.displayName + " as a child of HAMoneyBar");
                }
            });
        }
    };
});
//# sourceMappingURL=HAMoneyBar.js.map
;
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

(function (global, factory) {
    if (typeof define === "function" && define.amd) {
        define('hui-react/HAMoneyBarAmount',["exports", "react"], factory);
    } else if (typeof exports !== "undefined") {
        factory(exports, require("react"));
    } else {
        var mod = {
            exports: {}
        };
        factory(mod.exports, global.react);
        global.HAMoneyBarAmount = mod.exports;
    }
})(this, function (exports, _react) {
    "use strict";

    Object.defineProperty(exports, "__esModule", {
        value: true
    });

    var _react2 = _interopRequireDefault(_react);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }

    var _createClass = function () {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }

        return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();

    function _possibleConstructorReturn(self, call) {
        if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
    }

    function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }

    var HAMoneyBarAmount = function (_React$Component) {
        _inherits(HAMoneyBarAmount, _React$Component);

        function HAMoneyBarAmount() {
            _classCallCheck(this, HAMoneyBarAmount);

            return _possibleConstructorReturn(this, (HAMoneyBarAmount.__proto__ || Object.getPrototypeOf(HAMoneyBarAmount)).apply(this, arguments));
        }

        _createClass(HAMoneyBarAmount, [{
            key: "render",
            value: function render() {
                var alignClass = "center-align";

                if (this.props.align === "right") {
                    alignClass = "pull-right";
                } else if (this.props.align === "left") {
                    alignClass = "pull-left";
                }

                return _react2.default.createElement(
                    "div",
                    { key: this.props.key,
                        className: "ha-money-bar-amount " + (this.props.disabled ? "inactive" : ""),
                        onClick: this.props.handleClick },
                    _react2.default.createElement(
                        "div",
                        { className: "amountText " + this.props.colorClass + " " + alignClass },
                        this.props.amount
                    ),
                    _react2.default.createElement(
                        "div",
                        { className: "subText " + alignClass },
                        this.props.subText
                    )
                );
            }
        }]);

        return HAMoneyBarAmount;
    }(_react2.default.Component);

    exports.default = HAMoneyBarAmount;

    HAMoneyBarAmount.displayName = "HAMoneyBarAmount";
    HAMoneyBarAmount.propTypes = {
        amount: _react2.default.PropTypes.object.isRequired,
        subText: _react2.default.PropTypes.object.isRequired,
        colorClass: _react2.default.PropTypes.string.isRequired,
        align: _react2.default.PropTypes.string,
        key: _react2.default.PropTypes.string,
        handleClick: _react2.default.PropTypes.func,
        disabled: _react2.default.PropTypes.bool
    };
});
//# sourceMappingURL=HAMoneyBarAmount.js.map
;
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

(function (global, factory) {
    if (typeof define === "function" && define.amd) {
        define('hui-react/HAMoneyBarSection',["exports", "react", "./HAHeader"], factory);
    } else if (typeof exports !== "undefined") {
        factory(exports, require("react"), require("./HAHeader"));
    } else {
        var mod = {
            exports: {}
        };
        factory(mod.exports, global.react, global.HAHeader);
        global.HAMoneyBarSection = mod.exports;
    }
})(this, function (exports, _react, _HAHeader) {
    "use strict";

    Object.defineProperty(exports, "__esModule", {
        value: true
    });

    var _react2 = _interopRequireDefault(_react);

    var _HAHeader2 = _interopRequireDefault(_HAHeader);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }

    var _createClass = function () {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }

        return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();

    function _possibleConstructorReturn(self, call) {
        if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
    }

    function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }

    var HAMoneyBarSection = function (_React$Component) {
        _inherits(HAMoneyBarSection, _React$Component);

        function HAMoneyBarSection() {
            _classCallCheck(this, HAMoneyBarSection);

            return _possibleConstructorReturn(this, (HAMoneyBarSection.__proto__ || Object.getPrototypeOf(HAMoneyBarSection)).apply(this, arguments));
        }

        _createClass(HAMoneyBarSection, [{
            key: "getHeader",
            value: function getHeader() {
                return _react2.default.createElement(
                    _HAHeader2.default,
                    null,
                    _react2.default.createElement(
                        "h4",
                        null,
                        _react2.default.createElement(
                            "span",
                            { className: "boldText" },
                            this.props.total,
                            " ",
                            this.props.boldText
                        ),
                        _react2.default.createElement(
                            "span",
                            { className: "plainText" },
                            this.props.plainText
                        )
                    )
                );
            }
        }, {
            key: "render",
            value: function render() {

                var content = [];
                var HAPercentageBar = undefined;

                if (this.props.children) {
                    this.props.children.forEach(function (child) {

                        if (!_react2.default.isValidElement(child)) {
                            console.warn("Invalid react element as child for HAMoneyBarSection");
                            return;
                        }

                        if (child.type.displayName) {
                            name = child.type.displayName;
                        } else {
                            // IE11 support
                            name = child.type.toString().match(/^function\s*([^\s(]+)/)[1];
                        }

                        var childName = name;

                        if (childName === "HAMoneyBarAmount") {
                            content.push(child);
                        }
                        if (childName === "HAPercentageBar") {
                            HAPercentageBar = child;
                        }
                    });
                }

                return _react2.default.createElement(
                    "div",
                    { className: this.props.className + " ha-money-bar-section" },
                    this.getHeader(),
                    _react2.default.createElement(
                        "div",
                        { className: "ha-money-bar-amounts" },
                        content
                    ),
                    HAPercentageBar
                );
            }
        }]);

        return HAMoneyBarSection;
    }(_react2.default.Component);

    exports.default = HAMoneyBarSection;

    HAMoneyBarSection.displayName = "HAMoneyBarSection";
    HAMoneyBarSection.propTypes = {
        boldText: _react2.default.PropTypes.object.isRequired,
        plainText: _react2.default.PropTypes.object.isRequired,
        total: _react2.default.PropTypes.object.isRequired,
        verticleLayout: _react2.default.PropTypes.bool,
        className: _react2.default.PropTypes.string,
        children: function children(comp, propName) {

            var children = comp[propName];
            if (children.length === undefined) {
                children = [children];
            }
            var allowed = ["HAMoneyBarAmount", "HAPercentageBar"];
            children.forEach(function (child) {
                if (allowed.indexOf(child.type.displayName) < 0) {
                    throw new Error("Cannot have child of type " + child.type.displayName + " in HAMoneyBarSection");
                }
            });
        }
    };
});
//# sourceMappingURL=HAMoneyBarSection.js.map
;
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

(function (global, factory) {
    if (typeof define === "function" && define.amd) {
        define('hui-react/HAMoneyBarSegment',["exports", "react"], factory);
    } else if (typeof exports !== "undefined") {
        factory(exports, require("react"));
    } else {
        var mod = {
            exports: {}
        };
        factory(mod.exports, global.react);
        global.HAMoneyBarSegment = mod.exports;
    }
})(this, function (exports, _react) {
    "use strict";

    Object.defineProperty(exports, "__esModule", {
        value: true
    });

    var _react2 = _interopRequireDefault(_react);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }

    var _createClass = function () {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }

        return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();

    function _possibleConstructorReturn(self, call) {
        if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
    }

    function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }

    var HAMoneyBarSegment = function (_React$Component) {
        _inherits(HAMoneyBarSegment, _React$Component);

        function HAMoneyBarSegment() {
            _classCallCheck(this, HAMoneyBarSegment);

            return _possibleConstructorReturn(this, (HAMoneyBarSegment.__proto__ || Object.getPrototypeOf(HAMoneyBarSegment)).apply(this, arguments));
        }

        _createClass(HAMoneyBarSegment, [{
            key: "_refCallback",
            value: function _refCallback(el) {
                var _this2 = this;

                this.el = el;

                if (this.el && this.el.style.width !== this.props.width) {
                    setTimeout(function () {
                        return _this2.el.style.width = _this2.props.width;
                    }, 10);
                }
            }
        }, {
            key: "render",
            value: function render() {
                this._refCallback = this._refCallback.bind(this);

                return _react2.default.createElement("div", {
                    className: (this.props.colorClass || "") + " ha-money-bar-segment " + (this.props.className || "") + " " + (this.props.disabled ? "inactive" : ""),
                    onClick: this.props.handleClick,
                    ref: this._refCallback });
            }
        }]);

        return HAMoneyBarSegment;
    }(_react2.default.Component);

    exports.default = HAMoneyBarSegment;

    HAMoneyBarSegment.displayName = "HAMoneyBarSegment";
    HAMoneyBarSegment.propTypes = {
        colorClass: _react2.default.PropTypes.string.isRequired,
        handleClick: _react2.default.PropTypes.func,
        share: _react2.default.PropTypes.number.isRequired,
        disabled: _react2.default.PropTypes.bool,
        width: _react2.default.PropTypes.string,
        className: _react2.default.PropTypes.string
    };
});
//# sourceMappingURL=HAMoneyBarSegment.js.map
;
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

(function (global, factory) {
    if (typeof define === "function" && define.amd) {
        define('hui-react/HAPageMessage',["exports", "react", "hui/page-message"], factory);
    } else if (typeof exports !== "undefined") {
        factory(exports, require("react"), require("hui/page-message"));
    } else {
        var mod = {
            exports: {}
        };
        factory(mod.exports, global.react, global.pageMessage);
        global.HAPageMessage = mod.exports;
    }
})(this, function (exports, _react) {
    "use strict";

    Object.defineProperty(exports, "__esModule", {
        value: true
    });

    var _react2 = _interopRequireDefault(_react);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }

    var _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];

            for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }

        return target;
    };

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }

    var _createClass = function () {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }

        return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();

    function _possibleConstructorReturn(self, call) {
        if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
    }

    function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }

    var HAPageMessage = function (_React$Component) {
        _inherits(HAPageMessage, _React$Component);

        function HAPageMessage(props) {
            _classCallCheck(this, HAPageMessage);

            var _this = _possibleConstructorReturn(this, (HAPageMessage.__proto__ || Object.getPrototypeOf(HAPageMessage)).call(this, props));

            _this.handleRef = function (c) {
                _this._huiComponent = c;
            };

            _this._huiComponent = null;
            _this._listeners = {};
            return _this;
        }

        _createClass(HAPageMessage, [{
            key: "renderUpdate",
            value: function renderUpdate() {
                this._huiComponent.postRender();
                var iconSpan = this._huiComponent.querySelector('span.message-icon'),
                    titleSpan = this._huiComponent.querySelector('header h4');

                if (this.props.children) {
                    this._huiComponent.message = this.props.children;
                }

                if (this.props.type === 'alert' || this.props.type === 'warn' || this.props.type === 'error') {
                    iconSpan.className = 'message-icon hi hi-circle-alert';
                    if (this.props.type === 'alert') {
                        console.warn('DEPRECATION WARNING: The "alert" type is going to be deprecated. From now on, please use "error" type instead.');
                    }
                } else if (this.props.type === 'discovery') {
                    iconSpan.className = 'message-icon hi hi-lightbulb-o';
                } else {
                    iconSpan.className = 'message-icon hi hi-circle-info';
                }

                if (titleSpan) {
                    if (this.props.titleText) {
                        titleSpan.textContent = this.props.titleText;
                    } else {
                        this._huiComponent.removeChild(titleSpan.parentElement);
                    }
                }
            }
        }, {
            key: "componentDidMount",
            value: function componentDidMount() {
                var _this2 = this;

                // With es6 syntax we have to bind the events to the react component instance
                // https://facebook.github.io/react/docs/reusable-components.html#no-autobinding
                // Event handler for close

                // partial rewrite for React 15 - update rendered children
                this.renderUpdate();

                var onClose = function onClose(event) {
                    event.stopPropagation();
                    if (_this2.props.onClose) {
                        _this2.props.onClose(event);
                    }
                };
                this._listeners.onClose = onClose.bind(this);
                this._huiComponent.addEventListener("close", this._listeners.onClose);

                // Event handler for dismiss
                var onDismiss = function onDismiss(event) {
                    event.stopPropagation();
                    if (_this2.props.onDismiss) {
                        _this2.props.onDismiss(event);
                    }
                };
                this._listeners.onDismiss = onDismiss.bind(this);
                this._huiComponent.addEventListener("dismiss", this._listeners.onDismiss);

                // Event handler for show
                var onShow = function onShow(event) {
                    event.stopPropagation();
                    if (_this2.props.onShow) {
                        _this2.props.onShow(event);
                    }
                };
                this._listeners.onShow = onShow.bind(this);
                this._huiComponent.addEventListener("show", this._listeners.onShow);
            }
        }, {
            key: "componentWillUnmount",
            value: function componentWillUnmount() {
                this._huiComponent.removeEventListener("close", this._listeners.onClose, false);
                this._huiComponent.removeEventListener("dismiss", this._listeners.onDismiss, false);
                this._huiComponent.removeEventListener("show", this._listeners.onShow, false);
            }
        }, {
            key: "render",
            value: function render() {
                /* jshint ignore:start */
                return _react2.default.createElement(
                    "ha-page-message",
                    _extends({
                        ref: this.handleRef,
                        "class": this.props.className
                    }, this.props),
                    this.props.children
                );
                /* jshint ignore:end */
            }
        }]);

        return HAPageMessage;
    }(_react2.default.Component);

    HAPageMessage.propTypes = {
        className: _react2.default.PropTypes.string,
        titleText: _react2.default.PropTypes.string,
        type: _react2.default.PropTypes.string,
        dismissible: _react2.default.PropTypes.bool,
        onClose: _react2.default.PropTypes.func,
        onDismiss: _react2.default.PropTypes.func,
        onShow: _react2.default.PropTypes.func
    };
    exports.default = HAPageMessage;
});
//# sourceMappingURL=HAPageMessage.js.map
;
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

(function (global, factory) {
    if (typeof define === "function" && define.amd) {
        define('hui-react/HAPercentageBar',["exports", "react"], factory);
    } else if (typeof exports !== "undefined") {
        factory(exports, require("react"));
    } else {
        var mod = {
            exports: {}
        };
        factory(mod.exports, global.react);
        global.HAPercentageBar = mod.exports;
    }
})(this, function (exports, _react) {
    "use strict";

    Object.defineProperty(exports, "__esModule", {
        value: true
    });

    var _react2 = _interopRequireDefault(_react);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }

    var _createClass = function () {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }

        return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();

    function _possibleConstructorReturn(self, call) {
        if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
    }

    function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }

    var HAPercentageBar = function (_React$Component) {
        _inherits(HAPercentageBar, _React$Component);

        function HAPercentageBar(props) {
            _classCallCheck(this, HAPercentageBar);

            return _possibleConstructorReturn(this, (HAPercentageBar.__proto__ || Object.getPrototypeOf(HAPercentageBar)).call(this, props));
        }

        _createClass(HAPercentageBar, [{
            key: "setWidths",
            value: function setWidths(children) {
                // get the total
                var count = 0,
                    remainingShare = 0,
                    remainingTotal = 0,
                    allZeros = true,
                    shares = null;

                // calculate the percentages of each share
                // also get the total of percents > 5
                var values = children.map(function (child) {
                    return child.props.share;
                }),
                    total = values.reduce(function (prev, curr) {
                    return prev + curr;
                }) || 1;

                shares = values.map(function (val) {
                    // check if all values are zeros
                    allZeros = allZeros && !val;
                    // normalise the numbers to percents for ease of calculation
                    var share = val * 100 / total;

                    // find the number of shares <= 5%
                    share > 0 && share <= 5 ? count++ : remainingTotal += share;
                    // return the calculated percent
                    return share;
                });

                // Calculate the remaining share after the <5%s are allocated
                // this is used to calculate the percentage needed to render the bigger shares
                remainingShare = 100 - count * 5;

                // If all values are zeros, return an array of equal shares
                if (allZeros) {
                    // generate an array of equal numbers
                    shares = Array(values.length).fill(Math.floor(100 / values.length));
                    // reseting the values
                    remainingShare = 100;
                    remainingTotal = 100;
                }

                // If share is <=5%,
                //    assign 5% space
                // else
                //     calculate the percent to be allocated to that share in the remaining space
                return children.map(function (child, idx) {
                    var width = null;
                    var share = shares[idx],
                        className = child.props.className || "";

                    if (share === 0) {
                        width = 0;
                    } else if (share <= 5) {
                        // -0.8 is to prevent the segment moving to next line due to paddings
                        width = 5 - 0.8;
                    } else {
                        // -0.8 is to prevent the segment moving to next line due to paddings
                        width = Math.floor(share * remainingShare / remainingTotal) - 0.8;
                    }

                    return _react2.default.cloneElement(child, {
                        key: idx,
                        width: width + "%",
                        className: allZeros ? className + " zero" : className
                    });
                });
            }
        }, {
            key: "render",
            value: function render() {

                return _react2.default.createElement(
                    "div",
                    { className: "ha-percentage-bar" },
                    this.setWidths(this.props.children)
                );
            }
        }]);

        return HAPercentageBar;
    }(_react2.default.Component);

    exports.default = HAPercentageBar;

    HAPercentageBar.displayName = "HAPercentageBar";

    HAPercentageBar.propTypes = {
        children: function children(props, propName) {
            props = props[propName];

            props.forEach(function (child) {
                if (child.type.displayName !== "HAMoneyBarSegment") {
                    throw new Error("Cannot have a child of type " + child.type.displayName + " for HAPercentageBar");
                }
            });
        }
    };
});
//# sourceMappingURL=HAPercentageBar.js.map
;
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

(function (global, factory) {
    if (typeof define === "function" && define.amd) {
        define('hui-react/HARadioButton',["exports", "react", "hui/radio-button"], factory);
    } else if (typeof exports !== "undefined") {
        factory(exports, require("react"), require("hui/radio-button"));
    } else {
        var mod = {
            exports: {}
        };
        factory(mod.exports, global.react, global.radioButton);
        global.HARadioButton = mod.exports;
    }
})(this, function (exports, _react) {
    "use strict";

    Object.defineProperty(exports, "__esModule", {
        value: true
    });

    var _react2 = _interopRequireDefault(_react);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }

    var _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];

            for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }

        return target;
    };

    function _objectWithoutProperties(obj, keys) {
        var target = {};

        for (var i in obj) {
            if (keys.indexOf(i) >= 0) continue;
            if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
            target[i] = obj[i];
        }

        return target;
    }

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }

    var _createClass = function () {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }

        return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();

    function _possibleConstructorReturn(self, call) {
        if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
    }

    function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }

    var HARadioButton = function (_React$Component) {
        _inherits(HARadioButton, _React$Component);

        function HARadioButton(props) {
            _classCallCheck(this, HARadioButton);

            var _this = _possibleConstructorReturn(this, (HARadioButton.__proto__ || Object.getPrototypeOf(HARadioButton)).call(this, props));

            _this.handleRef = function (c) {
                _this._huiComponent = c;
            };

            _this._huiComponent = null;
            _this._listeners = {};
            return _this;
        }

        _createClass(HARadioButton, [{
            key: "componentDidMount",
            value: function componentDidMount() {
                var _this2 = this;

                // With es6 syntax we have to bind the events to the react component instance
                // https://facebook.github.io/react/docs/reusable-components.html#no-autobinding
                // Event handler for change
                var onChange = function onChange(event) {
                    event.stopPropagation();
                    if (_this2.props.onChange) {
                        _this2.props.onChange(event);
                    }
                };
                this._listeners.onChange = onChange.bind(this);
                this._huiComponent.addEventListener("change", this._listeners.onChange);

                // Event handler for click
                var onClick = function onClick(event) {
                    event.stopPropagation();
                    if (_this2.props.onClick) {
                        _this2.props.onClick(event);
                    }
                };
                this._listeners.onClick = onClick.bind(this);
                this._huiComponent.addEventListener("click", this._listeners.onClick);
            }
        }, {
            key: "componentWillUnmount",
            value: function componentWillUnmount() {
                this._huiComponent.removeEventListener("change", this._listeners.onChange, false);
                this._huiComponent.removeEventListener("click", this._listeners.onClick, false);
            }
        }, {
            key: "render",
            value: function render() {
                var _props = this.props,

                /* jshint ignore:start */
                disabled = _props.disabled,
                    props = _objectWithoutProperties(_props, ["disabled"]);

                // polyfill for IE 11, ref: https://github.com/facebook/react/issues/961
                return disabled === true || disabled === "true" ? _react2.default.createElement("ha-radio-button", _extends({ ref: this.handleRef, "class": this.props.className, disabled: true }, props)) : _react2.default.createElement("ha-radio-button", _extends({ ref: this.handleRef, "class": this.props.className }, props));
                /* jshint ignore:end */
            }
        }]);

        return HARadioButton;
    }(_react2.default.Component);

    HARadioButton.propTypes = {
        className: _react2.default.PropTypes.string,
        label: _react2.default.PropTypes.string,
        name: _react2.default.PropTypes.string,
        value: _react2.default.PropTypes.string,
        checked: _react2.default.PropTypes.bool,
        disabled: _react2.default.PropTypes.bool,
        onChange: _react2.default.PropTypes.func,
        onClick: _react2.default.PropTypes.func
    };
    exports.default = HARadioButton;
});
//# sourceMappingURL=HARadioButton.js.map
;
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

(function (global, factory) {
    if (typeof define === "function" && define.amd) {
        define('hui-react/HARadioButtonGroup',["exports", "react", "./HARadioButton", "hui/core/utils", "hui/radio-button-group"], factory);
    } else if (typeof exports !== "undefined") {
        factory(exports, require("react"), require("./HARadioButton"), require("hui/core/utils"), require("hui/radio-button-group"));
    } else {
        var mod = {
            exports: {}
        };
        factory(mod.exports, global.react, global.HARadioButton, global.utils, global.radioButtonGroup);
        global.HARadioButtonGroup = mod.exports;
    }
})(this, function (exports, _react, _HARadioButton, _utils) {
    "use strict";

    Object.defineProperty(exports, "__esModule", {
        value: true
    });

    var _react2 = _interopRequireDefault(_react);

    var _HARadioButton2 = _interopRequireDefault(_HARadioButton);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }

    var _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];

            for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }

        return target;
    };

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }

    var _createClass = function () {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }

        return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();

    function _possibleConstructorReturn(self, call) {
        if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
    }

    function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }

    var HARadioButtonGroup = function (_React$Component) {
        _inherits(HARadioButtonGroup, _React$Component);

        function HARadioButtonGroup(props) {
            _classCallCheck(this, HARadioButtonGroup);

            var _this = _possibleConstructorReturn(this, (HARadioButtonGroup.__proto__ || Object.getPrototypeOf(HARadioButtonGroup)).call(this, props));

            _initialiseProps.call(_this);

            _this._huiComponent = null;
            _this._listeners = {};
            return _this;
        }

        _createClass(HARadioButtonGroup, [{
            key: "testValidity",
            value: function testValidity() {
                if (this.props.onValidityChange) {
                    var valid = undefined;
                    if (this._huiComponent.checkValidity) {
                        valid = this._huiComponent.checkValidity();
                    }
                    if (this._lastValidity !== valid) {
                        this._lastValidity = valid;
                        this.props.onValidityChange(valid);
                    }
                }
            }
        }, {
            key: "componentDidMount",
            value: function componentDidMount() {
                var _this2 = this;

                // With es6 syntax we have to bind the events to the react component instance
                // https://facebook.github.io/react/docs/reusable-components.html#no-autobinding
                // Event handler for change
                var onChange = function onChange(event) {
                    event.stopPropagation();
                    if (_this2.props.onChange) {
                        _this2.props.onChange(event);
                    }
                    _this2.testValidity();
                };

                // Update react components to the web component
                this.removeWebRenderComp();
                this.updateRadios();

                this._listeners.onChange = onChange.bind(this);
                this._huiComponent.addEventListener("change", this._listeners.onChange);

                // Event handler for click
                var onClick = function onClick(event) {
                    event.stopPropagation();
                    if (_this2.props.onClick) {
                        _this2.props.onClick(event);
                    }
                };
                this._listeners.onClick = onClick.bind(this);
                this._huiComponent.addEventListener("click", this._listeners.onClick);

                // Stop validation tooltip show event propagation
                var onShow = function onShow(event) {
                    event.stopPropagation();
                };
                this._listeners.onShow = onShow.bind(this);
                this._huiComponent.addEventListener("show", this._listeners.onShow);

                // Stop validation tooltip close event propagation
                var onClose = function onClose(event) {
                    event.stopPropagation();
                };
                this._listeners.onClose = onClose.bind(this);
                this._huiComponent.addEventListener("close", this._listeners.onClose);

                // Stop validation tooltip dismiss event propagation
                var onDismiss = function onDismiss(event) {
                    event.stopPropagation();
                };
                this._listeners.onDismiss = onDismiss.bind(this);
                this._huiComponent.addEventListener("dismiss", this._listeners.onDismiss);

                window.setTimeout(function () {
                    // We need the timeout so h-ui component checkValidity function is initialized
                    if (_this2.props.validator) {
                        _this2._huiComponent.validator = _this2.props.validator;
                    }
                    if (_this2.props.alwaysRenderValidity) {
                        _this2._huiComponent.reportValidity();
                    }
                    _this2.testValidity(); // We need to do initial notification of validity state.
                }, 0);
            }
        }, {
            key: "componentWillUnmount",
            value: function componentWillUnmount() {
                this._huiComponent.removeEventListener("change", this._listeners.onChange, false);
                this._huiComponent.removeEventListener("click", this._listeners.onClick, false);
                this._huiComponent.removeEventListener("show", this._listeners.onShow, false);
                this._huiComponent.removeEventListener("close", this._listeners.onClose, false);
                this._huiComponent.removeEventListener("dismiss", this._listeners.onDismiss, false);
            }
        }, {
            key: "componentDidUpdate",
            value: function componentDidUpdate() {
                if (this.props.validator) {
                    this._huiComponent.validator = this.props.validator;
                }
                this.testValidity();
                if (this.props.alwaysRenderValidity) {
                    this._huiComponent.reportValidity();
                }

                this.updateRadios();
            }
        }, {
            key: "removeWebRenderComp",
            value: function removeWebRenderComp() {
                var fieldChild = this._huiComponent.querySelectorAll("fieldset");
                if (fieldChild && fieldChild.length > 1) {
                    this._huiComponent.removeChild(fieldChild[0]);
                }
            }
        }, {
            key: "updateRadios",
            value: function updateRadios() {
                var radios = this._huiComponent.querySelectorAll("ha-radio-button");
                if (radios) {
                    this._huiComponent.radios = Array.prototype.slice.call(radios);
                }
            }
        }, {
            key: "render",
            value: function render() {
                var _this3 = this;

                /* jshint ignore:start */
                var children = undefined;
                if (this.props.value) {
                    // pass the default selected value to radio button children
                    children = _react2.default.Children.map(this.props.children, function (child) {
                        if (child.type === _HARadioButton2.default && child.props.value === _this3.props.value) {
                            return _react2.default.cloneElement(child, { checked: true });
                        } else {
                            return child;
                        }
                    });
                }
                children = children || this.props.children;

                return _react2.default.createElement(
                    "ha-radio-button-group",
                    _extends({
                        ref: this.handleRef,
                        "class": this.props.className
                    }, this.props),
                    _react2.default.createElement(
                        "fieldset",
                        null,
                        this.props.label ? _react2.default.createElement(
                            "div",
                            { className: "label-container" },
                            _react2.default.createElement(
                                "legend",
                                null,
                                this.props.label
                            )
                        ) : null,
                        children
                    )
                );
                /* jshint ignore:end */
            }
        }]);

        return HARadioButtonGroup;
    }(_react2.default.Component);

    HARadioButtonGroup.propTypes = {
        children: function children(props, propName, componentName) {
            var error = (0, _utils.checkReactChildrenType)(props[propName], componentName, _HARadioButton2.default, "HARadioButton");
            if (error) {
                return error;
            }
        },
        expected: _react2.default.PropTypes.string,
        className: _react2.default.PropTypes.string,
        name: _react2.default.PropTypes.string,
        label: _react2.default.PropTypes.string,
        value: _react2.default.PropTypes.string,
        radios: _react2.default.PropTypes.array,
        selectedItem: _react2.default.PropTypes.number,
        required: _react2.default.PropTypes.bool,
        noRequiredIndicator: _react2.default.PropTypes.bool,
        min: _react2.default.PropTypes.number,
        max: _react2.default.PropTypes.number,
        requiredMessage: _react2.default.PropTypes.string,
        invalidMessage: _react2.default.PropTypes.string,
        validator: _react2.default.PropTypes.func,
        onValidityChange: _react2.default.PropTypes.func,
        alwaysRenderValidity: _react2.default.PropTypes.bool,
        onChange: _react2.default.PropTypes.func,
        onClick: _react2.default.PropTypes.func
    };

    var _initialiseProps = function _initialiseProps() {
        var _this4 = this;

        this.handleRef = function (c) {
            _this4._huiComponent = c;
        };
    };

    exports.default = HARadioButtonGroup;
});
//# sourceMappingURL=HARadioButtonGroup.js.map
;
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

(function (global, factory) {
    if (typeof define === "function" && define.amd) {
        define('hui-react/HASegmentedButton',["exports", "react", "hui/segmented-button"], factory);
    } else if (typeof exports !== "undefined") {
        factory(exports, require("react"), require("hui/segmented-button"));
    } else {
        var mod = {
            exports: {}
        };
        factory(mod.exports, global.react, global.segmentedButton);
        global.HASegmentedButton = mod.exports;
    }
})(this, function (exports, _react) {
    "use strict";

    Object.defineProperty(exports, "__esModule", {
        value: true
    });

    var _react2 = _interopRequireDefault(_react);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }

    var _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];

            for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }

        return target;
    };

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }

    var _createClass = function () {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }

        return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();

    function _possibleConstructorReturn(self, call) {
        if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
    }

    function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }

    var HASegmentedButton = function (_React$Component) {
        _inherits(HASegmentedButton, _React$Component);

        function HASegmentedButton(props) {
            _classCallCheck(this, HASegmentedButton);

            var _this = _possibleConstructorReturn(this, (HASegmentedButton.__proto__ || Object.getPrototypeOf(HASegmentedButton)).call(this, props));

            _this.handleRef = function (c) {
                _this._huiComponent = c;
            };

            _this._huiComponent = null;
            _this._listeners = {};
            return _this;
        }

        _createClass(HASegmentedButton, [{
            key: "componentDidMount",
            value: function componentDidMount() {
                var _this2 = this;

                // update react components to the web component.
                this._huiComponent.postRender();

                // With es6 syntax we have to bind the events to the react component instance
                // https://facebook.github.io/react/docs/reusable-components.html#no-autobinding
                // Event handler for change
                var onChange = function onChange(event) {
                    event.stopPropagation();
                    if (_this2.props.onChange) {
                        _this2.props.onChange(event);
                    }
                };

                this._listeners.onChange = onChange.bind(this);
                this._huiComponent.addEventListener("change", this._listeners.onChange);

                // Event handler for click
                var onClick = function onClick(event) {
                    event.stopPropagation();
                    if (_this2.props.onClick) {
                        _this2.props.onClick(event);
                    }
                };
                this._listeners.onClick = onClick.bind(this);
                this._huiComponent.addEventListener("click", this._listeners.onClick);
            }
        }, {
            key: "componentWillUnmount",
            value: function componentWillUnmount() {
                this._huiComponent.removeEventListener("change", this._listeners.onChange, false);
                this._huiComponent.removeEventListener("click", this._listeners.onClick, false);
            }
        }, {
            key: "render",
            value: function render() {
                /* jshint ignore:start */
                return _react2.default.createElement(
                    "ha-segmented-button",
                    _extends({
                        ref: this.handleRef
                    }, this.props),
                    this.props.children
                );
                /* jshint ignore:end */
            }
        }]);

        return HASegmentedButton;
    }(_react2.default.Component);

    HASegmentedButton.propTypes = {
        className: _react2.default.PropTypes.string,
        name: _react2.default.PropTypes.string,
        label: _react2.default.PropTypes.string,
        value: _react2.default.PropTypes.string,
        buttons: _react2.default.PropTypes.array,
        selectedItem: _react2.default.PropTypes.object,
        selectedIndex: _react2.default.PropTypes.number,
        onChange: _react2.default.PropTypes.func,
        onClick: _react2.default.PropTypes.func
    };
    exports.default = HASegmentedButton;
});
//# sourceMappingURL=HASegmentedButton.js.map
;
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

(function (global, factory) {
    if (typeof define === "function" && define.amd) {
        define('hui-react/HASelect',["exports", "react", "hui/select"], factory);
    } else if (typeof exports !== "undefined") {
        factory(exports, require("react"), require("hui/select"));
    } else {
        var mod = {
            exports: {}
        };
        factory(mod.exports, global.react, global.select);
        global.HASelect = mod.exports;
    }
})(this, function (exports, _react) {
    "use strict";

    Object.defineProperty(exports, "__esModule", {
        value: true
    });

    var _react2 = _interopRequireDefault(_react);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }

    var _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];

            for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }

        return target;
    };

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }

    var _createClass = function () {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }

        return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();

    function _possibleConstructorReturn(self, call) {
        if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
    }

    function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }

    var HASelect = function (_React$Component) {
        _inherits(HASelect, _React$Component);

        function HASelect(props) {
            _classCallCheck(this, HASelect);

            var _this = _possibleConstructorReturn(this, (HASelect.__proto__ || Object.getPrototypeOf(HASelect)).call(this, props));

            _this.handleRef = function (c) {
                _this._huiComponent = c;
                // connect the selectedItemRenderer property to the component.
                if (_this.props && _this.props.selectedItemRenderer) {
                    _this._huiComponent.selectedItemRenderer = _this.props.selectedItemRenderer;
                }
            };

            _this._huiComponent = null;
            _this._listeners = {};
            return _this;
        }

        _createClass(HASelect, [{
            key: "testValidity",
            value: function testValidity() {
                if (this.props.onValidityChange) {
                    var valid = undefined;
                    if (this._huiComponent.checkValidity) {
                        valid = this._huiComponent.checkValidity();
                    }
                    if (this._lastValidity !== valid) {
                        this._lastValidity = valid;
                        this.props.onValidityChange(valid);
                    }
                }
            }
        }, {
            key: "updateAddNewPop",
            value: function updateAddNewPop() {
                var addNewPopForm = this._huiComponent.querySelector('ha-popover > ha-popover-form'),
                    addNewPop = undefined;

                if (addNewPopForm) {
                    addNewPop = addNewPopForm.parentElement;
                }

                if (addNewPop) {
                    this._huiComponent.addNewPopover = addNewPop;
                }
            }
        }, {
            key: "componentDidMount",
            value: function componentDidMount() {
                var _this2 = this;

                // With es6 syntax we have to bind the events to the react component instance
                // https://facebook.github.io/react/docs/reusable-components.html#no-autobinding
                // Event handler for add-new
                var onAddNew = function onAddNew(event) {
                    event.stopPropagation();
                    if (_this2.props.onAddNew) {
                        _this2.props.onAddNew(event);
                    }
                };
                this._listeners.onAddNew = onAddNew.bind(this);
                this._huiComponent.addEventListener("add-new", this._listeners.onAddNew);

                // update web popover-form to react-compnent
                if (this.props.addNew) {
                    this.updateAddNewPop();
                }

                // Event handler for change
                var onChange = function onChange(event) {
                    event.stopPropagation();
                    if (_this2.props.onChange) {
                        _this2.props.onChange(event);
                    }
                    _this2.testValidity();
                };
                this._listeners.onChange = onChange.bind(this);
                this._huiComponent.addEventListener("change", this._listeners.onChange);

                // Event handler for click
                var onClick = function onClick(event) {
                    event.stopPropagation();
                    if (_this2.props.onClick) {
                        _this2.props.onClick(event);
                    }
                };
                this._listeners.onClick = onClick.bind(this);
                this._huiComponent.addEventListener("click", this._listeners.onClick);

                // Invoked after the popover menu appears
                var onItemsShow = function onItemsShow(event) {
                    event.stopPropagation();
                    if (_this2.props.onItemsShow) {
                        _this2.props.onItemsShow(event);
                    }
                };
                this._listeners.onItemsShow = onItemsShow.bind(this);
                this._huiComponent.addEventListener("items-show", this._listeners.onItemsShow);

                // Invoked after the popover menu is dismissed
                var onItemsClose = function onItemsClose(event) {
                    event.stopPropagation();
                    if (_this2.props.onItemsClose) {
                        _this2.props.onItemsClose(event);
                    }
                };
                this._listeners.onItemsClose = onItemsClose.bind(this);
                this._huiComponent.addEventListener("items-close", this._listeners.onItemsClose);

                // Stop validation tooltip dismiss event propagation
                var onDismiss = function onDismiss(event) {
                    event.stopPropagation();
                };
                this._listeners.onDismiss = onDismiss.bind(this);
                this._huiComponent.addEventListener("dismiss", this._listeners.onDismiss);

                window.setTimeout(function () {
                    // We need the timeout so h-ui component checkValidity function is initialized
                    if (_this2.props.validator) {
                        _this2._huiComponent.validator = _this2.props.validator;
                    }
                    if (_this2.props.alwaysRenderValidity) {
                        _this2._huiComponent.reportValidity();
                    }
                    if (_this2.props.resetValidation) {
                        _this2._huiComponent.resetValidation();
                    }
                    _this2.testValidity(); // We need to do initial notification of validity state.

                    // set the default value pass by property
                    if (_this2._huiComponent && _this2.props.value) {
                        _this2._huiComponent.value = _this2.props.value;
                    }
                }, 0);
            }
        }, {
            key: "componentWillUnmount",
            value: function componentWillUnmount() {
                this._huiComponent.removeEventListener("add-new", this._listeners.onAddNew, false);
                this._huiComponent.removeEventListener("change", this._listeners.onChange, false);
                this._huiComponent.removeEventListener("click", this._listeners.onClick, false);
                this._huiComponent.removeEventListener("items-show", this._listeners.onItemsShow, false);
                this._huiComponent.removeEventListener("items-close", this._listeners.onItemsClose, false);
                this._huiComponent.removeEventListener("dismiss", this._listeners.onDismiss, false);
                this._huiComponent.resetValidation();
            }
        }, {
            key: "componentDidUpdate",
            value: function componentDidUpdate() {
                if (this.props.validator) {
                    this._huiComponent.validator = this.props.validator;
                }
                this.testValidity();
                if (this.props.alwaysRenderValidity) {
                    this._huiComponent.reportValidity();
                }
                if (this.props.resetValidation) {
                    this._huiComponent.resetValidation();
                }
            }
        }, {
            key: "render",
            value: function render() {
                /* jshint ignore:start */
                return _react2.default.createElement(
                    "ha-select",
                    _extends({ ref: this.handleRef, "class": this.props.className }, this.props),
                    this.props.children
                );
                /* jshint ignore:end */
            }
        }]);

        return HASelect;
    }(_react2.default.Component);

    HASelect.propTypes = {
        className: _react2.default.PropTypes.string,
        label: _react2.default.PropTypes.string,
        placeholder: _react2.default.PropTypes.string,
        icon: _react2.default.PropTypes.string,
        name: _react2.default.PropTypes.string,
        value: _react2.default.PropTypes.string,
        items: _react2.default.PropTypes.array,
        size: _react2.default.PropTypes.number,
        selectedIndex: _react2.default.PropTypes.number,
        selectedItem: _react2.default.PropTypes.object,
        addNew: _react2.default.PropTypes.bool,
        addNewPopover: _react2.default.PropTypes.object,
        addNewText: _react2.default.PropTypes.string,
        disabled: _react2.default.PropTypes.bool,
        required: _react2.default.PropTypes.bool,
        noRequiredIndicator: _react2.default.PropTypes.bool,
        min: _react2.default.PropTypes.number,
        max: _react2.default.PropTypes.number,
        requiredMessage: _react2.default.PropTypes.string,
        invalidMessage: _react2.default.PropTypes.string,
        validator: _react2.default.PropTypes.func,
        onValidityChange: _react2.default.PropTypes.func,
        alwaysRenderValidity: _react2.default.PropTypes.bool,
        resetValidation: _react2.default.PropTypes.bool,
        onAddNew: _react2.default.PropTypes.func,
        onChange: _react2.default.PropTypes.func,
        onClick: _react2.default.PropTypes.func,
        onItemsShow: _react2.default.PropTypes.func,
        onItemsClose: _react2.default.PropTypes.func,
        selectedItemRenderer: _react2.default.PropTypes.func
    };
    exports.default = HASelect;
});
//# sourceMappingURL=HASelect.js.map
;
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

(function (global, factory) {
    if (typeof define === "function" && define.amd) {
        define('hui-react/HASelectTypeAhead',["exports", "react", "hui/core/utils", "hui/select-type-ahead"], factory);
    } else if (typeof exports !== "undefined") {
        factory(exports, require("react"), require("hui/core/utils"), require("hui/select-type-ahead"));
    } else {
        var mod = {
            exports: {}
        };
        factory(mod.exports, global.react, global.utils, global.selectTypeAhead);
        global.HASelectTypeAhead = mod.exports;
    }
})(this, function (exports, _react, _utils) {
    "use strict";

    Object.defineProperty(exports, "__esModule", {
        value: true
    });

    var _react2 = _interopRequireDefault(_react);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }

    var _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];

            for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }

        return target;
    };

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }

    var _createClass = function () {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }

        return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();

    function _possibleConstructorReturn(self, call) {
        if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
    }

    function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }

    function toStore(data) {
        return {
            query: function query() {
                return {
                    then: function then(callback) {
                        callback(data);
                    }
                };
            }
        };
    }

    function propsWithout(exludeList, props) {
        return Object.getOwnPropertyNames(props).reduce(function (newProps, propName) {
            if (exludeList.indexOf(propName) < 0) {
                newProps[propName] = props[propName];
            }
            return newProps;
        }, {});
    }

    function pluckSelectedItem(event) {
        var selectedItem = event.target.selectedItem;
        // for backward-compatibility
        event.selectedItem = selectedItem;

        return event;
    }

    var HASelectTypeAhead = function (_Component) {
        _inherits(HASelectTypeAhead, _Component);

        function HASelectTypeAhead(props) {
            _classCallCheck(this, HASelectTypeAhead);

            var _this = _possibleConstructorReturn(this, (HASelectTypeAhead.__proto__ || Object.getPrototypeOf(HASelectTypeAhead)).call(this, props));

            _this._huiComponent = null;
            _this._listeners = {};
            _this.state = {
                classAttributes: null
            };

            // Bind event handling methods to current instance
            _this.handleClick = _this.handleClick.bind(_this);
            _this.handleRef = _this.handleRef.bind(_this);
            return _this;
        }

        _createClass(HASelectTypeAhead, [{
            key: "componentDidMount",
            value: function componentDidMount() {
                var _this2 = this;

                // Event handler for change
                this._huiComponent.addEventListener("change", function (event) {
                    event.stopPropagation();
                    if (_this2.props.onChange) {
                        _this2.props.onChange(pluckSelectedItem(event));
                    }
                    _this2.testValidity();
                });

                this.domElementPostRender();

                window.setTimeout(function () {
                    // We need the timeout so h-ui component checkValidity function is initialized
                    if (_this2.props.validator) {
                        _this2._huiComponent.validator = _this2.props.validator;
                    }
                    if (_this2.props.alwaysRenderValidity) {
                        _this2._huiComponent.reportValidity();
                    }
                    if (_this2.props.resetValidation) {
                        _this2._huiComponent.resetValidation();
                    }
                    _this2.testValidity(); // We need to do initial notification of validity state.
                }, 0);

                // Invoked after the popover menu appears
                var onItemsShow = function onItemsShow(event) {
                    event.stopPropagation();
                    if (_this2.props.onItemsShow) {
                        _this2.props.onItemsShow(event);
                    }
                };
                this._listeners.onItemsShow = onItemsShow.bind(this);
                this._huiComponent.addEventListener("items-show", this._listeners.onItemsShow);

                // Invoked after the popover menu is dismissed
                var onItemsClose = function onItemsClose(event) {
                    event.stopPropagation();
                    if (_this2.props.onItemsClose) {
                        _this2.props.onItemsClose(event);
                    }
                };
                this._listeners.onItemsClose = onItemsClose.bind(this);
                this._huiComponent.addEventListener("items-close", this._listeners.onItemsClose);

                if (this.props.className) {
                    this.updateElementClasses();
                }
            }
        }, {
            key: "componentWillReceiveProps",
            value: function componentWillReceiveProps(nextProps) {
                // ensure that H-UI supported classes on the element aren't erased on props change
                var existingClasses = this.state.classAttributes;
                if (existingClasses !== nextProps.className) {
                    this.updateElementClasses(nextProps);
                }
            }
        }, {
            key: "componentDidUpdate",
            value: function componentDidUpdate() {
                if (this.props.validator) {
                    this._huiComponent.validator = this.props.validator;
                }
                if (this.props.alwaysRenderValidity) {
                    this._huiComponent.reportValidity();
                }
                if (this.props.resetValidation) {
                    this._huiComponent.resetValidation();
                }
                this.domElementPostRender();
            }
        }, {
            key: "componentWillUnmount",
            value: function componentWillUnmount() {
                this._huiComponent.removeEventListener("change", null, false);
                this._huiComponent.removeEventListener("items-show", this._listeners.onItemsShow, false);
                this._huiComponent.removeEventListener("items-close", this._listeners.onItemsClose, false);
                this._huiComponent.resetValidation();
            }
        }, {
            key: "updateElementClasses",
            value: function updateElementClasses(newProps) {
                var mergedClassString = undefined;
                if (newProps) {
                    mergedClassString = (0, _utils.updateClassWithProps)(this._huiComponent, newProps.className);
                } else {
                    mergedClassString = (0, _utils.updateClassWithProps)(this._huiComponent, this.props.className);
                }

                // re-render the element with addition / removal of props
                if (mergedClassString) {
                    this.setState({
                        classAttributes: mergedClassString
                    });
                }
            }
        }, {
            key: "testValidity",
            value: function testValidity() {
                if (this.props.onValidityChange) {
                    var valid = undefined;
                    if (this._huiComponent.checkValidity) {
                        valid = this._huiComponent.checkValidity();
                    }
                    if (this._lastValidity !== valid) {
                        this._lastValidity = valid;
                        this.props.onValidityChange(valid);
                    }
                }
            }
        }, {
            key: "handleClick",
            value: function handleClick(event) {
                if (this.props.onClick) {
                    this.props.onClick(event);
                }
            }
        }, {
            key: "handleRef",
            value: function handleRef(c) {
                this._huiComponent = c;
                // connect the itemRenderer property to the component.
                if (this._huiComponent && this.props && this.props.itemRenderer) {
                    this._huiComponent.itemRenderer = this.props.itemRenderer;
                }
            }
        }, {
            key: "getStore",
            value: function getStore() {
                var _props = this.props,
                    store = _props.store,
                    data = _props.data,
                    huiComponent = this._huiComponent;

                if (store) {
                    return store;
                } else if (data) {
                    if (this._currentData === data) {
                        // If data has not changed return the current store
                        return huiComponent.store;
                    } else {
                        this._currentData = data;
                        return toStore(data);
                    }
                } else {
                    return toStore([]);
                }
            }
        }, {
            key: "updatePopoverForm",
            value: function updatePopoverForm() {
                var popoverForm = this._huiComponent.querySelector("ha-popover-form");

                if (popoverForm && popoverForm.parentNode) {
                    this._huiComponent.addNewPopover = popoverForm.parentNode;
                } else {
                    if (!this._huiComponent.addNewPopover) {
                        console.error("No popover-form defined. Please provide the correct popover and popover-form structure.");
                    }
                }
            }
        }, {
            key: "domElementPostRender",
            value: function domElementPostRender() {
                var _props2 = this.props,
                    value = _props2.value,
                    selectedIndex = _props2.selectedIndex,
                    huiComponent = this._huiComponent,
                    newStore = this.getStore();

                if (this.props.addNew === true || this.props.addNew === "true") {
                    this.updatePopoverForm();
                }

                // Don't set the store if it is the same as the current store
                if (newStore !== huiComponent.store) {
                    huiComponent.store = newStore;
                }

                if (value && value !== huiComponent.value) {
                    // After the store is set, we need to set the value again
                    huiComponent.value = this.props.value;
                    // And then we remove 'menu-expanded' to make sure the popover remains closed.
                    huiComponent.classList.remove("menu-expanded");
                }

                if (selectedIndex && selectedIndex !== huiComponent.selectedIndex) {
                    // After the store is set, we need to set the selectedIndex again
                    huiComponent.selectedIndex = this.props.selectedIndex;
                }
            }
        }, {
            key: "hasStaticItems",
            value: function hasStaticItems() {
                var _props3 = this.props,
                    staticItems = _props3.staticItems,
                    store = _props3.store,
                    data = _props3.data;

                return staticItems || data && !store ? true : false;
            }
        }, {
            key: "render",
            value: function render() {
                var excludeProps = ["data", "store", "ref", "key"];
                // workaround for IE 11, ref: https://github.com/facebook/react/issues/961
                if (this.props.disabled === false || this.props.disabled === "false") {
                    excludeProps.push("disabled");
                }
                var props = propsWithout(excludeProps, this.props);
                /* jshint ignore:start */
                return _react2.default.createElement(
                    "ha-select-type-ahead",
                    _extends({
                        ref: this.handleRef,
                        "class": this.state.classAttributes,
                        onClick: this.handleClick,
                        staticItems: this.hasStaticItems()
                    }, props),
                    this.props.children
                );
                /* jshint ignore:end */
            }
        }]);

        return HASelectTypeAhead;
    }(_react.Component);

    HASelectTypeAhead.propTypes = {
        className: _react2.default.PropTypes.string,
        mobileMenuClass: _react2.default.PropTypes.oneOfType([_react2.default.PropTypes.array, _react2.default.PropTypes.string]),
        label: _react2.default.PropTypes.string,
        placeholder: _react2.default.PropTypes.string,
        icon: _react2.default.PropTypes.string,
        name: _react2.default.PropTypes.string,
        value: _react2.default.PropTypes.string,
        typedText: _react2.default.PropTypes.string,
        size: _react2.default.PropTypes.number,
        disabled: _react2.default.PropTypes.bool,
        required: _react2.default.PropTypes.bool,
        noRequiredIndicator: _react2.default.PropTypes.bool,
        selectedIndex: _react2.default.PropTypes.number,
        selectedItem: _react2.default.PropTypes.object,
        filterMode: _react2.default.PropTypes.string,
        store: _react2.default.PropTypes.object,
        storeLabelProperty: _react2.default.PropTypes.string,
        storeValueProperty: _react2.default.PropTypes.string,
        staticItems: _react2.default.PropTypes.bool,
        addNew: _react2.default.PropTypes.oneOfType([_react2.default.PropTypes.bool, _react2.default.PropTypes.string]),
        addNewText: _react2.default.PropTypes.string,
        min: _react2.default.PropTypes.number,
        max: _react2.default.PropTypes.number,
        requiredMessage: _react2.default.PropTypes.string,
        invalidMessage: _react2.default.PropTypes.string,
        validator: _react2.default.PropTypes.func,
        onValidityChange: _react2.default.PropTypes.func,
        alwaysRenderValidity: _react2.default.PropTypes.bool,
        resetValidation: _react2.default.PropTypes.bool,
        onClick: _react2.default.PropTypes.func,
        onChange: _react2.default.PropTypes.func,
        onItemsShow: _react2.default.PropTypes.func,
        onItemsClose: _react2.default.PropTypes.func,
        data: _react2.default.PropTypes.array,
        children: _react2.default.PropTypes.element,
        itemRenderer: _react2.default.PropTypes.func
    };
    exports.default = HASelectTypeAhead;
});
//# sourceMappingURL=HASelectTypeAhead.js.map
;
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

(function (global, factory) {
    if (typeof define === "function" && define.amd) {
        define('hui-react/HASingleStep',["exports", "react", "hui/single-step"], factory);
    } else if (typeof exports !== "undefined") {
        factory(exports, require("react"), require("hui/single-step"));
    } else {
        var mod = {
            exports: {}
        };
        factory(mod.exports, global.react, global.singleStep);
        global.HASingleStep = mod.exports;
    }
})(this, function (exports, _react) {
    "use strict";

    Object.defineProperty(exports, "__esModule", {
        value: true
    });

    var _react2 = _interopRequireDefault(_react);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }

    var _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];

            for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }

        return target;
    };

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }

    var _createClass = function () {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }

        return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();

    function _possibleConstructorReturn(self, call) {
        if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
    }

    function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }

    var HASingleStep = function (_React$Component) {
        _inherits(HASingleStep, _React$Component);

        function HASingleStep(props) {
            _classCallCheck(this, HASingleStep);

            var _this = _possibleConstructorReturn(this, (HASingleStep.__proto__ || Object.getPrototypeOf(HASingleStep)).call(this, props));

            _this.onClick = function (event) {
                if (_this.props.onClick) {
                    _this.props.onClick(event);
                }
            };

            _this.handleRef = function (c) {
                _this._huiComponent = c;
            };

            _this._huiComponent = null;
            _this._listeners = {
                onChange: null
            };
            return _this;
        }

        //Event handler for Click

        _createClass(HASingleStep, [{
            key: "componentDidMount",
            value: function componentDidMount() {
                var _this2 = this;

                // Event handler for change
                this._listeners.onChange = function (event) {
                    event.stopPropagation();
                    if (_this2.props.onChange) {
                        _this2.props.onChange(event);
                    }
                };
                this._huiComponent.addEventListener("change", this._listeners.onChange);
            }
        }, {
            key: "componentWillUnmount",
            value: function componentWillUnmount() {
                this._huiComponent.removeEventListener("change", this._listeners.onChange, false);
            }
        }, {
            key: "render",
            value: function render() {
                /* jshint ignore:start */
                return _react2.default.createElement(
                    "ha-single-step",
                    _extends({
                        ref: this.handleRef,
                        "class": this.props.className,
                        onClick: this.onClick
                    }, this.props),
                    this.props.children
                );
                /* jshint ignore:end */
            }
        }]);

        return HASingleStep;
    }(_react2.default.Component);

    HASingleStep.propTypes = {
        id: _react2.default.PropTypes.string,
        className: _react2.default.PropTypes.string,
        showOnRender: _react2.default.PropTypes.bool,
        targetSelector: _react2.default.PropTypes.string,
        position: _react2.default.PropTypes.string,
        titleText: _react2.default.PropTypes.string,
        message: _react2.default.PropTypes.string,
        dismissible: _react2.default.PropTypes.bool,
        trigger: _react2.default.PropTypes.string,
        duration: _react2.default.PropTypes.oneOfType([_react2.default.PropTypes.number, _react2.default.PropTypes.string]),
        onChange: _react2.default.PropTypes.func,
        onClick: _react2.default.PropTypes.func
    };
    exports.default = HASingleStep;
});
//# sourceMappingURL=HASingleStep.js.map
;
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

(function (global, factory) {
    if (typeof define === "function" && define.amd) {
        define('hui-react/HAStackedPageMessages',["exports", "react", "hui/stacked-page-messages"], factory);
    } else if (typeof exports !== "undefined") {
        factory(exports, require("react"), require("hui/stacked-page-messages"));
    } else {
        var mod = {
            exports: {}
        };
        factory(mod.exports, global.react, global.stackedPageMessages);
        global.HAStackedPageMessages = mod.exports;
    }
})(this, function (exports, _react) {
    "use strict";

    Object.defineProperty(exports, "__esModule", {
        value: true
    });

    var _react2 = _interopRequireDefault(_react);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }

    var _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];

            for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }

        return target;
    };

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }

    var _createClass = function () {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }

        return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();

    function _possibleConstructorReturn(self, call) {
        if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
    }

    function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }

    var HAStackedPageMessages = function (_React$Component) {
        _inherits(HAStackedPageMessages, _React$Component);

        function HAStackedPageMessages(props) {
            _classCallCheck(this, HAStackedPageMessages);

            var _this = _possibleConstructorReturn(this, (HAStackedPageMessages.__proto__ || Object.getPrototypeOf(HAStackedPageMessages)).call(this, props));

            _this.handleRef = function (c) {
                _this._huiComponent = c;
            };

            _this._huiComponent = null;
            _this._listeners = {};
            return _this;
        }

        _createClass(HAStackedPageMessages, [{
            key: "componentDidMount",
            value: function componentDidMount() {
                var _this2 = this;

                // With es6 syntax we have to bind the events to the react component instance
                // https://facebook.github.io/react/docs/reusable-components.html#no-autobinding
                // Event handler for close
                var onClose = function onClose(event) {
                    event.stopPropagation();
                    if (_this2.props.onClose) {
                        _this2.props.onClose(event);
                    }
                };
                this._listeners.onClose = onClose.bind(this);
                this._huiComponent.addEventListener("close", this._listeners.onClose);

                // Event handler for show
                var onShow = function onShow(event) {
                    event.stopPropagation();
                    if (_this2.props.onShow) {
                        _this2.props.onShow(event);
                    }
                };
                this._listeners.onShow = onShow.bind(this);
                this._huiComponent.addEventListener("show", this._listeners.onShow);

                var haMessages = Array.prototype.slice.call(this._huiComponent.querySelectorAll("ha-page-message"));
                this._huiComponent.messages = haMessages;
            }
        }, {
            key: "componentWillUnmount",
            value: function componentWillUnmount() {
                this._huiComponent.removeEventListener("close", this._listeners.onClose, false);
                this._huiComponent.removeEventListener("show", this._listeners.onShow, false);
            }
        }, {
            key: "render",
            value: function render() {
                /* jshint ignore:start */
                return _react2.default.createElement(
                    "ha-stacked-page-messages",
                    _extends({
                        ref: this.handleRef,
                        "class": this.props.className
                    }, this.props),
                    this.props.children
                );
                /* jshint ignore:end */
            }
        }]);

        return HAStackedPageMessages;
    }(_react2.default.Component);

    HAStackedPageMessages.propTypes = {
        className: _react2.default.PropTypes.string,
        onClose: _react2.default.PropTypes.func,
        onShow: _react2.default.PropTypes.func
    };
    exports.default = HAStackedPageMessages;
});
//# sourceMappingURL=HAStackedPageMessages.js.map
;
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

(function (global, factory) {
    if (typeof define === "function" && define.amd) {
        define('hui-react/HAStage',["exports", "react", "./HAHeader", "./HASection", "hui/core/utils", "hui/stage"], factory);
    } else if (typeof exports !== "undefined") {
        factory(exports, require("react"), require("./HAHeader"), require("./HASection"), require("hui/core/utils"), require("hui/stage"));
    } else {
        var mod = {
            exports: {}
        };
        factory(mod.exports, global.react, global.HAHeader, global.HASection, global.utils, global.stage);
        global.HAStage = mod.exports;
    }
})(this, function (exports, _react, _HAHeader, _HASection, _utils) {
    "use strict";

    Object.defineProperty(exports, "__esModule", {
        value: true
    });

    var _react2 = _interopRequireDefault(_react);

    var _HAHeader2 = _interopRequireDefault(_HAHeader);

    var _HASection2 = _interopRequireDefault(_HASection);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }

    var _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];

            for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }

        return target;
    };

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }

    var _createClass = function () {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }

        return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();

    function _possibleConstructorReturn(self, call) {
        if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
    }

    function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }

    var HAStage = function (_React$Component) {
        _inherits(HAStage, _React$Component);

        function HAStage(props) {
            _classCallCheck(this, HAStage);

            var _this = _possibleConstructorReturn(this, (HAStage.__proto__ || Object.getPrototypeOf(HAStage)).call(this, props));

            _initialiseProps.call(_this);

            _this.childCount = 0;
            _this._huiComponent = null;
            _this.state = {
                classAttributes: null
            };
            return _this;
        }

        _createClass(HAStage, [{
            key: "componentDidMount",
            value: function componentDidMount() {
                this.updateHeader();
                this.updateSection();

                if (this.props.collapsible) {
                    if (this.childCount === 2) {
                        this._huiComponent.collapsible = this.props.collapsible;
                    } else {
                        console.error("You can not set collapsible to be true if you do not have both a header and a section.");
                    }
                }

                if (this.props.open) {
                    this._huiComponent.open = this.props.open;
                }

                // merge pre-existing custom element classes with props
                if (this.props.className) {
                    this.updateElementClasses();
                }
            }
        }, {
            key: "updateElementClasses",
            value: function updateElementClasses() {
                var mergedClassString = (0, _utils.updateClassWithProps)(this._huiComponent, this.props.className);
                if (mergedClassString) {
                    this.setState({
                        classAttributes: mergedClassString
                    });
                }
            }
        }, {
            key: "updateHeader",
            value: function updateHeader() {
                var header = this._huiComponent.querySelector("header");

                if (header) {
                    this._huiComponent.header = Array.prototype.slice.call(header.childNodes);
                    this.childCount++;
                }
            }
        }, {
            key: "updateSection",
            value: function updateSection() {
                var section = this._huiComponent.querySelector("section");

                if (section) {
                    this._huiComponent.section = Array.prototype.slice.call(section.childNodes);
                    this.childCount++;
                }
            }
        }, {
            key: "render",
            value: function render() {
                /* jshint ignore:start */
                return _react2.default.createElement(
                    "ha-stage",
                    _extends({
                        ref: this.handleRef,
                        reactLayering: true,
                        "class": this.state.classAttributes
                    }, this.props),
                    this.props.children
                );
                /* jshint ignore:end */
            }
        }]);

        return HAStage;
    }(_react2.default.Component);

    HAStage.propTypes = {
        children: function anonymous(props, propName, componentName) {
            var error = (0, _utils.checkReactChildrenType)(props[propName], componentName, [_HAHeader2.default, _HASection2.default], "HAHeader,HASection");
            if (error) {
                return error;
            }
        },
        className: _react2.default.PropTypes.string,
        open: _react2.default.PropTypes.bool,
        collapsible: _react2.default.PropTypes.bool
    };

    var _initialiseProps = function _initialiseProps() {
        var _this2 = this;

        this.handleRef = function (c) {
            _this2._huiComponent = c;
        };
    };

    exports.default = HAStage;
});
//# sourceMappingURL=HAStage.js.map
;
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

(function (global, factory) {
    if (typeof define === "function" && define.amd) {
        define('hui-react/HAStepFlow',["exports", "react", "./HAFlowStep", "./HAFlowLanding", "./HAFlowConfirmation", "hui/core/utils", "hui/step-flow"], factory);
    } else if (typeof exports !== "undefined") {
        factory(exports, require("react"), require("./HAFlowStep"), require("./HAFlowLanding"), require("./HAFlowConfirmation"), require("hui/core/utils"), require("hui/step-flow"));
    } else {
        var mod = {
            exports: {}
        };
        factory(mod.exports, global.react, global.HAFlowStep, global.HAFlowLanding, global.HAFlowConfirmation, global.utils, global.stepFlow);
        global.HAStepFlow = mod.exports;
    }
})(this, function (exports, _react, _HAFlowStep, _HAFlowLanding, _HAFlowConfirmation, _utils) {
    "use strict";

    Object.defineProperty(exports, "__esModule", {
        value: true
    });

    var _react2 = _interopRequireDefault(_react);

    var _HAFlowStep2 = _interopRequireDefault(_HAFlowStep);

    var _HAFlowLanding2 = _interopRequireDefault(_HAFlowLanding);

    var _HAFlowConfirmation2 = _interopRequireDefault(_HAFlowConfirmation);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }

    var _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];

            for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }

        return target;
    };

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }

    var _createClass = function () {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }

        return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();

    function _possibleConstructorReturn(self, call) {
        if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
    }

    function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }

    var HAStepFlow = function (_React$Component) {
        _inherits(HAStepFlow, _React$Component);

        function HAStepFlow(props) {
            _classCallCheck(this, HAStepFlow);

            var _this = _possibleConstructorReturn(this, (HAStepFlow.__proto__ || Object.getPrototypeOf(HAStepFlow)).call(this, props));

            _initialiseProps.call(_this);

            _this._huiComponent = null;
            _this._listeners = {};
            return _this;
        }

        _createClass(HAStepFlow, [{
            key: "componentDidMount",
            value: function componentDidMount() {
                var _this2 = this;

                // force the web component to pick up React rendering components.
                this._huiComponent.postRender();

                if (this._huiComponent.show) {
                    this._huiComponent.show();
                } else {
                    // on browsers that doesn't support custom elements natively,
                    // the component is not upgraded yet so show is not available, wait for event
                    var componentUpgraded = function componentUpgraded(event) {
                        event.stopPropagation();
                        _this2._huiComponent.show();
                    };
                    this._listeners.componentUpgraded = componentUpgraded.bind(this);
                    this._huiComponent.addEventListener("component-upgraded", this._listeners.componentUpgraded);
                }

                // Event handler for next
                var onNext = function onNext(event) {
                    if (_this2.props.onNext) {
                        _this2.props.onNext(event);
                    }
                };
                this._listeners.onNext = onNext.bind(this);
                this._huiComponent.addEventListener("next", this._listeners.onNext);

                // Event handler for previous
                var onPrevious = function onPrevious(event) {
                    if (_this2.props.onPrevious) {
                        _this2.props.onPrevious(event);
                    }
                };
                this._listeners.onPrevious = onPrevious.bind(this);
                this._huiComponent.addEventListener("previous", this._listeners.onPrevious);

                // Event handler for done
                var onDone = function onDone(event) {
                    if (_this2.props.onDone) {
                        _this2.props.onDone(event);
                    }
                };
                this._listeners.onDone = onDone.bind(this);
                this._huiComponent.addEventListener("done", this._listeners.onDone);

                // Event handler for show
                var onShow = function onShow(event) {
                    if (_this2.props.onShow) {
                        _this2.props.onShow(event);
                    }
                };
                this._listeners.onShow = onShow.bind(this);
                this._huiComponent.addEventListener("show", this._listeners.onShow);

                // Event handler for close
                var onClose = function onClose(event) {
                    if (_this2.props.onClose) {
                        _this2.props.onClose(event);
                    }
                };
                this._listeners.onClose = onClose.bind(this);
                this._huiComponent.addEventListener("close", this._listeners.onClose);

                // Event handler for before-step
                var onBeforeStep = function onBeforeStep(event) {
                    if (_this2.props.onBeforeStep) {
                        _this2.props.onBeforeStep(event);
                    }
                };
                this._listeners.onBeforeStep = onBeforeStep.bind(this);
                this._huiComponent.addEventListener("before-step", this._listeners.onBeforeStep);

                // Event handler for after-step
                var onAfterStep = function onAfterStep(event) {
                    if (_this2.props.onAfterStep) {
                        _this2.props.onAfterStep(event);
                    }
                };
                this._listeners.onAfterStep = onAfterStep.bind(this);
                this._huiComponent.addEventListener("after-step", this._listeners.onAfterStep);

                // Event handler for start-spinner
                var onStartSpinner = function onStartSpinner(event) {
                    if (_this2.props.onStartSpinner) {
                        _this2.props.onStartSpinner(event);
                    }
                };
                this._listeners.onStartSpinner = onStartSpinner.bind(this);
                this._huiComponent.addEventListener("start-spinner", this._listeners.onStartSpinner);

                // Event handler for stop-spinner
                var onStopSpinner = function onStopSpinner(event) {
                    if (_this2.props.onStopSpinner) {
                        _this2.props.onStopSpinner(event);
                    }
                };
                this._listeners.onStopSpinner = onStopSpinner.bind(this);
                this._huiComponent.addEventListener("stop-spinner", this._listeners.onStopSpinner);
            }
        }, {
            key: "componentDidUpdate",
            value: function componentDidUpdate(prevProps, prevState) {
                if (this.props.show !== prevProps.show) {
                    if (this.props.show) {
                        this._huiComponent.show();
                    } else {
                        this._huiComponent.close();
                    }
                }
            }
        }, {
            key: "componentWillUnmount",
            value: function componentWillUnmount() {
                this._huiComponent.removeEventListener("next", this._listeners.onNext, false);
                this._huiComponent.removeEventListener("previous", this._listeners.onPrevious, false);
                this._huiComponent.removeEventListener("done", this._listeners.onDone, false);
                this._huiComponent.removeEventListener("show", this._listeners.onShow, false);
                this._huiComponent.removeEventListener("close", this._listeners.onClose, false);
                this._huiComponent.removeEventListener("before-step", this._listeners.onBeforeStep, false);
                this._huiComponent.removeEventListener("after-step", this._listeners.onAfterStep, false);
                this._huiComponent.removeEventListener("start-spinner", this._listeners.onStartSpinner, false);
                this._huiComponent.removeEventListener("stop-spinner", this._listeners.onStopSpinner, false);
                this._huiComponent.removeEventListener("component-upgraded", this._listeners.componentUpgraded, false);
            }
        }, {
            key: "render",
            value: function render() {
                /* jshint ignore:start */
                return _react2.default.createElement(
                    "ha-step-flow",
                    _extends({
                        ref: this.handleRef,
                        "class": this.props.className
                    }, this.props),
                    this.props.children
                );
                /* jshint ignore:end */
            }
        }]);

        return HAStepFlow;
    }(_react2.default.Component);

    HAStepFlow.propTypes = {
        children: function anonymous(props, propName, componentName) {
            if (!props.allowAllChildren) {
                var error = (0, _utils.checkReactChildrenType)(props[propName], componentName, [_HAFlowStep2.default, _HAFlowLanding2.default, _HAFlowConfirmation2.default], "HAFlowStep,HAFlowLanding,HAFlowConfirmation");
                if (error) {
                    return error;
                }
            }
        },
        className: _react2.default.PropTypes.string,
        id: _react2.default.PropTypes.string,
        show: _react2.default.PropTypes.bool,
        currentStep: _react2.default.PropTypes.number,
        flow: _react2.default.PropTypes.string,
        progressIndicator: _react2.default.PropTypes.bool,
        startIndex: _react2.default.PropTypes.number,
        nextButtonText: _react2.default.PropTypes.string,
        previousButtonText: _react2.default.PropTypes.string,
        doneButtonText: _react2.default.PropTypes.string,
        landing: _react2.default.PropTypes.object,
        steps: _react2.default.PropTypes.array,
        confirmation: _react2.default.PropTypes.object,
        disableAutoComplete: _react2.default.PropTypes.bool,
        enableAnimateIn: _react2.default.PropTypes.bool,
        closeParentTrowser: _react2.default.PropTypes.bool,
        onNext: _react2.default.PropTypes.func,
        onPrevious: _react2.default.PropTypes.func,
        onDone: _react2.default.PropTypes.func,
        onShow: _react2.default.PropTypes.func,
        onClose: _react2.default.PropTypes.func,
        onBeforeStep: _react2.default.PropTypes.func,
        onAfterStep: _react2.default.PropTypes.func,
        onStartSpinner: _react2.default.PropTypes.func,
        onStopSpinner: _react2.default.PropTypes.func,
        allowAllChildren: _react2.default.PropTypes.bool,
        disableProgressIndicatorNavigation: _react2.default.PropTypes.bool
    };

    var _initialiseProps = function _initialiseProps() {
        var _this3 = this;

        this.handleRef = function (c) {
            _this3._huiComponent = c;
        };
    };

    exports.default = HAStepFlow;
});
//# sourceMappingURL=HAStepFlow.js.map
;
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

(function (global, factory) {
    if (typeof define === "function" && define.amd) {
        define('hui-react/HASwitchbutton',["exports", "react", "hui/switch-button"], factory);
    } else if (typeof exports !== "undefined") {
        factory(exports, require("react"), require("hui/switch-button"));
    } else {
        var mod = {
            exports: {}
        };
        factory(mod.exports, global.react, global.switchButton);
        global.HASwitchbutton = mod.exports;
    }
})(this, function (exports, _react) {
    "use strict";

    Object.defineProperty(exports, "__esModule", {
        value: true
    });

    var _react2 = _interopRequireDefault(_react);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }

    var _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];

            for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }

        return target;
    };

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }

    var _createClass = function () {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }

        return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();

    function _possibleConstructorReturn(self, call) {
        if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
    }

    function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }

    var HASwitchbutton = function (_React$Component) {
        _inherits(HASwitchbutton, _React$Component);

        function HASwitchbutton(props) {
            _classCallCheck(this, HASwitchbutton);

            var _this = _possibleConstructorReturn(this, (HASwitchbutton.__proto__ || Object.getPrototypeOf(HASwitchbutton)).call(this, props));

            _this.handleRef = function (c) {
                _this._huiComponent = c;
            };

            _this._huiComponent = null;
            _this._listeners = {};
            return _this;
        }

        _createClass(HASwitchbutton, [{
            key: "componentDidMount",
            value: function componentDidMount() {
                var _this2 = this;

                // With es6 syntax we have to bind the events to the react component instance
                // https://facebook.github.io/react/docs/reusable-components.html#no-autobinding
                // Event handler for change
                var onChange = function onChange(event) {
                    event.stopPropagation();
                    if (_this2.props.onChange) {
                        _this2.props.onChange(event);
                    }
                };
                this._listeners.onChange = onChange.bind(this);
                this._huiComponent.addEventListener("change", this._listeners.onChange);

                // Event handler for click
                var onClick = function onClick(event) {
                    event.stopPropagation();
                    if (_this2.props.onClick) {
                        _this2.props.onClick(event);
                    }
                };
                this._listeners.onClick = onClick.bind(this);
                this._huiComponent.addEventListener("click", this._listeners.onClick);
            }
        }, {
            key: "componentWillUnmount",
            value: function componentWillUnmount() {
                this._huiComponent.removeEventListener("change", this._listeners.onChange, false);
                this._huiComponent.removeEventListener("click", this._listeners.onClick, false);
            }
        }, {
            key: "render",
            value: function render() {
                /* jshint ignore:start */
                return _react2.default.createElement("ha-switch-button", _extends({ ref: this.handleRef }, this.props));
                /* jshint ignore:end */
            }
        }]);

        return HASwitchbutton;
    }(_react2.default.Component);

    HASwitchbutton.propTypes = {
        label: _react2.default.PropTypes.string,
        labelOn: _react2.default.PropTypes.string,
        labelOff: _react2.default.PropTypes.string,
        value: _react2.default.PropTypes.string,
        name: _react2.default.PropTypes.string,
        checked: _react2.default.PropTypes.bool,
        onChange: _react2.default.PropTypes.func,
        onClick: _react2.default.PropTypes.func
    };
    HASwitchbutton.defaultProps = {
        labelOn: " ",
        labelOff: " "
    };
    exports.default = HASwitchbutton;
});
//# sourceMappingURL=HASwitchbutton.js.map
;
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

(function (global, factory) {
    if (typeof define === "function" && define.amd) {
        define('hui-react/HATab',["exports", "react", "hui/tab"], factory);
    } else if (typeof exports !== "undefined") {
        factory(exports, require("react"), require("hui/tab"));
    } else {
        var mod = {
            exports: {}
        };
        factory(mod.exports, global.react, global.tab);
        global.HATab = mod.exports;
    }
})(this, function (exports, _react) {
    "use strict";

    Object.defineProperty(exports, "__esModule", {
        value: true
    });

    var _react2 = _interopRequireDefault(_react);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }

    var _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];

            for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }

        return target;
    };

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }

    var _createClass = function () {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }

        return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();

    function _possibleConstructorReturn(self, call) {
        if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
    }

    function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }

    var HATab = function (_React$Component) {
        _inherits(HATab, _React$Component);

        function HATab(props) {
            _classCallCheck(this, HATab);

            var _this = _possibleConstructorReturn(this, (HATab.__proto__ || Object.getPrototypeOf(HATab)).call(this, props));

            _this.handleRef = function (c) {
                _this._huiComponent = c;
            };

            _this._huiComponent = null;
            return _this;
        }

        _createClass(HATab, [{
            key: "componentDidMount",
            value: function componentDidMount() {
                // force web component pick up childNode one more time.
                this._huiComponent.postRender();
            }
        }, {
            key: "render",
            value: function render() {
                /* jshint ignore:start */
                return _react2.default.createElement(
                    "ha-tab",
                    _extends({ ref: this.handleRef }, this.props),
                    this.props.children
                );
                /* jshint ignore:end */
            }
        }]);

        return HATab;
    }(_react2.default.Component);

    HATab.propTypes = {
        className: _react2.default.PropTypes.string,
        titleText: _react2.default.PropTypes.string,
        icon: _react2.default.PropTypes.string,
        section: _react2.default.PropTypes.array,
        badgeClass: _react2.default.PropTypes.string,
        badgeText: _react2.default.PropTypes.string
    };
    exports.default = HATab;
});
//# sourceMappingURL=HATab.js.map
;
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

(function (global, factory) {
    if (typeof define === "function" && define.amd) {
        define('hui-react/HATabs',["exports", "react", "hui/tabs"], factory);
    } else if (typeof exports !== "undefined") {
        factory(exports, require("react"), require("hui/tabs"));
    } else {
        var mod = {
            exports: {}
        };
        factory(mod.exports, global.react, global.tabs);
        global.HATabs = mod.exports;
    }
})(this, function (exports, _react) {
    "use strict";

    Object.defineProperty(exports, "__esModule", {
        value: true
    });

    var _react2 = _interopRequireDefault(_react);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }

    var _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];

            for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }

        return target;
    };

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }

    var _createClass = function () {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }

        return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();

    function _possibleConstructorReturn(self, call) {
        if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
    }

    function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }

    var HATabs = function (_React$Component) {
        _inherits(HATabs, _React$Component);

        function HATabs(props) {
            _classCallCheck(this, HATabs);

            var _this = _possibleConstructorReturn(this, (HATabs.__proto__ || Object.getPrototypeOf(HATabs)).call(this, props));

            _this.handleRef = function (c) {
                _this._huiComponent = c;
            };

            _this._huiComponent = null;
            _this._listeners = {};
            return _this;
        }

        _createClass(HATabs, [{
            key: "componentDidMount",
            value: function componentDidMount() {
                var _this2 = this;

                // With es6 syntax we have to bind the events to the react component instance
                // https://facebook.github.io/react/docs/reusable-components.html#no-autobinding
                // Event handler for select
                var onSelect = function onSelect(event) {
                    event.stopPropagation();
                    if (_this2.props.onSelect) {
                        _this2.props.onSelect(event);
                    }
                };
                this._listeners.onSelect = onSelect.bind(this);
                this._huiComponent.addEventListener("select", this._listeners.onSelect);
                this.updateTabChildren();
            }
        }, {
            key: "componentWillUnmount",
            value: function componentWillUnmount() {
                this._huiComponent.removeEventListener("select", this._listeners.onSelect, false);
            }
        }, {
            key: "updateTabChildren",
            value: function updateTabChildren() {
                var tabChildren = this._huiComponent.querySelectorAll('ha-tab');

                if (tabChildren && tabChildren.length > 0) {
                    this._huiComponent.tabs = Array.prototype.slice.call(tabChildren);
                }
            }
        }, {
            key: "render",
            value: function render() {
                /* jshint ignore:start */
                return _react2.default.createElement(
                    "ha-tabs",
                    _extends({ ref: this.handleRef, "class": this.props.className }, this.props),
                    this.props.children
                );
                /* jshint ignore:end */
            }
        }]);

        return HATabs;
    }(_react2.default.Component);

    HATabs.propTypes = {
        className: _react2.default.PropTypes.string,
        selectedIndex: _react2.default.PropTypes.number,
        onSelect: _react2.default.PropTypes.func
    };
    exports.default = HATabs;
});
//# sourceMappingURL=HATabs.js.map
;
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

(function (global, factory) {
    if (typeof define === "function" && define.amd) {
        define('hui-react/HATextField',["exports", "react", "hui/core/utils", "hui/text-field"], factory);
    } else if (typeof exports !== "undefined") {
        factory(exports, require("react"), require("hui/core/utils"), require("hui/text-field"));
    } else {
        var mod = {
            exports: {}
        };
        factory(mod.exports, global.react, global.utils, global.textField);
        global.HATextField = mod.exports;
    }
})(this, function (exports, _react, _utils) {
    "use strict";

    Object.defineProperty(exports, "__esModule", {
        value: true
    });

    var _react2 = _interopRequireDefault(_react);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }

    var _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];

            for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }

        return target;
    };

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }

    var _createClass = function () {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }

        return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();

    function _possibleConstructorReturn(self, call) {
        if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
    }

    function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }

    var HATextField = function (_React$Component) {
        _inherits(HATextField, _React$Component);

        function HATextField(props) {
            _classCallCheck(this, HATextField);

            var _this = _possibleConstructorReturn(this, (HATextField.__proto__ || Object.getPrototypeOf(HATextField)).call(this, props));

            _this.handleRef = function (c) {
                _this._huiComponent = c;
            };

            _this._huiComponent = null;
            _this._listeners = {};
            _this.state = {
                classAttributes: null
            };
            return _this;
        }

        _createClass(HATextField, [{
            key: "testValidity",
            value: function testValidity() {
                if (this.props.onValidityChange) {
                    var valid = undefined;
                    if (this._huiComponent.checkValidity) {
                        valid = this._huiComponent.checkValidity();
                    }
                    if (this._lastValidity !== valid) {
                        this._lastValidity = valid;
                        this.props.onValidityChange(valid);
                    }
                }
            }
        }, {
            key: "componentDidMount",
            value: function componentDidMount() {
                var _this2 = this;

                // With es6 syntax we have to bind the events to the react component instance
                // https://facebook.github.io/react/docs/reusable-components.html#no-autobinding
                // Event handler for change
                var onChange = function onChange(event) {
                    event.stopPropagation();
                    if (_this2.props.onChange) {
                        _this2.props.onChange(event);
                    }
                };
                this._listeners.onChange = onChange.bind(this);
                this._huiComponent.addEventListener("change", this._listeners.onChange);

                // Event handler for input
                var onInput = function onInput(event) {
                    event.stopPropagation();
                    if (_this2.props.onInput) {
                        _this2.props.onInput(event);
                    }
                    _this2.testValidity();
                };
                this._listeners.onInput = onInput.bind(this);
                this._huiComponent.addEventListener("input", this._listeners.onInput);

                // Stop validation tooltip show event propagation
                var onShow = function onShow(event) {
                    event.stopPropagation();
                };
                this._listeners.onShow = onShow.bind(this);
                this._huiComponent.addEventListener("show", this._listeners.onShow);

                // Stop validation tooltip close event propagation
                var onClose = function onClose(event) {
                    event.stopPropagation();
                };
                this._listeners.onClose = onClose.bind(this);
                this._huiComponent.addEventListener("close", this._listeners.onClose);

                // Stop validation tooltip dismiss event propagation
                var onDismiss = function onDismiss(event) {
                    event.stopPropagation();
                };
                this._listeners.onDismiss = onDismiss.bind(this);
                this._huiComponent.addEventListener("dismiss", this._listeners.onDismiss);

                window.setTimeout(function () {
                    // We need the timeout so h-ui component checkValidity function is initialized
                    if (_this2._huiComponent && _this2.props.validator) {
                        _this2._huiComponent.validator = _this2.props.validator;
                    }
                    if (_this2.props.alwaysRenderValidity) {
                        _this2._huiComponent.reportValidity();
                    }
                    if (_this2.props.resetValidation) {
                        _this2._huiComponent.resetValidation();
                    }
                    _this2.testValidity(); // We need to do initial notification of validity state.
                }, 0);

                // merge pre-existing custom element classes with props
                if (this.props.className) {
                    this.updateElementClasses();
                }
            }
        }, {
            key: "updateElementClasses",
            value: function updateElementClasses(newProps) {
                var mergedClassString = undefined;
                if (newProps) {
                    mergedClassString = (0, _utils.updateClassWithProps)(this._huiComponent, newProps.className);
                } else {
                    mergedClassString = (0, _utils.updateClassWithProps)(this._huiComponent, this.props.className);
                }

                // re-render the element with addition / removal of props
                if (mergedClassString) {
                    this.setState({
                        classAttributes: mergedClassString
                    });
                }
            }
        }, {
            key: "componentWillReceiveProps",
            value: function componentWillReceiveProps(nextProps) {
                // ensure that H-UI supported classes on the element aren't erased on props change
                var existingClasses = this.state.classAttributes;
                if (existingClasses !== nextProps.className) {
                    this.updateElementClasses(nextProps);
                }
            }
        }, {
            key: "componentWillUnmount",
            value: function componentWillUnmount() {
                this._huiComponent.removeEventListener("change", this._listeners.onChange, false);
                this._huiComponent.removeEventListener("input", this._listeners.onInput, false);
                this._huiComponent.removeEventListener("show", this._listeners.onShow, false);
                this._huiComponent.removeEventListener("close", this._listeners.onClose, false);
                this._huiComponent.removeEventListener("dismiss", this._listeners.onDismiss, false);
                this._huiComponent.resetValidation();
            }
        }, {
            key: "componentDidUpdate",
            value: function componentDidUpdate() {
                if (this.props.validator) {
                    this._huiComponent.validator = this.props.validator;
                }
                this.testValidity();
                if (this.props.alwaysRenderValidity) {
                    this._huiComponent.reportValidity();
                }
                if (this.props.resetValidation) {
                    this._huiComponent.resetValidation();
                }
            }
        }, {
            key: "render",
            value: function render() {
                /* jshint ignore:start */
                return _react2.default.createElement(
                    "ha-text-field",
                    _extends({
                        ref: this.handleRef,
                        "class": this.state.classAttributes
                    }, this.props),
                    this.props.children
                );
                /* jshint ignore:end */
            }
        }]);

        return HATextField;
    }(_react2.default.Component);

    HATextField.propTypes = {
        className: _react2.default.PropTypes.string,
        disabled: _react2.default.PropTypes.bool,
        label: _react2.default.PropTypes.string,
        labelOptional: _react2.default.PropTypes.string,
        minLength: _react2.default.PropTypes.oneOfType([_react2.default.PropTypes.number, _react2.default.PropTypes.string]),
        maxLength: _react2.default.PropTypes.oneOfType([_react2.default.PropTypes.number, _react2.default.PropTypes.string]),
        name: _react2.default.PropTypes.string,
        optional: _react2.default.PropTypes.bool,
        placeholder: _react2.default.PropTypes.string,
        pattern: _react2.default.PropTypes.string,
        size: _react2.default.PropTypes.number,
        value: _react2.default.PropTypes.string,
        autoComplete: _react2.default.PropTypes.string,
        required: _react2.default.PropTypes.bool,
        noRequiredIndicator: _react2.default.PropTypes.bool,
        min: _react2.default.PropTypes.number,
        max: _react2.default.PropTypes.number,
        requiredMessage: _react2.default.PropTypes.string,
        invalidMessage: _react2.default.PropTypes.string,
        validator: _react2.default.PropTypes.func,
        onValidityChange: _react2.default.PropTypes.func,
        alwaysRenderValidity: _react2.default.PropTypes.bool,
        resetValidation: _react2.default.PropTypes.bool,
        onChange: _react2.default.PropTypes.func,
        onInput: _react2.default.PropTypes.func
    };
    exports.default = HATextField;
});
//# sourceMappingURL=HATextField.js.map
;
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

(function (global, factory) {
    if (typeof define === "function" && define.amd) {
        define('hui-react/HATextFieldTypeAhead',["exports", "react", "hui/core/utils", "hui/textfield-type-ahead"], factory);
    } else if (typeof exports !== "undefined") {
        factory(exports, require("react"), require("hui/core/utils"), require("hui/textfield-type-ahead"));
    } else {
        var mod = {
            exports: {}
        };
        factory(mod.exports, global.react, global.utils, global.textfieldTypeAhead);
        global.HATextFieldTypeAhead = mod.exports;
    }
})(this, function (exports, _react, _utils) {
    "use strict";

    Object.defineProperty(exports, "__esModule", {
        value: true
    });

    var _react2 = _interopRequireDefault(_react);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }

    var _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];

            for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }

        return target;
    };

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }

    var _createClass = function () {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }

        return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();

    function _possibleConstructorReturn(self, call) {
        if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
    }

    function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }

    function toStore(data) {
        return {
            query: function query() {
                return {
                    then: function then(callback) {
                        callback(data);
                    }
                };
            }
        };
    }

    function propsWithout(exludeList, props) {
        return Object.getOwnPropertyNames(props).reduce(function (newProps, propName) {
            if (exludeList.indexOf(propName) < 0) {
                newProps[propName] = props[propName];
            }
            return newProps;
        }, {});
    }

    function pluckSelectedItem(event) {
        var selectedItem = event.target.selectedItem;
        // for backward-compatibility
        event.selectedItem = selectedItem;

        return event;
    }

    var HATextFieldTypeAhead = function (_Component) {
        _inherits(HATextFieldTypeAhead, _Component);

        function HATextFieldTypeAhead(props) {
            _classCallCheck(this, HATextFieldTypeAhead);

            var _this = _possibleConstructorReturn(this, (HATextFieldTypeAhead.__proto__ || Object.getPrototypeOf(HATextFieldTypeAhead)).call(this, props));

            _this._huiComponent = null;
            _this._listeners = {};
            _this.state = {
                classAttributes: null
            };

            // Bind event handling methods to current instance
            _this.handleClick = _this.handleClick.bind(_this);
            _this.handleRef = _this.handleRef.bind(_this);
            return _this;
        }

        _createClass(HATextFieldTypeAhead, [{
            key: "componentDidMount",
            value: function componentDidMount() {
                var _this2 = this;

                // Event handler for change
                this._huiComponent.addEventListener("change", function (event) {
                    event.stopPropagation();
                    if (_this2.props.onChange) {
                        _this2.props.onChange(pluckSelectedItem(event));
                    }
                    _this2.testValidity();
                });

                // Invoked after the popover menu appears
                var onItemsShow = function onItemsShow(event) {
                    event.stopPropagation();
                    if (_this2.props.onItemsShow) {
                        _this2.props.onItemsShow(event);
                    }
                };
                this._listeners.onItemsShow = onItemsShow.bind(this);
                this._huiComponent.addEventListener("items-show", this._listeners.onItemsShow);

                // Invoked after the popover menu is dismissed
                var onItemsClose = function onItemsClose(event) {
                    event.stopPropagation();
                    if (_this2.props.onItemsClose) {
                        _this2.props.onItemsClose(event);
                    }
                };
                this._listeners.onItemsClose = onItemsClose.bind(this);
                this._huiComponent.addEventListener("items-close", this._listeners.onItemsClose);

                this.domElementPostRender();

                window.setTimeout(function () {
                    // We need the timeout so h-ui component checkValidity function is initialized
                    if (_this2.props.validator) {
                        _this2._huiComponent.validator = _this2.props.validator;
                    }
                    if (_this2.props.alwaysRenderValidity) {
                        _this2._huiComponent.reportValidity();
                    }
                    if (_this2.props.resetValidation) {
                        _this2._huiComponent.resetValidation();
                    }
                    _this2.testValidity(); // We need to do initial notification of validity state.
                }, 0);

                if (this.props.className) {
                    this.updateElementClasses();
                }
            }
        }, {
            key: "componentWillReceiveProps",
            value: function componentWillReceiveProps(nextProps) {
                // ensure that H-UI supported classes on the element aren't erased on props change
                var existingClasses = this.state.classAttributes;
                if (existingClasses !== nextProps.className) {
                    this.updateElementClasses(nextProps);
                }
            }
        }, {
            key: "componentDidUpdate",
            value: function componentDidUpdate() {
                if (this.props.validator) {
                    this._huiComponent.validator = this.props.validator;
                }
                this.testValidity();
                if (this.props.alwaysRenderValidity) {
                    this._huiComponent.reportValidity();
                }
                if (this.props.resetValidation) {
                    this._huiComponent.resetValidation();
                }
                this.domElementPostRender();
            }
        }, {
            key: "componentWillUnmount",
            value: function componentWillUnmount() {
                this._huiComponent.removeEventListener("change", null, false);
                this._huiComponent.removeEventListener("items-show", this._listeners.onItemsShow, false);
                this._huiComponent.removeEventListener("items-close", this._listeners.onItemsClose, false);
                this._huiComponent.resetValidation();
            }
        }, {
            key: "updateElementClasses",
            value: function updateElementClasses(newProps) {
                var mergedClassString = undefined;
                if (newProps) {
                    mergedClassString = (0, _utils.updateClassWithProps)(this._huiComponent, newProps.className);
                } else {
                    mergedClassString = (0, _utils.updateClassWithProps)(this._huiComponent, this.props.className);
                }

                // re-render the element with addition / removal of props
                if (mergedClassString) {
                    this.setState({
                        classAttributes: mergedClassString
                    });
                }
            }
        }, {
            key: "testValidity",
            value: function testValidity() {
                if (this.props.onValidityChange) {
                    var valid = undefined;
                    if (this._huiComponent.checkValidity) {
                        valid = this._huiComponent.checkValidity();
                    }
                    if (this._lastValidity !== valid) {
                        this._lastValidity = valid;
                        this.props.onValidityChange(valid);
                    }
                }
            }
        }, {
            key: "handleClick",
            value: function handleClick(event) {
                if (this.props.onClick) {
                    this.props.onClick(event);
                }
            }
        }, {
            key: "handleRef",
            value: function handleRef(c) {
                this._huiComponent = c;
                // connect the itemRenderer property to the component.
                if (this._huiComponent && this.props && this.props.itemRenderer) {
                    this._huiComponent.itemRenderer = this.props.itemRenderer;
                }
            }
        }, {
            key: "getStore",
            value: function getStore() {
                var _props = this.props,
                    store = _props.store,
                    data = _props.data,
                    huiComponent = this._huiComponent;

                if (store) {
                    return store;
                } else if (data) {
                    if (this._currentData === data) {
                        // If data has not changed return the current store
                        return huiComponent.store;
                    } else {
                        this._currentData = data;
                        return toStore(data);
                    }
                } else {
                    return toStore([]);
                }
            }
        }, {
            key: "updatePopoverForm",
            value: function updatePopoverForm() {
                var popoverForm = this._huiComponent.querySelector("ha-popover-form");

                if (popoverForm && popoverForm.parentNode) {
                    this._huiComponent.addNewPopover = popoverForm.parentNode;
                } else {
                    if (!this._huiComponent.addNewPopover) {
                        console.error("No popover-form defined. Please provide the correct popover and popover-form structure.");
                    }
                }
            }
        }, {
            key: "domElementPostRender",
            value: function domElementPostRender() {
                var _props2 = this.props,
                    value = _props2.value,
                    selectedIndex = _props2.selectedIndex,
                    huiComponent = this._huiComponent,
                    newStore = this.getStore();

                if (this.props.addNew === true || this.props.addNew === "true") {
                    this.updatePopoverForm();
                }

                // Don't set the store if it is the same as the current store
                if (newStore !== huiComponent.store) {
                    huiComponent.store = newStore;
                }

                if (value && value !== huiComponent.value) {
                    // After the store is set, we need to set the value again
                    huiComponent.value = this.props.value;
                    // And then we remove 'menu-expanded' to make sure the popover remains closed.
                    huiComponent.classList.remove("menu-expanded");
                }

                if (selectedIndex && selectedIndex !== huiComponent.selectedIndex) {
                    // After the store is set, we need to set the selectedIndex again
                    huiComponent.selectedIndex = this.props.selectedIndex;
                }
            }
        }, {
            key: "hasStaticItems",
            value: function hasStaticItems() {
                var _props3 = this.props,
                    staticItems = _props3.staticItems,
                    store = _props3.store,
                    data = _props3.data;

                return !!(staticItems || data && !store);
            }
        }, {
            key: "render",
            value: function render() {
                var excludeProps = ["data", "store", "ref", "key"];
                // workaround for IE 11, ref: https://github.com/facebook/react/issues/961
                if (this.props.disabled === false || this.props.disabled === "false") {
                    excludeProps.push("disabled");
                }
                var props = propsWithout(excludeProps, this.props);
                /* jshint ignore:start */
                return _react2.default.createElement(
                    "ha-textfield-type-ahead",
                    _extends({
                        ref: this.handleRef,
                        "class": this.state.classAttributes,
                        onClick: this.handleClick,
                        staticItems: this.hasStaticItems()
                    }, props),
                    this.props.children
                );
                /* jshint ignore:end */
            }
        }]);

        return HATextFieldTypeAhead;
    }(_react.Component);

    HATextFieldTypeAhead.propTypes = {
        className: _react2.default.PropTypes.string,
        mobileMenuClass: _react2.default.PropTypes.oneOfType([_react2.default.PropTypes.array, _react2.default.PropTypes.string]),
        label: _react2.default.PropTypes.string,
        placeholder: _react2.default.PropTypes.string,
        icon: _react2.default.PropTypes.string,
        name: _react2.default.PropTypes.string,
        value: _react2.default.PropTypes.string,
        typedText: _react2.default.PropTypes.string,
        size: _react2.default.PropTypes.number,
        disabled: _react2.default.PropTypes.bool,
        required: _react2.default.PropTypes.bool,
        noRequiredIndicator: _react2.default.PropTypes.bool,
        selectedIndex: _react2.default.PropTypes.number,
        selectedItem: _react2.default.PropTypes.object,
        filterMode: _react2.default.PropTypes.string,
        store: _react2.default.PropTypes.object,
        storeLabelProperty: _react2.default.PropTypes.string,
        storeValueProperty: _react2.default.PropTypes.string,
        staticItems: _react2.default.PropTypes.bool,
        addNew: _react2.default.PropTypes.oneOfType([_react2.default.PropTypes.bool, _react2.default.PropTypes.string]),
        addNewText: _react2.default.PropTypes.string,
        min: _react2.default.PropTypes.number,
        max: _react2.default.PropTypes.number,
        requiredMessage: _react2.default.PropTypes.string,
        invalidMessage: _react2.default.PropTypes.string,
        validator: _react2.default.PropTypes.func,
        onValidityChange: _react2.default.PropTypes.func,
        alwaysRenderValidity: _react2.default.PropTypes.bool,
        resetValidation: _react2.default.PropTypes.bool,
        autoComplete: _react2.default.PropTypes.string,
        onClick: _react2.default.PropTypes.func,
        onChange: _react2.default.PropTypes.func,
        onItemsShow: _react2.default.PropTypes.func,
        onItemsClose: _react2.default.PropTypes.func,
        data: _react2.default.PropTypes.array,
        children: _react2.default.PropTypes.element,
        itemRenderer: _react2.default.PropTypes.func
    };
    exports.default = HATextFieldTypeAhead;
});
//# sourceMappingURL=HATextFieldTypeAhead.js.map
;
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

(function (global, factory) {
    if (typeof define === "function" && define.amd) {
        define('hui-react/HATextarea',["exports", "react", "hui/core/utils", "hui/textarea"], factory);
    } else if (typeof exports !== "undefined") {
        factory(exports, require("react"), require("hui/core/utils"), require("hui/textarea"));
    } else {
        var mod = {
            exports: {}
        };
        factory(mod.exports, global.react, global.utils, global.textarea);
        global.HATextarea = mod.exports;
    }
})(this, function (exports, _react, _utils) {
    "use strict";

    Object.defineProperty(exports, "__esModule", {
        value: true
    });

    var _react2 = _interopRequireDefault(_react);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }

    var _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];

            for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }

        return target;
    };

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }

    var _createClass = function () {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }

        return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();

    function _possibleConstructorReturn(self, call) {
        if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
    }

    function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }

    var HATextarea = function (_React$Component) {
        _inherits(HATextarea, _React$Component);

        function HATextarea(props) {
            _classCallCheck(this, HATextarea);

            var _this = _possibleConstructorReturn(this, (HATextarea.__proto__ || Object.getPrototypeOf(HATextarea)).call(this, props));

            _this.handleRef = function (c) {
                _this._huiComponent = c;
            };

            _this._huiComponent = null;
            _this._listeners = {};
            _this.state = {
                classAttributes: null
            };
            return _this;
        }

        _createClass(HATextarea, [{
            key: "testValidity",
            value: function testValidity() {
                if (this.props.onValidityChange) {
                    var valid = undefined;
                    if (this._huiComponent.checkValidity) {
                        valid = this._huiComponent.checkValidity();
                    }
                    if (this._lastValidity !== valid) {
                        this._lastValidity = valid;
                        this.props.onValidityChange(valid);
                    }
                }
            }
        }, {
            key: "componentDidMount",
            value: function componentDidMount() {
                var _this2 = this;

                // With es6 syntax we have to bind the events to the react component instance
                // https://facebook.github.io/react/docs/reusable-components.html#no-autobinding
                // Event handler for change
                var onChange = function onChange(event) {
                    event.stopPropagation();
                    if (_this2.props.onChange) {
                        _this2.props.onChange(event);
                    }
                };
                this._listeners.onChange = onChange.bind(this);
                this._huiComponent.addEventListener("change", this._listeners.onChange);

                // Event handler for input
                var onInput = function onInput(event) {
                    event.stopPropagation();
                    if (_this2.props.onInput) {
                        _this2.props.onInput(event);
                    }
                    _this2.testValidity();
                };
                this._listeners.onInput = onInput.bind(this);
                this._huiComponent.addEventListener("input", this._listeners.onInput);

                // Stop validation tooltip show event propagation
                var onShow = function onShow(event) {
                    event.stopPropagation();
                };
                this._listeners.onShow = onShow.bind(this);
                this._huiComponent.addEventListener("show", this._listeners.onShow);

                // Stop validation tooltip close event propagation
                var onClose = function onClose(event) {
                    event.stopPropagation();
                };
                this._listeners.onClose = onClose.bind(this);
                this._huiComponent.addEventListener("close", this._listeners.onClose);

                // Stop validation tooltip dismiss event propagation
                var onDismiss = function onDismiss(event) {
                    event.stopPropagation();
                };
                this._listeners.onDismiss = onDismiss.bind(this);
                this._huiComponent.addEventListener("dismiss", this._listeners.onDismiss);

                window.setTimeout(function () {
                    // We need the timeout so h-ui component checkValidity function is initialized
                    if (_this2.props.validator) {
                        _this2._huiComponent.validator = _this2.props.validator;
                    }
                    if (_this2.props.alwaysRenderValidity) {
                        _this2._huiComponent.reportValidity();
                    }
                    if (_this2.props.resetValidation) {
                        _this2._huiComponent.resetValidation();
                    }
                    _this2.testValidity(); // We need to do initial notification of validity state.
                }, 0);

                // merge pre-existing custom element classes with props
                if (this.props.className) {
                    this.updateElementClasses();
                }
            }
        }, {
            key: "updateElementClasses",
            value: function updateElementClasses() {
                var mergedClassString = (0, _utils.updateClassWithProps)(this._huiComponent, this.props.className);
                if (mergedClassString) {
                    this.setState({
                        classAttributes: mergedClassString
                    });
                }
            }
        }, {
            key: "componentWillUnmount",
            value: function componentWillUnmount() {
                this._huiComponent.removeEventListener("change", this._listeners.onChange, false);
                this._huiComponent.removeEventListener("input", this._listeners.onInput, false);
                this._huiComponent.removeEventListener("show", this._listeners.onShow, false);
                this._huiComponent.removeEventListener("close", this._listeners.onClose, false);
                this._huiComponent.removeEventListener("dismiss", this._listeners.onDismiss, false);
                this._huiComponent.resetValidation();
            }
        }, {
            key: "componentDidUpdate",
            value: function componentDidUpdate() {
                if (this.props.validator) {
                    this._huiComponent.validator = this.props.validator;
                }
                this.testValidity();
                if (this.props.alwaysRenderValidity) {
                    this._huiComponent.reportValidity();
                }
                if (this.props.resetValidation) {
                    this._huiComponent.resetValidation();
                }
            }
        }, {
            key: "render",
            value: function render() {
                /* jshint ignore:start */
                return _react2.default.createElement(
                    "ha-textarea",
                    _extends({ ref: this.handleRef, "class": this.state.classAttributes }, this.props),
                    this.props.children
                );
                /* jshint ignore:end */
            }
        }]);

        return HATextarea;
    }(_react2.default.Component);

    HATextarea.propTypes = {
        className: _react2.default.PropTypes.string,
        cols: _react2.default.PropTypes.number,
        disabled: _react2.default.PropTypes.bool,
        label: _react2.default.PropTypes.string,
        labelOptional: _react2.default.PropTypes.string,
        minLength: _react2.default.PropTypes.oneOfType([_react2.default.PropTypes.number, _react2.default.PropTypes.string]),
        maxLength: _react2.default.PropTypes.oneOfType([_react2.default.PropTypes.number, _react2.default.PropTypes.string]),
        name: _react2.default.PropTypes.string,
        optional: _react2.default.PropTypes.bool,
        pattern: _react2.default.PropTypes.string,
        placeholder: _react2.default.PropTypes.string,
        readOnly: _react2.default.PropTypes.bool,
        rows: _react2.default.PropTypes.number,
        value: _react2.default.PropTypes.string,
        required: _react2.default.PropTypes.bool,
        noRequiredIndicator: _react2.default.PropTypes.bool,
        min: _react2.default.PropTypes.number,
        max: _react2.default.PropTypes.number,
        requiredMessage: _react2.default.PropTypes.string,
        invalidMessage: _react2.default.PropTypes.string,
        validator: _react2.default.PropTypes.func,
        onValidityChange: _react2.default.PropTypes.func,
        alwaysRenderValidity: _react2.default.PropTypes.bool,
        resetValidation: _react2.default.PropTypes.bool,
        onChange: _react2.default.PropTypes.func,
        onInput: _react2.default.PropTypes.func
    };
    exports.default = HATextarea;
});
//# sourceMappingURL=HATextarea.js.map
;
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

(function (global, factory) {
    if (typeof define === "function" && define.amd) {
        define('hui-react/HAToastMessage',["exports", "react", "react-dom", "hui/toast-message"], factory);
    } else if (typeof exports !== "undefined") {
        factory(exports, require("react"), require("react-dom"), require("hui/toast-message"));
    } else {
        var mod = {
            exports: {}
        };
        factory(mod.exports, global.react, global.reactDom, global.toastMessage);
        global.HAToastMessage = mod.exports;
    }
})(this, function (exports, _react, _reactDom) {
    "use strict";

    Object.defineProperty(exports, "__esModule", {
        value: true
    });

    var _react2 = _interopRequireDefault(_react);

    var _reactDom2 = _interopRequireDefault(_reactDom);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }

    var _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];

            for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }

        return target;
    };

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }

    var _createClass = function () {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }

        return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();

    function _possibleConstructorReturn(self, call) {
        if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
    }

    function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }

    var HAToastMessage = function (_React$Component) {
        _inherits(HAToastMessage, _React$Component);

        function HAToastMessage(props) {
            _classCallCheck(this, HAToastMessage);

            var _this = _possibleConstructorReturn(this, (HAToastMessage.__proto__ || Object.getPrototypeOf(HAToastMessage)).call(this, props));

            _this.handleRef = function (c) {
                _this._huiComponent = c;
            };

            _this._huiComponent = null;
            // keep track if we have set any event listeners on modal
            _this._listeners = {};
            return _this;
        }

        _createClass(HAToastMessage, [{
            key: "removeWebRenderComp",
            value: function removeWebRenderComp() {
                var wrapper = this._huiComponent.querySelectorAll('.toast-wrapper');
                if (wrapper && wrapper.length > 1) {
                    this._huiComponent.removeChild(wrapper[0]);
                }
            }
        }, {
            key: "componentDidMount",
            value: function componentDidMount() {
                this.setupListeners();
                if (this.props.show) {
                    this._huiComponent.show();
                }
                this.removeWebRenderComp();
            }
        }, {
            key: "componentDidUpdate",
            value: function componentDidUpdate(prevProps, prevState) {
                if (this.props.show !== prevProps.show) {
                    if (this.props.show) {
                        this._huiComponent.show();
                    } else if (this.props.duration <= 0) {
                        // only allow closing toasts that don't have a timout set
                        this._huiComponent.close();
                    }
                }
            }
        }, {
            key: "componentWillUnmount",
            value: function componentWillUnmount() {
                this._huiComponent.removeEventListener("show", this._listeners.onShow, false); // clean up show listener
                this._huiComponent.removeEventListener("close", this._listeners.onClose, false); // clean up close listener
                this._huiComponent.removeEventListener("dismiss", this._listeners.onDismiss, false); // clean up dismiss listener
            }
        }, {
            key: "setupListeners",
            value: function setupListeners() {
                var _this2 = this;

                var onShow = function onShow(event) {
                    event.stopPropagation();
                    if (_this2.props.onShow) {
                        _this2.props.onShow(event);
                    }
                };
                this._listeners.onShow = onShow.bind(this);
                this._huiComponent.addEventListener("show", this._listeners.onShow);

                var onClose = function onClose(event) {
                    event.stopPropagation();
                    _this2.props.onClose(event);
                };
                this._listeners.onClose = onClose.bind(this);
                this._huiComponent.addEventListener("close", this._listeners.onClose);

                var onDismiss = function onDismiss(event) {
                    event.stopPropagation();
                    if (_this2.props.onDismiss) {
                        _this2.props.onDismiss(event);
                    }
                };
                this._listeners.onDismiss = onDismiss.bind(this);
                this._huiComponent.addEventListener("dismiss", this._listeners.onDismiss);
            }
        }, {
            key: "render",
            value: function render() {
                /* jshint ignore:start */
                return _react2.default.createElement(
                    "ha-toast-message",
                    _extends({
                        ref: this.handleRef,
                        "class": this.props.className
                    }, this.props),
                    _react2.default.createElement(
                        "div",
                        { className: "toast-wrapper" },
                        _react2.default.createElement("button", { "aria-label": "Close", className: "hi hi-close" }),
                        _react2.default.createElement("i", { className: "hi hi-confirm hi-circle-check" }),
                        _react2.default.createElement(
                            "p",
                            null,
                            this.props.children
                        )
                    )
                );
                /* jshint ignore:end */
            }
        }]);

        return HAToastMessage;
    }(_react2.default.Component);

    HAToastMessage.propTypes = {
        duration: _react2.default.PropTypes.oneOfType([_react2.default.PropTypes.number, _react2.default.PropTypes.string]),
        dismissible: _react2.default.PropTypes.bool,
        show: _react2.default.PropTypes.bool,
        onShow: _react2.default.PropTypes.func,
        onClose: _react2.default.PropTypes.func.isRequired, // used to set parent's state of show back to false
        onDismiss: _react2.default.PropTypes.func
    };
    exports.default = HAToastMessage;
});
//# sourceMappingURL=HAToastMessage.js.map
;
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

(function (global, factory) {
    if (typeof define === "function" && define.amd) {
        define('hui-react/HATooltip',["exports", "react", "react-dom", "hui/tooltip"], factory);
    } else if (typeof exports !== "undefined") {
        factory(exports, require("react"), require("react-dom"), require("hui/tooltip"));
    } else {
        var mod = {
            exports: {}
        };
        factory(mod.exports, global.react, global.reactDom, global.tooltip);
        global.HATooltip = mod.exports;
    }
})(this, function (exports, _react, _reactDom) {
    "use strict";

    Object.defineProperty(exports, "__esModule", {
        value: true
    });

    var _react2 = _interopRequireDefault(_react);

    var _reactDom2 = _interopRequireDefault(_reactDom);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }

    var _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];

            for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }

        return target;
    };

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }

    var _createClass = function () {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }

        return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();

    function _possibleConstructorReturn(self, call) {
        if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
    }

    function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }

    var HATooltip = function (_React$Component) {
        _inherits(HATooltip, _React$Component);

        function HATooltip(props) {
            _classCallCheck(this, HATooltip);

            var _this = _possibleConstructorReturn(this, (HATooltip.__proto__ || Object.getPrototypeOf(HATooltip)).call(this, props));

            _this.handleRef = function (c) {
                _this._huiComponent = c;
            };

            _this._huiComponent = null;
            // keep track if we have set any event listeners on modal
            _this._listeners = {};
            return _this;
        }

        _createClass(HATooltip, [{
            key: "componentDidMount",
            value: function componentDidMount() {
                var _this2 = this;

                // update web components from react rendered components
                this.updateWebComponent();

                var onShow = function onShow(event) {
                    event.stopPropagation();
                    if (_this2.props.onShow) {
                        _this2.props.onShow(event);
                    }
                };
                this._listeners.onShow = onShow.bind(this);
                this._huiComponent.addEventListener("show", this._listeners.onShow);

                var onClose = function onClose(event) {
                    event.stopPropagation();
                    if (_this2.props.onClose) {
                        _this2.props.onClose(event);
                    }
                };
                this._listeners.onClose = onClose.bind(this);
                this._huiComponent.addEventListener("close", this._listeners.onClose);

                var onDismiss = function onDismiss(event) {
                    event.stopPropagation();
                    if (_this2.props.onDismiss) {
                        _this2.props.onDismiss(event);
                    }
                };
                this._listeners.onDismiss = onDismiss.bind(this);
                this._huiComponent.addEventListener("dismiss", this._listeners.onDismiss);
            }
        }, {
            key: "componentWillUnmount",
            value: function componentWillUnmount() {
                this._huiComponent.removeEventListener("show", this._listeners.onShow, false); // clean up show listener
                this._huiComponent.removeEventListener("close", this._listeners.onClose, false); // clean up close listener
                this._huiComponent.removeEventListener("dismiss", this._listeners.onDismiss, false); // clean up dismiss listener
            }
        }, {
            key: "updateWebComponent",
            value: function updateWebComponent() {
                var container = this._huiComponent.querySelectorAll(".tooltip-container");
                if (container && container.length > 1) {
                    this._huiComponent.message = Array.prototype.slice.call(container[1].childNodes);
                    this._huiComponent.removeChild(container[1]);
                }
            }
        }, {
            key: "render",
            value: function render() {
                /* jshint ignore:start */
                return _react2.default.createElement(
                    "ha-tooltip",
                    _extends({
                        ref: this.handleRef,
                        "class": this.props.className
                    }, this.props),
                    _react2.default.createElement(
                        "div",
                        { className: "tooltip-container" },
                        this.props.children
                    )
                );
                /* jshint ignore:end */
            }
        }]);

        return HATooltip;
    }(_react2.default.Component);

    HATooltip.propTypes = {
        className: _react2.default.PropTypes.string,
        targetSelector: _react2.default.PropTypes.string,
        position: _react2.default.PropTypes.string,
        dismissible: _react2.default.PropTypes.bool,
        trigger: _react2.default.PropTypes.string,
        duration: _react2.default.PropTypes.number,
        onShow: _react2.default.PropTypes.func,
        onClose: _react2.default.PropTypes.func,
        onDismiss: _react2.default.PropTypes.func
    };
    exports.default = HATooltip;
});
//# sourceMappingURL=HATooltip.js.map
;
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

(function (global, factory) {
    if (typeof define === "function" && define.amd) {
        define('hui-react/HATrowserFooter',["exports", "react"], factory);
    } else if (typeof exports !== "undefined") {
        factory(exports, require("react"));
    } else {
        var mod = {
            exports: {}
        };
        factory(mod.exports, global.react);
        global.HATrowserFooter = mod.exports;
    }
})(this, function (exports, _react) {
    "use strict";

    Object.defineProperty(exports, "__esModule", {
        value: true
    });

    var _react2 = _interopRequireDefault(_react);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }

    var _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];

            for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }

        return target;
    };

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }

    var _createClass = function () {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }

        return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();

    function _possibleConstructorReturn(self, call) {
        if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
    }

    function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }

    var HATrowserFooter = function (_React$Component) {
        _inherits(HATrowserFooter, _React$Component);

        function HATrowserFooter(props) {
            _classCallCheck(this, HATrowserFooter);

            return _possibleConstructorReturn(this, (HATrowserFooter.__proto__ || Object.getPrototypeOf(HATrowserFooter)).call(this, props));
        }

        _createClass(HATrowserFooter, [{
            key: "render",
            value: function render() {
                /* jshint ignore:start */
                return _react2.default.createElement(
                    "footer",
                    _extends({ className: "page-modal-footer", tabIndex: "-1" }, this.props),
                    this.props.children
                );
                /* jshint ignore:end */
            }
        }]);

        return HATrowserFooter;
    }(_react2.default.Component);

    exports.default = HATrowserFooter;
});
//# sourceMappingURL=HATrowserFooter.js.map
;
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

(function (global, factory) {
    if (typeof define === "function" && define.amd) {
        define('hui-react/HATrowser',["exports", "react", "./HAPortal", "./HASection", "./HATrowserFooter", "hui/core/utils", "hui/trowser/page-modal", "hui/trowser/page-modal-header", "hui/trowser/page-modal-footer", "hui/trowser/page-modal-header-item"], factory);
    } else if (typeof exports !== "undefined") {
        factory(exports, require("react"), require("./HAPortal"), require("./HASection"), require("./HATrowserFooter"), require("hui/core/utils"), require("hui/trowser/page-modal"), require("hui/trowser/page-modal-header"), require("hui/trowser/page-modal-footer"), require("hui/trowser/page-modal-header-item"));
    } else {
        var mod = {
            exports: {}
        };
        factory(mod.exports, global.react, global.HAPortal, global.HASection, global.HATrowserFooter, global.utils, global.pageModal, global.pageModalHeader, global.pageModalFooter, global.pageModalHeaderItem);
        global.HATrowser = mod.exports;
    }
})(this, function (exports, _react, _HAPortal, _HASection, _HATrowserFooter, _utils) {
    "use strict";

    Object.defineProperty(exports, "__esModule", {
        value: true
    });

    var _react2 = _interopRequireDefault(_react);

    var _HAPortal2 = _interopRequireDefault(_HAPortal);

    var _HASection2 = _interopRequireDefault(_HASection);

    var _HATrowserFooter2 = _interopRequireDefault(_HATrowserFooter);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }

    var _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];

            for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }

        return target;
    };

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }

    var _createClass = function () {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }

        return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();

    function _possibleConstructorReturn(self, call) {
        if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
    }

    function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }

    var HATrowser = function (_React$Component) {
        _inherits(HATrowser, _React$Component);

        function HATrowser(props) {
            _classCallCheck(this, HATrowser);

            var _this = _possibleConstructorReturn(this, (HATrowser.__proto__ || Object.getPrototypeOf(HATrowser)).call(this, props));

            _initialiseProps.call(_this);

            _this._trowser = null; // trowser DOM reference, set after render()
            // keep track if we have set any event listeners on trowser
            _this._listeners = {};
            _this.showModal = props.show;

            _this.state = {
                classAttributes: null
            };
            return _this;
        }

        // check that the only children passed to this component are a HASection, or HATrowserFooter

        _createClass(HATrowser, [{
            key: "componentDidMount",
            value: function componentDidMount() {
                var _this2 = this;

                if (this._trowser) {
                    this.removeWebRenderComp();
                    this.setState(function () {
                        _this2.showModal = _this2.props.show;
                    });
                }
                this.mountTrowser();
            }
        }, {
            key: "componentDidUpdate",
            value: function componentDidUpdate(prevProps) {
                this.mountTrowser(prevProps);
            }
        }, {
            key: "mountTrowser",
            value: function mountTrowser() {
                var _this3 = this;

                var prevProps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

                if (this._trowser && this.props.show !== prevProps.show) {
                    if (this.props.show) {
                        this.setupListeners();

                        // handle showing trowser
                        if (this.state.classAttributes !== this.props.className) {
                            this._trowser.classList.remove('hidden');
                            this.updateElementClasses();
                        }

                        if (this._trowser.show) {
                            this._trowser.show();
                        } else {
                            // on browsers that doesn't support custom elements natively,
                            // the component is not upgraded yet so show is not available, wait for event
                            var componentUpgraded = function componentUpgraded(event) {
                                event.stopPropagation();
                                _this3._trowser.show();
                            };
                            this._listeners.componentUpgraded = componentUpgraded.bind(this);
                            this._trowser.addEventListener("component-upgraded", this._listeners.componentUpgraded);
                        }
                    } else if (prevProps.show) {
                        this._trowser.close(); // remove trowser from DOM using hui/trowser

                        // handle className props being passed to custom element
                        if (this.props.className !== prevProps.className) {
                            this.updateElementClasses();
                        }
                    }
                }
            }
        }, {
            key: "updateElementClasses",
            value: function updateElementClasses() {
                var mergedClassString = (0, _utils.updateClassWithProps)(this._trowser, this.props.className);
                if (mergedClassString) {
                    this.setState({
                        classAttributes: mergedClassString
                    });
                }
            }
        }, {
            key: "removeWebRenderComp",
            value: function removeWebRenderComp() {
                var headerLeft = undefined,
                    headerCenter = undefined,
                    headerRight = undefined,
                    pageModal = undefined,
                    header = undefined,
                    pageModalChildren = this._trowser.querySelectorAll('.page-modal-panel');

                if (pageModalChildren && pageModalChildren.length > 1) {
                    this._trowser.removeChild(pageModalChildren[0]);
                    pageModal = pageModalChildren[1];
                    header = pageModal.querySelector('ha-page-modal-header');
                    headerLeft = header.querySelectorAll('ha-page-modal-header > span.header-left');
                    headerCenter = header.querySelectorAll('ha-page-modal-header > span.header-center');
                    headerRight = header.querySelectorAll('ha-page-modal-header > span.header-right');
                    this.removeDuplicateChild(header, headerLeft);
                    this.removeDuplicateChild(header, headerCenter);
                    this.removeDuplicateChild(header, headerRight);
                    this.removeDuplicateHeaderItem(headerLeft);
                    this.removeDuplicateHeaderItem(headerCenter);
                    this.removeDuplicateHeaderItem(headerRight);
                }
            }
        }, {
            key: "removeDuplicateChild",
            value: function removeDuplicateChild(component, children) {
                if (component && children && children.length > 1) {
                    component.removeChild(children[0]);
                }
            }
        }, {
            key: "removeDuplicateHeaderItem",
            value: function removeDuplicateHeaderItem(component) {
                var _this4 = this;

                if (component && component.length > 1) {
                    var headerItems = Array.prototype.slice.call(component[1].querySelectorAll('ha-page-modal-header-item'));
                    headerItems.forEach(function (item) {
                        var headerBtn = item.querySelectorAll('button');
                        _this4.removeDuplicateChild(item, headerBtn);
                    });
                }
            }
        }, {
            key: "setupListeners",
            value: function setupListeners() {
                var _this5 = this;

                if (Object.keys(this._listeners).length === 0) {
                    var onShow = function onShow(event) {
                        event.stopPropagation();
                        if (_this5.props.onShow) {
                            _this5.props.onShow(event);
                        }
                    };
                    this._listeners.onShow = onShow.bind(this);
                    this._trowser.addEventListener("show", this._listeners.onShow);

                    var onClose = function onClose(event) {
                        event.stopPropagation();
                        if (_this5.props.onClose) {
                            _this5.props.onClose(event);
                        }
                        _this5.cleanUpListeners();
                    };
                    this._listeners.onClose = onClose.bind(this);
                    this._trowser.addEventListener("close", this._listeners.onClose);

                    var onDismiss = function onDismiss(event) {
                        event.stopPropagation();
                        if (_this5.props.onDismiss) {
                            _this5.props.onDismiss(event);
                        }
                    };
                    this._listeners.onDismiss = onDismiss.bind(this);
                    this._trowser.addEventListener("dismiss", this._listeners.onDismiss);
                }
            }
        }, {
            key: "componentWillUnmount",
            value: function componentWillUnmount() {
                // we might need a unmountPortal here depending on how applications handle dom rendering & routing
                this.cleanUpListeners();
            }
        }, {
            key: "cleanUpListeners",
            value: function cleanUpListeners() {
                // if we do not have a _modal then HAUnderlay destroys the event listeners
                if (this._trowser) {
                    this._trowser.removeEventListener("show", this._listeners.onShow, false); // clean up show listener
                    this._trowser.removeEventListener("close", this._listeners.onClose, false); // clean up close listener
                    this._trowser.removeEventListener("dismiss", this._listeners.onDismiss, false); // clean up dismiss listener
                    this._trowser.removeEventListener("component-upgraded", this._listeners.componentUpgraded, false); // clean up component-upgraded listener
                }
                this._listeners = {};
            }
        }, {
            key: "render",
            value: function render() {
                /* jshint ignore:start */
                return(
                    // renders .ha-underlay and trowser outside of parent react DOM tree
                    _react2.default.createElement(
                        _HAPortal2.default,
                        { show: this.props.show },
                        _react2.default.createElement(
                            "ha-page-modal",
                            _extends({
                                ref: this.handleRef,
                                "class": this.state.classAttributes,
                                reactLayering: true
                            }, this.props),
                            _react2.default.createElement(
                                "div",
                                { className: "page-modal-panel", "aria-hidden": this.showModal },
                                _react2.default.createElement(
                                    "header",
                                    null,
                                    _react2.default.createElement(
                                        "ha-page-modal-header",
                                        { titleText: this.props.titleText, infoText: this.props.infoText, dismissible: this.props.dismissible },
                                        _react2.default.createElement(
                                            "span",
                                            { className: "header-left" },
                                            this.history
                                        ),
                                        _react2.default.createElement(
                                            "span",
                                            { className: "header-center" },
                                            _react2.default.createElement(
                                                "label",
                                                { className: "title-text pull-left" },
                                                this.props.titleText
                                            )
                                        ),
                                        _react2.default.createElement(
                                            "span",
                                            { className: "header-right pull-right" },
                                            this.info,
                                            this.help,
                                            this.settings,
                                            this.props.dismissible ? this.closeBtn : null
                                        )
                                    )
                                ),
                                _react2.default.Children.map(this.props.children, function (child) {
                                    if (child.type === _HASection2.default) {
                                        return _react2.default.createElement(
                                            "section",
                                            { key: "1", tabIndex: "-1" },
                                            child
                                        );
                                    } else if (child.type === _HATrowserFooter2.default) {
                                        return _react2.default.createElement(
                                            "footer",
                                            { key: "2", tabIndex: "-1" },
                                            child
                                        );
                                    }
                                })
                            )
                        )
                    )
                );
                /* jshint ignore:end */
            }
        }, {
            key: "info",
            get: function get() {
                if (this.props.infoText) {
                    return _react2.default.createElement(
                        "label",
                        { className: "info-text ghost-text pull-left" },
                        this.props.infoText
                    );
                }
            }
        }, {
            key: "history",
            get: function get() {
                if (this.props.history) {
                    return _react2.default.createElement(
                        "ha-page-modal-header-item",
                        { type: "history", icon: "history", position: "left", className: "pull-left" },
                        _react2.default.createElement(
                            "button",
                            { className: "header-button btn btn-link", "aria-label": "history" },
                            _react2.default.createElement("span", { className: "hi hi-history" })
                        )
                    );
                }
            }
        }, {
            key: "settings",
            get: function get() {
                if (this.props.settings) {
                    return _react2.default.createElement(
                        "ha-page-modal-header-item",
                        { type: "settings", icon: "settings-o", position: "right" },
                        _react2.default.createElement(
                            "button",
                            { className: "header-button btn btn-link", "aria-label": "settings" },
                            _react2.default.createElement("span", { className: "hi hi-settings-o" })
                        )
                    );
                }
            }
        }, {
            key: "help",
            get: function get() {
                if (this.props.help) {
                    return _react2.default.createElement(
                        "ha-page-modal-header-item",
                        { type: "help", icon: "help-o", position: "right" },
                        _react2.default.createElement(
                            "button",
                            { className: "header-button btn btn-link", "aria-label": "help" },
                            _react2.default.createElement("span", { className: "hi hi-help-o" })
                        )
                    );
                }
            }
        }, {
            key: "closeBtn",
            get: function get() {
                return _react2.default.createElement(
                    "ha-page-modal-header-item",
                    { icon: "close", position: "right", type: "close", "class": "show" },
                    _react2.default.createElement(
                        "button",
                        { className: "header-button btn btn-link", "aria-label": "close" },
                        _react2.default.createElement("span", { className: "hi hi-close" })
                    )
                );
            }
        }]);

        return HATrowser;
    }(_react2.default.Component);

    HATrowser.propTypes = {
        children: function children(props, propName, componentName) {
            var error = (0, _utils.checkReactChildrenType)(props[propName], componentName, [_HASection2.default, _HATrowserFooter2.default], "HASection,HATrowserFooter");
            if (error) {
                return error;
            }
        },
        className: _react2.default.PropTypes.string,
        titleText: _react2.default.PropTypes.string,
        infoText: _react2.default.PropTypes.string,
        type: _react2.default.PropTypes.string,
        settings: _react2.default.PropTypes.bool,
        help: _react2.default.PropTypes.bool,
        history: _react2.default.PropTypes.bool,
        dismissible: _react2.default.PropTypes.bool,
        autofocus: _react2.default.PropTypes.bool,
        noCloseOnDismiss: _react2.default.PropTypes.bool,
        onShow: _react2.default.PropTypes.func,
        onClose: _react2.default.PropTypes.func,
        onDismiss: _react2.default.PropTypes.func
    };

    var _initialiseProps = function _initialiseProps() {
        var _this6 = this;

        this.handleRef = function (c) {
            _this6._trowser = c;
        };
    };

    exports.default = HATrowser;
});
//# sourceMappingURL=HATrowser.js.map
;
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

(function (global, factory) {
    if (typeof define === "function" && define.amd) {
        define('hui-react/HAZeroState',["exports", "react", "./HAHeader", "./HASection", "./HAFooter", "hui/core/utils"], factory);
    } else if (typeof exports !== "undefined") {
        factory(exports, require("react"), require("./HAHeader"), require("./HASection"), require("./HAFooter"), require("hui/core/utils"));
    } else {
        var mod = {
            exports: {}
        };
        factory(mod.exports, global.react, global.HAHeader, global.HASection, global.HAFooter, global.utils);
        global.HAZeroState = mod.exports;
    }
})(this, function (exports, _react, _HAHeader, _HASection, _HAFooter, _utils) {
    "use strict";

    Object.defineProperty(exports, "__esModule", {
        value: true
    });

    var _react2 = _interopRequireDefault(_react);

    var _HAHeader2 = _interopRequireDefault(_HAHeader);

    var _HASection2 = _interopRequireDefault(_HASection);

    var _HAFooter2 = _interopRequireDefault(_HAFooter);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }

    var _createClass = function () {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }

        return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();

    function _possibleConstructorReturn(self, call) {
        if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
    }

    function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }

    var HAZeroState = function (_React$Component) {
        _inherits(HAZeroState, _React$Component);

        function HAZeroState() {
            _classCallCheck(this, HAZeroState);

            return _possibleConstructorReturn(this, (HAZeroState.__proto__ || Object.getPrototypeOf(HAZeroState)).apply(this, arguments));
        }

        _createClass(HAZeroState, [{
            key: "componentWillMount",
            value: function componentWillMount() {
                if (this.props.simulateViewport) {
                    var viewports = document.getElementsByName("viewport");

                    if (viewports && viewports.length > 0) {
                        viewports[0].content = "width=device-width, initial-scale=1";
                    }
                }
            }
        }, {
            key: "componentWillUnmount",
            value: function componentWillUnmount() {
                if (this.props.simulateViewport) {
                    var viewports = document.getElementsByName("viewport");

                    if (viewports && viewports.length > 0) {
                        viewports[0].content = "";
                    }
                }
            }
        }, {
            key: "renderFooter",
            value: function renderFooter(HAFooter) {
                return _react2.default.createElement(
                    "div",
                    { className: "footer zero-state-footer" },
                    HAFooter
                );
            }
        }, {
            key: "render",
            value: function render() {

                var button = undefined,
                    header = undefined,
                    section = undefined,
                    footer = undefined,
                    subTitle = undefined;

                if (this.props.buttonText) {
                    button = _react2.default.createElement(
                        "button",
                        { className: "ha-button-primary ha-button", onClick: this.props.onButtonClick },
                        this.props.buttonText
                    );
                }

                if (this.props.subTitleText) {
                    subTitle = _react2.default.createElement(
                        "span",
                        { className: "sub-title" },
                        this.props.subTitleText
                    );
                }

                if (this.props.children) {
                    _react2.default.Children.forEach(this.props.children, function (child) {
                        if (!_react2.default.isValidElement(child)) {
                            return;
                        }
                        if (child.type === _HAHeader2.default) {
                            header = child;
                        }
                        if (child.type === _HASection2.default) {
                            section = child;
                        }
                        if (child.type === _HAFooter2.default) {
                            footer = child;
                        }
                    });
                }

                return _react2.default.createElement(
                    "div",
                    { className: "ha-zero-state-container" },
                    _react2.default.createElement(
                        "div",
                        { className: "image-container zero-state-header" },
                        header
                    ),
                    _react2.default.createElement(
                        "div",
                        { className: "zero-state-content" },
                        _react2.default.createElement(
                            "div",
                            null,
                            _react2.default.createElement(
                                "span",
                                { className: "main-title" },
                                this.props.titleText
                            ),
                            subTitle
                        ),
                        _react2.default.createElement(
                            "div",
                            null,
                            section
                        ),
                        _react2.default.createElement(
                            "div",
                            null,
                            button
                        )
                    ),
                    footer && this.renderFooter(footer)
                );
            }
        }]);

        return HAZeroState;
    }(_react2.default.Component);

    HAZeroState.propTypes = {
        titleText: _react2.default.PropTypes.string,
        subTitleText: _react2.default.PropTypes.string,
        buttonText: _react2.default.PropTypes.string,
        onButtonClick: _react2.default.PropTypes.func,
        simulateViewport: _react2.default.PropTypes.bool,
        children: function children(props, propName, componentName) {
            var error = (0, _utils.checkReactChildrenType)(props[propName], componentName, [_HAHeader2.default, _HASection2.default, _HAFooter2.default], "HAHeader,HASection,HAFooter");
            if (error) {
                return error;
            }
        }
    };
    exports.default = HAZeroState;
});
//# sourceMappingURL=HAZeroState.js.map
;

define("../../build/dist/js/hui", function(){});
